# Вопросы к экзамену

- [1. Понятие алгоритма. Свойства алгоритмов.](#1-понятие-алгоритма-свойства-алгоритмов)
- [2. Способы описания алгоритмов: словесно-формульный, графический, на алгоритмическом языке.](#2-способы-описания-алгоритмов-словесно-формульный-графический-на-алгоритмическом-языке)
  - [Словесный способ](#словесный-способ)
  - [Формульно-словесный способ](#формульно-словесный-способ)
  - [Табличный способ](#табличный-способ)
  - [Графический способ](#графический-способ)
  - [Программный способ (текстовая запись)](#программный-способ-текстовая-запись)
  - [О взаимодополнении способов представления](#о-взаимодополнении-способов-представления)
- [3. Графический способ описания.](#3-графический-способ-описания)
  - [Главные элементы блок-схем алгоритмов](#главные-элементы-блок-схем-алгоритмов)
  - [Общие требования к блок-схеме](#общие-требования-к-блок-схеме)
  - [Решение алгоритма сортировки пузырьком](#решение-алгоритма-сортировки-пузырьком)
- [4. Базовые структуры алгоритмов. Виды алгоритмов](#4-базовые-структуры-алгоритмов-виды-алгоритмов)
- [5. Виды алгоритмов: линейный, разветвляющийся, циклический.](#5-виды-алгоритмов-линейный-разветвляющийся-циклический)
  - [Последовательный (линейный) алгоритм](#последовательный-линейный-алгоритм)
  - [Разветвляющиеся алгоритмы](#разветвляющиеся-алгоритмы)
  - [Циклические алгоритмы](#циклические-алгоритмы)
- [6. Принципы алгоритмизации.](#6-принципы-алгоритмизации)
  - [Этапы решения задач на ЭВМ](#этапы-решения-задач-на-эвм)
    - [I этап: Постановка задачи и её содержательный анализ](#i-этап-постановка-задачи-и-её-содержательный-анализ)
    - [II этап: Математическая формализация](#ii-этап-математическая-формализация)
    - [III этап: Алгоритмизация (построение алгоритма)](#iii-этап-алгоритмизация-построение-алгоритма)
    - [IV этап: Программирование](#iv-этап-программирование)
    - [V этап: Отладка и тестирование программы](#v-этап-отладка-и-тестирование-программы)
    - [VI этап: Проведение расчетов и анализ результатов](#vi-этап-проведение-расчетов-и-анализ-результатов)
  - [Распределение общего времени между этапами, необходимое для разработки сложных программ](#распределение-общего-времени-между-этапами-необходимое-для-разработки-сложных-программ)
  - [Общие рекомендации](#общие-рекомендации)
  - [Принципы алгоритмизации](#принципы-алгоритмизации)
  - [Принципы, лежащие в основе создания эффективных алгоритмов](#принципы-лежащие-в-основе-создания-эффективных-алгоритмов)
- [7. Разветвляющийся алгоритм. Методика составления разветвляющихся алгоритмов.](#7-разветвляющийся-алгоритм-методика-составления-разветвляющихся-алгоритмов)
  - [Разветвляющиеся алгоритмы со сложным условием. Методика составления разветвляющихся алгоритмов со сложным условием](#разветвляющиеся-алгоритмы-со-сложным-условием-методика-составления-разветвляющихся-алгоритмов-со-сложным-условием)
- [8. Циклический алгоритм. Методика составления циклических алгоритмов.](#8-циклический-алгоритм-методика-составления-циклических-алгоритмов)
- [9. Отладка и тестирование алгоритмов.](#9-отладка-и-тестирование-алгоритмов)
- [10. Структура программы на языке С#.](#10-структура-программы-на-языке-с)
- [11. Основные элементы языка С#: переменные, константы, алфавит, идентификаторы, ключевые слова, выражения, операторы.](#11-основные-элементы-языка-с-переменные-константы-алфавит-идентификаторы-ключевые-слова-выражения-операторы)
  - [Состав языка](#состав-языка)
  - [Операторы языка C#](#операторы-языка-c)
  - [Операторы следования](#операторы-следования)
  - [Операторы ветвления](#операторы-ветвления)
  - [Операторы цикла](#операторы-цикла)
  - [Операторы безусловного перехода](#операторы-безусловного-перехода)
- [12. Основные типы данных языка С#.](#12-основные-типы-данных-языка-с)
  - [Базовые типы](#базовые-типы)
- [13. Объявление переменных и констант в языке С#. Инициализация переменных.](#13-объявление-переменных-и-констант-в-языке-с-инициализация-переменных)
  - [Переменные](#переменные)
  - [Константы](#константы)
  - [Перечисления](#перечисления)
- [14. Операции и выражения в языке С#: арифметические, логические выражения. Основные математические функции.](#14-операции-и-выражения-в-языке-с-арифметические-логические-выражения-основные-математические-функции)
  - [Операции](#операции)
  - [Приоритет операций](#приоритет-операций)
  - [Выражения и преобразование типов](#выражения-и-преобразование-типов)
  - [Основные математические функции](#основные-математические-функции)
- [15. Функция ввода.](#15-функция-ввода)
- [16. Функции вывода.](#16-функции-вывода)
- [17. Условный оператор в языке С#.](#17-условный-оператор-в-языке-с)
- [18. Оператор выбора в языке С#.](#18-оператор-выбора-в-языке-с)
- [19. Циклические операторы в языке С#: цикл с предусловием, цикл с постусловием, цикл с параметром.](#19-циклические-операторы-в-языке-с-цикл-с-предусловием-цикл-с-постусловием-цикл-с-параметром)
  - [Цикл с предусловием `while`](#цикл-с-предусловием-while)
  - [Цикл с постусловием `do while`](#цикл-с-постусловием-do-while)
  - [Цикл с параметром `for`](#цикл-с-параметром-for)
  - [Вложенные циклы](#вложенные-циклы)
- [20. Операторы передачи управления `break` и `continue`.](#20-операторы-передачи-управления-break-и-continue)
  - [Оператор безусловного перехода `goto`](#оператор-безусловного-перехода-goto)
  - [Оператор выхода `break`](#оператор-выхода-break)
  - [Оператор перехода к следующей итерации цикла `continue`](#оператор-перехода-к-следующей-итерации-цикла-continue)
  - [Обработка исключений](#обработка-исключений)
    - [Оператор `try`](#оператор-try)
    - [Операторы `checked` и `unchecked`](#операторы-checked-и-unchecked)
    - [Генерация собственных исключений](#генерация-собственных-исключений)
- [21. Методы в С#](#21-методы-в-с)
  - [Основные понятия](#основные-понятия)
  - [Перегрузка методов](#перегрузка-методов)
- [22. Понятие массива. Объявление и инициализация одномерного массива в языке С#.](#22-понятие-массива-объявление-и-инициализация-одномерного-массива-в-языке-с)
  - [Одномерные массивы](#одномерные-массивы)
  - [Массивы и исключения](#массивы-и-исключения)
  - [Массив как параметр](#массив-как-параметр)
  - [Массив как объект](#массив-как-объект)
- [23. Понятие массива. Объявление и инициализация многомерного массива в языке С#.](#23-понятие-массива-объявление-и-инициализация-многомерного-массива-в-языке-с)
  - [Многомерные массивы](#многомерные-массивы)
  - [Ступенчатые массивы](#ступенчатые-массивы)
  - [Оператор `foreach` и его использование при работе с массивами](#оператор-foreach-и-его-использование-при-работе-с-массивами)
- [24. Строки в языке С#. Функции для работы со строками.](#24-строки-в-языке-с-функции-для-работы-со-строками)
  - [Символы `char`](#символы-char)
  - [Неизменяемые строки `string`](#неизменяемые-строки-string)
  - [Изменяемые строки](#изменяемые-строки)
  - [Регулярные выражения](#регулярные-выражения)
    - [Метасимволы в регулярных выражениях](#метасимволы-в-регулярных-выражениях)
    - [Поиск в тексте по шаблону](#поиск-в-тексте-по-шаблону)
    - [Редактирование текста](#редактирование-текста)
    - [Группировка соответствий](#группировка-соответствий)
- [25. Функции в языке С#. Структура функции. Вызов функции. Прототип функции.](#25-функции-в-языке-с-структура-функции-вызов-функции-прототип-функции)
- [26. Рекурсивные функции.](#26-рекурсивные-функции)
- [27. Область видимости переменных. Локальные и глобальные переменные. Статические и динамические переменные](#27-область-видимости-переменных-локальные-и-глобальные-переменные-статические-и-динамические-переменные)
  - [Неявно типизированные переменные](#неявно-типизированные-переменные)
    - [Ключевое слово `var` и анонимные типы](#ключевое-слово-var-и-анонимные-типы)
  - [DLR в C#. Ключевое слово dynamic](#dlr-в-c-ключевое-слово-dynamic)
- [28. Ввод/вывод в С#. Форматированный ввод/вывод в С#.](#28-вводвывод-в-с-форматированный-вводвывод-в-с)
  - [Байтовый поток](#байтовый-поток)
  - [Символьный поток](#символьный-поток)
  - [Двоичные потоки](#двоичные-потоки)
  - [Перенаправление стандартных потоков](#перенаправление-стандартных-потоков)
- [29. Файловый ввод/вывод в С#. Функции для работы с файлами.](#29-файловый-вводвывод-в-с-функции-для-работы-с-файлами)
  - [Работа с каталогами](#работа-с-каталогами)
    - [Абстрактный класс `FileSystemInfo`](#абстрактный-класс-filesysteminfo)
    - [Класс `DirectoryInfo`](#класс-directoryinfo)
    - [Класс `Directory`](#класс-directory)
  - [Работа с файлами](#работа-с-файлами)
    - [Класс `Filelnfo`](#класс-filelnfo)
    - [Класс `File`](#класс-file)
- [30. Структуры в языке С#. Определение и инициализация структуры. Создание экземпляра структуры.](#30-структуры-в-языке-с-определение-и-инициализация-структуры-создание-экземпляра-структуры)
  - [Интерфейсы](#интерфейсы)
  - [Стандартные интерфейсы .Net](#стандартные-интерфейсы-net)
  - [Структуры](#структуры)
  - [Интерфейсы `System.Collection`](#интерфейсы-systemcollection)
  - [Коллекции](#коллекции)
  - [Коллекции общего назначения](#коллекции-общего-назначения)
  - [Класс `Stack`](#класс-stack)
  - [Класс `Queue`](#класс-queue)
  - [Класс `ArrayList`](#класс-arraylist)
  - [Класс `Hashtable`](#класс-hashtable)
- [31. Базовые понятия ООП: объект, его свойства и методы, класс. Основные принципы ООП: инкапсуляция, наследование, полиморфизм.](#31-базовые-понятия-ооп-объект-его-свойства-и-методы-класс-основные-принципы-ооп-инкапсуляция-наследование-полиморфизм)
- [32.Классы в С#.](#32классы-в-с)
  - [Основные понятия](#основные-понятия-1)
  - [Данные: поля и константы](#данные-поля-и-константы)
  - [Методы](#методы)
  - [Конструкторы](#конструкторы)
    - [Конструкторы экземпляра](#конструкторы-экземпляра)
    - [Конструкторы класса](#конструкторы-класса)
  - [Свойства](#свойства)
  - ["Один класс — один файл"](#один-класс--один-файл)
  - [Иерархия классов](#иерархия-классов)
  - [Наследование](#наследование)
  - [Использование защищенного доступа](#использование-защищенного-доступа)
  - [Наследование конструкторов](#наследование-конструкторов)
  - [Многоуровневая иерархия](#многоуровневая-иерархия)
  - [Переменные базового класса и производного класса](#переменные-базового-класса-и-производного-класса)
  - [Виртуальные методы](#виртуальные-методы)
  - [Абстрактные методы и классы](#абстрактные-методы-и-классы)
  - [Запрет наследования](#запрет-наследования)

1. Понятие алгоритма. Свойства алгоритмов.
2. Способы описания алгоритмов: словесно-формульный, графический, на алгоритмическом языке.
3. Графический способ описания.
4. Базовые структуры алгоритмов. Виды алгоритмов
5. Виды алгоритмов: линейный, разветвляющийся, циклический.
6. Принципы алгоритмизации.
7. Разветвляющийся алгоритм. Методика составления разветвляющихся алгоритмов.
8. Циклический алгоритм. Методика составления циклических алгоритмов.
9.  Отладка и тестирование алгоритмов.
10. Структура программы на языке С#.
11. Основные элементы языка С#: переменные, константы, алфавит, идентификаторы, ключевые слова, выражения, операторы.
12. Основные типы данных языка С#.
13. Объявление переменных и констант в языке С#. Инициализация переменных.
14. Операции и выражения в языке С#: арифметические, логические выражения. Основные математические функции.
15. Функция ввода.
16. Функции вывода.
17. Условный оператор в языке С#.
18. Оператор выбора в языке С#.
19. Циклические операторы в языке С#: цикл с предусловием, цикл с постусловием, цикл с параметром.
20. Операторы передачи управления break и continue.
21. Методы в С#
22. Понятие массива. Объявление и инициализация одномерного массива в языке С#.
23. Понятие массива. Объявление и инициализация многомерного массива в языке С#.
24. Строки в языке С#. Функции для работы со строками.
25. Функции в языке С#. Структура функции. Вызов функции. Прототип функции.
26. Рекурсивные функции.
27. Область видимости переменных. Локальные и глобальные переменные. Статические и динамические переменные
28. Ввод/вывод в С#.  Форматированный ввод/вывод в С#.
29. Файловый ввод/вывод в С#. Функции для работы с файлами.
30. Структуры в языке С#. Определение и инициализация структуры. Создание экземпляра структуры.
31. Базовые понятия ООП: объект, его свойства и методы, класс. Основные принципы ООП: инкапсуляция, наследование, полиморфизм.
32. Классы в С#.

## 1. Понятие алгоритма. Свойства алгоритмов.

**Алгоритм** – это система последовательных операций (в соответствии с определёнными правилами) для решения поставленной задачи, понятное и точное предписание (указание) исполнителю совершить последовательность действий, направленных на достижение указанной цели или на решение поставленной задачи.

Исполнитель выполняет алгоритм **формально**.

**Система команд исполнителя** (**СКИ**) — совокупность команд, которые данный исполнитель умеет выполнять. Совокупность всех действий, которые исполнитель может выполнить в ответ на эти команды, называется **системой допустимых действий** Исполнителя.

**Свойства алгоритма**

1. Дискретность
2. Понятность (единственность толкования)
3. Определённость (детерминированность — обязательное завершение каждого из действий)
4. Конечность (результативность)
5. Выполнимость (эффективность)
6. Массовость (универсальность — возможность применения для целого класса задач)
7. Однозначность

## 2. Способы описания алгоритмов: словесно-формульный, графический, на алгоритмическом языке.
https://otus.ru/nest/post/1769/

**Алгоритмом** (algorithm) называют чёткое описание последовательности действий, направленных на решение конкретной задачи.

Способы описания алгоритмов:

- словесный (вербальный);
- графический (блок-схемы);
- математический (формулами);
- алгоритмические языки (программа).

### Словесный способ
Словесное описание алгоритма предполагает наличие некого словесного перечня действий. Пример: вам говорят что-то типа следующего: «Вычислите Z при условии, что Z = X + Y, когда X равен 0,89, а Y равен 1,286. Полученное значение Z следует возвести в куб и вычислить корень».

У такого способа есть недостаток: отсутствие наглядности выполнения процесса и чёткой формализации объектов алгоритма.

### Формульно-словесный способ
При использовании формульно-словесного способа инструкции задаются более чётко. Этот тот случай, когда словесные пояснения сопровождаются перечнем конкретных действий, плюс эти пояснения характеризуются наличием формальных символов и выражений (формул).

Для примера составим **формульно-словесный алгоритм** вычисления выражения: $z=2 \cdot x–(y+6)$:
- вводим значения $x$ и $y$;
- находим сумму ($y+6$);
- находим произведение ($2 \cdot x$);
- вычисляем $z$ как разность уже полученных выше значений: $z=2 \cdot x–(y+6)$;
- выводим $z$ как результат вычисления выражения.

Это более компактный и лаконичный метод, он нагляднее, но всё же строго формальным не является.

### Табличный способ
В случае применения табличного метода алгоритм задаётся в виде входных данных: расчётных форм и таблиц. Способ широко применяется в экономических расчетах. Исходные данные, как и результаты, заносятся в заголовки столбцов используемой таблицы. Простейший пример такого способа представления — та же таблица умножения.

### Графический способ
Этот метод ещё называют **способом блок-схем**. В данной ситуации каждый этап прохождения алгоритма представляется в виде геометрических фигур — так называемых «блоков», причём конкретная форма фигур зависит от выполняемой операции. Существует стандарт, регламентирующий размеры используемых графических блоков, а также их отображение, функции, формы и взаимное расположение. Направление работы алгоритма показывают линии соединения блоков.

Другое название способа — **визуальное представление**. При проектировании алгоритмов, представленных графически, придерживаются ряда правил:
- в начале алгоритма располагаются блоки ввода значений (входные данные);
- после ввода значений располагаются блоки обработки и блоки условия;
- алгоритм завершается блоками вывода значений, полученных в результате работы алгоритма (выходные данные);
- должен быть лишь один блок начала и один — окончания;
- межблочная связь указывается линиями (направленными либо ненаправленными);
- вычислительные формулы, данные и логические выражения размещаются внутри соответствующих блоков;
- возможно наличие комментариев в виде выносок.

![Основные элементы блок-схем](../img/img-fZfgBD.png)

Графический способ представления имеет практическое значение и используется не только в случае программирования. Его применяют при составлении информационных и структурных схем, инфографики и в иных ситуациях, когда нужно обеспечить чёткую визуализацию данных и графически отобразить последовательность расположения объектов алгоритма.

Создание блок-схемы алгоритма — важный и нужный этап решения поставленной задачи. Но при некоторых обстоятельствах этот этап можно считать промежуточным, так как в таком виде описанный алгоритм невозможно выполнить средствами ЭВМ. Зато графический способ представления значительно облегчает процесс дальнейшего создания компьютерной программы. О ней ниже.

### Программный способ (текстовая запись)
Программа представляет собой алгоритм, который записан как последовательность команд. Речь идёт о командах, понятных компьютеру, для чего используются различные языки программирования, представляющие собой системы кодирования предписаний с правилами их применения. Языки программирования характеризуются строго определённым синтаксисом, то есть свободное толкование конструкций не допускается.

В случае программного способа представления алгоритмическая последовательность записывается в виде компьютерной программы с высокой степенью формализации. В результате появляется возможность решать прикладные задачи.

### О взаимодополнении способов представления
Способы, представленные выше, нередко являются взаимодополняемыми:
- на этапе обсуждения используются словесные и словесно-формульные способы;
- на этапе проектирования рекомендуется использовать графические алгоритмы (графическое представление);
- на этапе проверки возможно табличное описание;
- на этапе непосредственного применения и решения прикладных задач используют текстовую запись, представленную в виде компьютерной программы.

## 3. Графический способ описания.
https://otus.ru/nest/post/1778/

**Блок-схема** — графическое изображение структуры алгоритма, в котором каждый этап процесса переработки данных представляется в виде геометрических фигур (блоков), имеющих определенную конфигурацию в зависимости от характера выполняемых при этом операций.

Существуют правила, единые обозначения и стандарты, регламентирующие применение визуального отображения схем алгоритмов. В России это ГОСТ 19.701-90 «Схемы алгоритмов программ, данных и систем», который близок к международному стандарту ISO 5807:1985.

### Главные элементы блок-схем алгоритмов
Прежде чем продолжить, стоит дать определение **блок-схемы** в соответствии со стандартом — речь идёт о совокупности символов, которые отвечают этапам работы алгоритма, причём эти символы имеют соединяющие линии:
- **пунктирную** — для соединения с комментарием;
- **сплошную** — отображает зависимости по управлению, допускается наличие на ней стрелки.

В соответствии со стандартом составитель может не указывать стрелку, если дуга направляется сверху вниз или слева направо.

Также существуют и дополнительные виды линий, которые применяются, когда надо дать описание блок-схемам параллельных алгоритмов, однако в этой статье мы их рассматривать не будем, как и ряд других дополнительных спецсимволов.

В таблице ниже дан перечень основных символов, используемых при описании алгоритмов:

![Основные элементы блок-схем](../img/Screenshot_1-1801-c116d0.png)

![Flowchart items](../img/algos-block-schemes.png)

![Flowchart items](../img/algo-block-scheme-0.png)

![Flowchart items](../img/algo-block-scheme-1.png)

![Flowchart items](../img/algo-block-scheme-2.png)

![Flowchart items](../img/algo-block-scheme-3.png)

### Общие требования к блок-схеме

https://prohor-off.ru/pascal/pascal2.html#:~:text=%D0%A2%D0%B8%D0%BF%D1%8B%20%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%BE%D0%B2.,%D0%B8%20%D0%B8%D0%BC%D0%B5%D0%B5%D1%82%20%D0%BD%D0%B5%D1%81%D0%BA%D0%BE%D0%BB%D1%8C%D0%BA%D0%BE%20%D0%B2%D0%B5%D1%82%D0%B2%D0%B5%D0%B9%20%D0%BE%D0%B1%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B8.

- Стрелки в блок—схемах указываются только справа — налево и снизу — вверх.
- Блоки рисуются карандашом по линейке, текст пишется ручкой.
- Ширина всех блоков должна быть одинакова (блоки должны располагаться друг под другом).
- Все блоки алгоритма нумеруются.

### Решение алгоритма сортировки пузырьком
В этом примере давайте попробуем дать описание решению алгоритма сортировки по методу пузырьком (метод сортировки вставками). Здесь применяются 2 цикла. Во вложенном цикле осуществляется попарное сравнение элементов. Если нарушается порядок, происходит перестановка. По итогу выполнения одной итерации во внутреннем цикле, наибольший элемент будет смещён в самый конец массива. Внешний цикл будет выполняться, пока полностью весь массив не отсортируется.

![Блок-схема алгоритма сортировки пузырьком](../img/Screenshot_3-1801-3fbca6.avif)

На схеме отображено применение символов конца и начала цикла. Здесь условие внешнего цикла (`А`) проверяется в конце (с постусловием), а функционирует он до тех пор, пока переменная `hasSwapped` является `true`. Во внутреннем цикле используется предусловие для перебора пар элементов, которые сравниваются. Если они располагаются в неправильном порядке, они переставляются путём вызова внешней процедуры (`swap`). Для понимания назначения внешней процедуры, как и порядка следования аргументов этой процедуры, нужно оставлять комментарии. Если функция возвращает значение, то комментарий можно написать к символу-терминатору конца.

## 4. Базовые структуры алгоритмов. Виды алгоритмов

В 1969 году нидерландский ученый Эдсгер Дийкстра доказал важную теорему. Суть ее в том, что для решения любой логической задачи можно составить алгоритм, используя лишь три алгоритмических структуры: *следование*, *ветвление* и *повторение*. Эти структуры называют **базовыми**. В соответствии с этим различают три основных типа структур алгоритма:

- линейный (следование);
- альтернативный (разветвление);
- циклический (повторение, итерация).

Соответственно этим структурам выделяют следующие виды алгоритмов (по ходу выполнения):

- последовательный;
- разветвлённый;
- циклический.

Самой простой структурой является **«следование**».

Алгоритм реализован через последовательную алгоритмическую структуру, если все команды этого алгоритма выполняются один раз, причем в том порядке, в котором они записаны.

Алгоритм, основанный на конструкции «следование» называется **линейным алгоритмом**. Примером такого алгоритма может служить алгоритм вычисления дискриминанта квадратного уравнения, блок-схема которого приведена на рисунке 1.

![Линейный алгоритм](../img/189d6b2e-f240-4a57-84d2-9cda9492d4c5.png)

**Рис. 1**

Следующей конструкцией является **«ветвление»**. Она встречается, если действия алгоритма зависят от некоторого условия.

Алгоритм реализован через алгоритмическую конструкцию «ветвление», если от входных данных зависит, какие команды будут выполняться. Условие, которое выражает эту зависимость, фактически является вопросом, на который можно ответить либо «да», либо «нет».

Существуют полная и неполная формы ветвления.

В полной форме если условие выполняется, то алгоритм переходит к выполнению первой серии команд, а если не выполняется — то ко второй.

В неполной форме алгоритм выполняет серию команд только если условие истинно. В противном случае ничего не происходит.

Алгоритм, основанный на конструкции «ветвление» называется **разветвляющимся алгоритмом**. Примером такого алгоритма может служить алгоритм нахождения корней квадратного уравнения, блок-схема которого приведена на рисунке 2.

![Разветвляющийся алгоритм](../img/ea5d55a4-b598-437f-8466-bed779d81bb2.png)

**Рис. 2**

И, наконец, последняя алгоритмическая конструкция — «**повторение**».

Алгоритм реализован с использованием алгоритмической конструкции «повторение», если некая группа подряд идущих шагов алгоритма (она называется телом цикла) может выполняться многократно в зависимости от входных данных.

Алгоритм, содержащий конструкцию «повторение» называется **циклическим алгоритмом**.

Существует несколько разновидностей циклических алгоритмов.

Первый — **цикл с заданным условием продолжения работы** (цикл с предусловием или цикл-пока).

Второй — **цикл с заданным условием окончания работы** (цикл с постусловием или цикл-до).

И третий — **цикл с заданным числом повторений** (цикл с параметром).

![Циклический алгоритм](../img/4e287700-accd-44ba-9988-6395cd366d8d.png)

Доказано, что при решении задач можно ограничиться только одним циклом — циклом с предусловием. Но в ряде случаев цикл с постусловием или цикл с параметром делают решение задачи легче.

Примером решения одной и той же задачи с помощью различных циклов может служить задача возведения некоторого числа $a$ в натуральную степень $n$.

![Решение задачи разными циклами](../img/9e9d2b8d-8156-43b1-8828-f84a97fc6935.png)

## 5. Виды алгоритмов: линейный, разветвляющийся, циклический.

Алгоритмы бывают трёх типов:

- **последовательный** — действия выполняются по порядку друг за другом;
- **циклический** — организовывает повторение действий;
- **разветвляющийся** — содержит одно или несколько логических условий и имеет несколько ветвей обработки. Разветвление даёт возможность выбора варианта действий в зависимости от результатов анализа исходных условий.

### Последовательный (линейный) алгоритм

Самой простой структурой является **«следование**». Простейшие задачи имеют **линейный алгоритм** решения (имееют структуру"следование").

Алгоритм реализован через последовательную алгоритмическую структуру, если все команды этого алгоритма выполняются один раз, причем в том порядке, в котором они записаны. Алгоритм линейной структуры представляет собой последовательность действий и не содержит каких-либо *условий*.

<div style="background-color: white">

![](../img/al09.gif)

</div>

Алгоритм, основанный на конструкции «следование» называется **линейным алгоритмом**. Примером такого алгоритма может служить алгоритм вычисления дискриминанта квадратного уравнения, блок-схема которого приведена на рисунке 1.

![Линейный алгоритм](../img/189d6b2e-f240-4a57-84d2-9cda9492d4c5.png)

**Рис. 1**

Таким образом, в таких алгоритмах все этапы решения задачи выполняются строго последовательно, т.е. линейные алгоритмы выполняются в естественном порядке его написания и не содержит разветвлений и повторений.

```mermaid
flowchart TB
process1[Действие 1] --- process2[Действие 2] --- process3[Действие 3]
```

На практике линейные алгоритмы в чистом виде встречаются редко: при расчете арифметических и алгебраических выражений, при расчете по формулам, при решении ряда бытовых задач.

Существует несколько способов решения систем линейных уравнений, которые в основном делятся на два типа:
1) точные методы, представляющие собой конечные алгоритмы для вычисления корней системы,
2) итерационные методы, позволяющие получать корни системы с заданной точностью путем сходящихся бесконечных процессов.

### Разветвляющиеся алгоритмы

<div style="background-color: white">

| Условный оператор `IF` (полная запись) | Условный оператор `IF` (краткая запись) | Оператор выбора `CASE` |
-- | -- | --
![](../img/al14.gif) | ![](../img/al15.gif) | ![](../img/al16.gif)

</div>

Следующей конструкцией является **«ветвление»**. Она встречается, если действия алгоритма зависят от некоторого условия.

Алгоритм реализован через алгоритмическую конструкцию «ветвление», если от входных данных зависит, какие команды будут выполняться. Условие, которое выражает эту зависимость, фактически является вопросом, на который можно ответить либо «да», либо «нет».

Существуют полная и неполная формы ветвления.

В полной форме если условие выполняется, то алгоритм переходит к выполнению первой серии команд, а если не выполняется — то ко второй.

В неполной форме алгоритм выполняет серию команд только если условие истинно. В противном случае ничего не происходит.

Алгоритм, основанный на конструкции «ветвление» называется **разветвляющимся алгоритмом**. Примером такого алгоритма может служить алгоритм нахождения корней квадратного уравнения, блок-схема которого приведена на рисунке 2.

![Разветвляющийся алгоритм](../img/ea5d55a4-b598-437f-8466-bed779d81bb2.png)

### Циклические алгоритмы

<div style="background-color: white">

| Безусловный оператор цикла `FOR` | Условный оператор цикла с предусловием `WHILE` | Условный оператор цикла с постусловием `REPEAT` |
-- | -- | --
![](../img/al12.gif) | ![](../img/al13.gif) | ![](../img/al11.gif)

</div>

И, наконец, последняя алгоритмическая конструкция — «**повторение**».

Алгоритм реализован с использованием алгоритмической конструкции «повторение», если некая группа подряд идущих шагов алгоритма (она называется телом цикла) может выполняться многократно в зависимости от входных данных.

Алгоритм, содержащий конструкцию «повторение» называется **циклическим алгоритмом**.

Существует несколько разновидностей циклических алгоритмов.

Первый — **цикл с заданным условием продолжения работы** (цикл с предусловием или цикл-пока).

Второй — **цикл с заданным условием окончания работы** (цикл с постусловием или цикл-до).

И третий — **цикл с заданным числом повторений** (цикл с параметром).

![Циклический алгоритм](../img/4e287700-accd-44ba-9988-6395cd366d8d.png)

Доказано, что при решении задач можно ограничиться только одним циклом — циклом с предусловием. Но в ряде случаев цикл с постусловием или цикл с параметром делают решение задачи легче.

Примером решения одной и той же задачи с помощью различных циклов может служить задача возведения некоторого числа $a$ в натуральную степень $n$.

![Решение задачи разными циклами](../img/9e9d2b8d-8156-43b1-8828-f84a97fc6935.png)

## 6. Принципы алгоритмизации.

### Этапы решения задач на ЭВМ

| | | |
-- | -- | --
| 1. | Постановка задачи. | Работа без ЭВМ
| 2. | Математическая формализация. | Работа без ЭВМ
| 3. | Алгоритмизация. | Работа без ЭВМ
| 4. | Программирование | Работа на ЭВМ
| 5. | Отладка и тестирование программы | Работа на ЭВМ
| 6. | Проведение расчетов и анализ результатов |

#### I этап: Постановка задачи и её содержательный анализ

① Формируется условие задачи:

1. Что дано? (Анализ исходных данных) → **аргументы**
2. Что необходимо определить? → **результат**
3. Какие данные допустимы и в каких единицах измерения?
4. Какие результаты и в каком виде должны быть получены?

② Всем величинам присвоить имена.

#### II этап: Математическая формализация

Реально существующие объекты, предметы, явления заменяются математическими формулами.

#### III этап: Алгоритмизация (построение алгоритма)

При разработке алгоритма решения сложной задачи следует использовать метод структурного подхода:

1. Алгоритм собирается из 3-х основных базовых структур.
2. Разработка алгоритма «сверху вниз».
3. Сквозной структурный контроль.

**Сквозной структурный контроль** представляет собой совокупность технологических операций контроля, позволяющих обеспечить как можно более раннее обнаружение ошибок в процессе разработки. Термин «сквозной» в названии отражает выполнение контроля на всех этапах разработки. Термин «структурный» означает наличие четких рекомендаций по выполнению контролирующих операций на каждом этапе.

Сквозной структурный контроль должен выполняться на специальных контрольных сессиях, в которых, помимо разработчиков, могут участвовать специально приглашенные эксперты. Одна из первых сессий должна быть организована на этапе определения спецификаций. На этой сессии проверяют полноту и точность спецификаций, при этом целесообразно присутствие заказчика или специалиста по предметной области, которые смогут определить, насколько правильно и полно определены спецификации программного обеспечения.

На этапе проектирования вручную по частям проверяют алгоритмы разрабатываемого программного обеспечения на конкретных наборах данных и сверяют полученные результаты с соответствующими спецификациями. Основная задача – убедиться в правильности понимания спецификаций и проанализировать достоинства и недостатки концептуальных решений, закладываемых в проект.

На этапе реализации проверяют план (последовательность) реализации модулей, набор тестов, а также тексты отдельных модулей.

Для всех этапов целесообразно иметь списки наиболее часто встречающихся ошибок, которые формируют по литературным источникам и исходя из опыта предыдущих разработок. Такие списки позволяют сконцентрировать усилия на конкретных моментах, а не проверять все подряд. При этом все найденные ошибки фиксируют в специальном документе, но не исправляют их (более подробно см. §9.2).

Помимо раннего обнаружения ошибок, сквозной структурный контроль обеспечивает своевременную подготовку качественной документации по проекту.

https://studfile.net/preview/2007545/page:17/

#### IV этап: Программирование

- выбор языка программирования;
- запись алгоритма на выбранном языке программирования.

#### V этап: Отладка и тестирование программы

Ошибки программы:

- синтаксические;
- логические.

**Тест** – набор исходных данных, для которых заранее известен результат.

#### VI этап: Проведение расчетов и анализ результатов

Производится расчет программы (выполнение на ЭВМ).

После выполнения программы необходимо провести обработку и осмысление результатов.

### Распределение общего времени между этапами, необходимое для разработки сложных программ

![Распределение времени между этапами](../img/algos-time-distribution.png)

### Общие рекомендации

1. Необходимо создать программу универсальной.
2. Вместо констант лучше использовать переменные.
3. Программа должна иметь комментарии.

### Принципы алгоритмизации
https://studfile.net/preview/9012806/page:3/

На сегодняшний день самой популярной методикой программирования является **структурное программирование** "сверху – вниз". Эта технология программирования представляет собой процесс пошагового разбиения алгоритма на все более мелкие части с целью получить такие элементы, для которых можно легко написать конкретные предписания.

Структурная алгоритмизация основывается на двух принципах:

1) последовательная детализация "сверху - вниз";

2) ограниченность базового набора структур для построения алгоритмов любой степени сложности.

Из принципов вытекают требования структурного программирования:

1) программа должна составляться мелкими шагами, таким образом, сложная задача разбивается на достаточно простые, легко воспринимаемые части;

2) логика программы должна опираться на минимальное число достаточно простых базовых управляющих структур.

Базовый набор структурной алгоритмизации содержит линейные, разветвляющиеся и циклические структуры.

Можно перечислить основные свойства и достоинства структурного программирования:

1) возможность преодоления барьера сложности программ;

2) возможность демонстрации правильности программ на различных этапах решения задачи;

3) наглядность программ;

4) простота модификации программ.

### Принципы, лежащие в основе создания эффективных алгоритмов
https://studfile.net/preview/9012806/page:3/

Разработке алгоритма предшествуют такие этапы, как **формализация и моделирование** задачи. **Формализация** предполагает замену словесной формулировки решаемой задачи краткими символьными обозначениями, близкими к обозначениям в языках программирования или к математическим. **Моделирование** задачи является важнейшим этапом, целью которого является поиск общей концепции решения. Обычно моделирование выполняется путем выдвижения гипотез решения задачи и их проверке любым рациональным способом (прикидочные расчеты, физическое моделирование и т.д.). Результатом каждой проверки является либо принятие гипотезы, либо отказ от нее и разработка новой.

При разработке алгоритма используют следующие основные принципы.

1. **Принцип поэтапной детализации алгоритма** (другое название — "проектирование сверху-вниз"). Этот принцип предполагает первоначальную разработку алгоритма в виде укрупненных блоков (разбиение задачи на подзадачи) и их постепенную детализацию.

2. **Принцип "от главного к второстепенному"**, предполагающий составление алгоритма, начиная с главной конструкции. При этом, часто, приходится "достраивать" алгоритм в обратную сторону, например, от середины к началу.

3. **Принцип структурирования**, т.е. использования только типовых алгоритмических структур при построении алгоритма. Нетиповой структурой считается, например, циклическая конструкция, содержащая в теле цикла дополнительные выходы из цикла. В программировании нетиповые структуры появляются в результате злоупотребления командой безусловного перехода (GoTo). При этом программа хуже читается и труднее отлаживается.

## 7. Разветвляющийся алгоритм. Методика составления разветвляющихся алгоритмов.
**Разветвляющийся алгоритм** – это такой алгоритм, в котором в зависимости от выполнения некоторого условия совершается либо одна, либо другая последовательность действий.

В таких алгоритмах делается выбор: выполнять или не выполнять какую-нибудь группу команд в зависимости от условия, т.е. выбирается один из нескольких возможных путей (вариантов) вычислительного процесса. Каждый подобный путь называется **ветвью алгоритма**.

Для изображения разветвляющегося алгоритма используется ветвление, при котором выполнение программы идет по одной из двух, нескольких или множества ветвей. Выбор ветви зависит от условия на входе ветвления и поступивших сюда данных.

Признаком разветвляющегося алгоритма является наличие операций условного перехода, когда происходит проверка истинности некоторого логического выражения (проверяемое условие) и в зависимости от истинности или ложности проверяемого условия для выполнения выбирается та или иная ветвь алгоритма.

**Логическое выражение** – такое выражение, результатом вычисления которого является «истина» или «ложь».

В логических выражениях используется операция сравнения: `<` (меньше), `>` (больше), `<=` (меньше или равно), `>=` (больше или равно), `=` (равно), `<>` (не равно). Часто встречаются задачи, в которых используются не отдельные условия, а совокупность связанных между собой условий (отношений). Для связи используются `AND` и (или) `OR`.

**Полная форма** ветвления предусматривает организацию выполнения двух разных наборов команд, из которых выполняется только один. В **сокращенной форме** один из наборов команд (чаще по ответу «Нет») опускается. В этом случае, если условие ложное, то никакие действия не выполняются.

![Full branching](../img/htmlconvd-YZcaOw_html_2455fac2d1c522a1.jpg)

Алгоритм предполагает выполнение *Действия 1*, если записанное условие истинно (выполняется), и выполнение *Действия 2*, если условие ложно (не выполняется) – это полная развилка.

![Short branching](../img/htmlconvd-YZcaOw_html_f6a5e67bc274ae33.jpg)

Если в алгоритме отсутствует Действие 2, т.е. если записанное условие истинно, то выполняется Действие 1, а если условие ложно, то никаких действий не выполняется – это не полная развилка.

### Разветвляющиеся алгоритмы со сложным условием. Методика составления разветвляющихся алгоритмов со сложным условием
Признаком является наличие операций проверки условий. Сложное условие или составное состоит из двух простых условий, связанных логическими операциями (не, и или).

## 8. Циклический алгоритм. Методика составления циклических алгоритмов.
https://studfile.net/preview/9012806/page:5/

Алгоритм реализован с использованием алгоритмической конструкции «повторение», если некая группа подряд идущих шагов алгоритма (она называется телом цикла) может выполняться многократно в зависимости от входных данных.

Алгоритм, содержащий конструкцию «повторение» называется **циклическим алгоритмом**.

Циклические алгоритмы являются наиболее распространенным видом алгоритмов, в них предусматривается повторное выполнение определенного набора действий при выполнении некоторого условия. Такое повторное выполнение часто называют **циклом**.

Существуют два основных видов циклических алгоритмов: циклические алгоритмы с **предусловием**, циклические алгоритмы с **постусловием**. Они отличаются друг от друга местоположением условия выхода их цикла.

**Цикл с предусловием** начинается с проверки условия выхода из цикла. Это логическое выражение, например $I<=6$. Если оно истинно, то выполняются те действия, которые должны повторяться. В противном случае, если логическое выражение $I<=6$ ложно, то этот цикл прекращает свои действия.

**Цикл с постусловием** функционирует иначе. Сначала выполняется один раз те действия, которые подлежат повторению, затем проверяется логическое выражение, определяющее условие выхода из цикла, например, $I>6$. Проверка его осуществляется тоже по-другому. Если условие выхода истинно, то цикл с постусловием прекращает свою работу, в противном случае происходит повторение действий, указанных в цикле. Повторяющиеся действия в цикле называются "**телом цикла**".

Разновидности циклических алгоритмов:
- **цикл с заданным условием продолжения работы** (цикл с предусловием или цикл-пока);
- **цикл с заданным условием окончания работы** (цикл с постусловием или цикл-до);
- **цикл с заданным числом повторений** (цикл с параметром).

![Циклический алгоритм](../img/4e287700-accd-44ba-9988-6395cd366d8d.png)

Доказано, что при решении задач можно ограничиться только одним циклом — циклом с предусловием. Но в ряде случаев цикл с постусловием или цикл с параметром делают решение задачи легче.

Примером решения одной и той же задачи с помощью различных циклов может служить задача возведения некоторого числа $a$ в натуральную степень $n$.

![Решение задачи разными циклами](../img/9e9d2b8d-8156-43b1-8828-f84a97fc6935.png)

## 9. Отладка и тестирование алгоритмов.
https://studfile.net/preview/9012806/page:4/

**Отладка алгоритма** – это процесс выявления и исправления ошибок в нём. Суть отладки алгоритма в том, что выбирается некоторый набор исходных данных, называемый *тестовым набором* (*тестом*), и задача с этим набором решается дважды: один раз — исполнением алгоритма, второй раз — каким-либо иным способом, исходя из условия задачи (например, вручную). При совпадении результатов алгоритм считается верным.

**Задачи отладки**. При всех методах отладки алгоритмов система отладки с той или иной степенью автоматизации должна решать следующие задачи:
- обнаруживать наличие ошибок;
- проводить диагностику и локализацию ошибок;
- устранять ошибки и корректировать алгоритмы и программы, а также соответствующую документацию;
- информировать оператора о ходе, вычислений, переменных величинах и передачах управления в отлаживаемых алгоритмах и программах.

Самыми сложными среди перечисленных являются задачи обнаружения, диагностики и локализации ошибок.

**Тест** – набор исходных данных, для которых заранее известен результат.

**Тестирование** – это проверка в процессе эксперимента соответствия (*конформности*) реализации требованиям, заданным в виде спецификации. Тестирование **полное**, если оно однозначно отвечает на вопрос: есть в реализации ошибки или нет, где под ошибкой понимается нарушение требований, то есть *неконформность*.

Набор тестов называется **значимым**, если каждая конформная реализация его проходит; **исчерпывающий**, если каждая неконформная реализация его не проходит; **полный**, если он значимый и исчерпывающий.

**Избыточное тестирование** — тестирование алгоритма со всеми возможными комбинациями всех возможных входных данных во всех возможных условиях выполнения.

Тестирование алгоритма позволяет выявить логические ошибки построения алгоритма. Подобные ошибки можно обнаружить при тестировании алгоритма на большом количестве различных тестовых наборов данных, так как далеко не при каждом сочетании входных данных логические ошибки построения алгоритма дают о себе знать. Следовательно, эффективное проектирование текстовых наборов данных - задача достаточно сложная.

**Структурное тестирование** основывается на детальном изучении логики алгоритма и подборе тестов, позволяющих обеспечить максимально возможное количество проверяемых операторов, логических ветвлений и условий.

При использовании структурного тестирования для построения тестовых наборов данных возможно использование следующих критериев:

1) набор данных должен обеспечивать выполнение каждого оператора, по крайней мере, один раз;

2) тестовые наборы данных в узлах ветвления с более чем одним условием должны обеспечивать принятие каждым условием значения истина или ложь хотя бы по одному разу;

3) тестовые наборы данных в узлах ветвления с более чем одним условием должны обеспечивать перебор всех возможных сочетаний значений условий в одном узле ветвления.

## 10. Структура программы на языке С#.
http://plssite.ru/csharpquick/qcsprogramstructure

Структура заготовки проекта
```c#
//Подключение пространства имен
using System;
using System.Collections.Generic;
using System.Linq; //можно удалить
using System.Text;

//Объявление пространства имен
namespace ConsoleApplication1
{
  //Объявление класса
  class Program
  {
    //Главный метод программы
    static void Main(string[] args)
    {
      //здесь размещается основной текст программы

      //Вывод строки
      Console.WriteLine("Hello World!");
      //Вспомогательный оператор
      Console.ReadKey();
    }
  }
}
```

Первая строка данной программы, это комментарий. Комментарии никак не влияют на работу программы, они нужны для человека, который будет сопровождать код программы (дорабатывать её, исправлять ошибки и т.п.). Комментарии в C# начинаются с символов «`//`» (две косые черты, два слэша), и действуют только до конца строки.

Вторая строка программы (`using System;`) является оператором, который подключает стандартное пространство имен `System`. По сути, мы получаем доступ к набору классов  имеющихся в «контейнере» `System`.  Как видно, данная строка состоит из двух слов, первое (ключевое слово `using`) означает, что мы хотим подключить пространство имен, а второе `System` — название нужного пространства имен.

> В конце второй строки стоит символ «`;`», который обозначает завершение оператора. Каждый оператор программы должен заканчиваться таким символом.

Далее объявляется своё пространство имен (`namespace ConsoleApplication1`), оно называется «ConsoleApplication1». Пространство имен является своего рода контейнером, и оно ограничивается фигурными скобками (открывающей и закрывающей), следующими за его названием. Таким образом, все что находится между этими скобками, принадлежит пространству имен `ConsoleApplication`.

Далее объявляется класс с именем «Program», это основной и единственный класс нашей программы. Как можно заметить, для объявления класса служит ключевое слово `class` за которым следует имя класса. В программе, может быть и не один, а несколько классов. Как правило, класс состоит из набора методов, которые определяют так называемое поведение класса (если хотите, функциональность). Границы класса, так же как и пространства имен обозначаются фигурными скобками. В нашем случае, класс имеет только один метод, это метод `Main`.

Далее как раз и объявляется метод `Main`. Этот метод является главным в нашей программе, так называемая точка входа в программу. Это означает, что при запуске программы, первым будет выполняться именно метод `Main`. Каждый метод тоже имеет границы, которые так же обозначаются фигурными скобками.

Метод `Main` нашей программы содержит только два оператора. Первый выводит сообщение «Hello World!». А второй, является вспомогательным, он заставляет программу ждать нажатие клавиши на клавиатуре, и не дает её до этого момента завершить свое выполнение (без этого оператора, программа бы вывела строку и быстро закрылась, так что мы даже не успели прочитать что она вывела).

## 11. Основные элементы языка С#: переменные, константы, алфавит, идентификаторы, ключевые слова, выражения, операторы.
http://smolapo.ru/sites/default/files/Prepod/Efremova/pril/13_2.pdf

### Состав языка
**Алфавит** – совокупность допустимых в языке символов. Алфавит языка С# включает:
1. прописные и строчные латинские буквы и буквы национальных алфавитов (включая кириллицу);
2. арабские цифры от `0` до `9`, шестнадцатеричные цифры от `A` до `F`;
3. специальные знаки: `" { } , | ; [ ] ( ) + - / % * . \ ' : ? < = > ! & ~ ^ @ _`
4. пробельные символы: пробел, символ табуляции, символ перехода на новую строку.

Из символов алфавита формируются **лексемы** языка: идентификаторы, ключевые
(зарезервированные) слова, знаки операций, константы, разделители (скобки, точка,
запятая, пробельные символы).

Границы лексем определяются другими лексемами, такими, как разделители или
знаки операций. В свою очередь лексемы входят в состав **выражений** (выражение задает
правило вычисления некоторого значения) и **операторов** (оператор задает законченное
описание некоторого действия).

**Идентификатор** – это имя программного элемента: константы, переменной, метки,
типа, класса, объекта, метода и т.д. Идентификатор может включать латинские буквы и
буквы национальных алфавитов, цифры и символ подчеркивания. Прописные и строчные
буквы различаются, например, `myname`, `myName` и `MyName` — три различных имени.
Первым символом идентификатора может быть буква или знак подчеркивания, но не цифра.

Пробелы и другие разделители внутри имен не допускаются. Язык С# не налагает
никаких ограничений на длину имен, однако для удобства чтения и записи кода не стоит
делать их слишком длинными.

Для улучшения читабельности кода программным элементам следует давать
осмысленные имена, составленные в соответствии с определенными правилами.
Существует несколько видов нотаций – соглашений о правилах создания имен.

В нотации Pascal каждое слово, входящее в идентификатор, начинается с заглавной
буквы. Например: `Age`, `LastName`, `TimeOfDeath`.

Венгерская нотация отличается от предыдущей наличием префикса,
соответствующего типу величины. Например: `fAge`, `sName`, `iTime`.

В нотации Camel с заглавной буквы начинается каждое слово идентификатора,
кроме первого. Например: `age`, `lastName`, `timeOfDeath`.

Наиболее часто используются нотации Pascal или Camel. Однако в простых
программах будут использоваться однобуквенные переменные.

**Ключевые слова** – это зарезервированные идентификаторы, которые имеют
специальное значение для компилятора, например, `static`, `int` и т.д. Ключевые слова можно использовать только по прямому назначению. Однако если перед ключевым словом
поставить символ `@,` например, `@int`, `@static`, то полученное имя можно использовать в качестве идентификатора. С полным перечнем ключевых слов и их назначением можно ознакомиться в справочной системе С#.

https://codechick.io/tutorials/csharp/csharp-expressions-statements-blocks

**Выражение** — комбинация операндов (переменных, литералов и вызовов методов) и инструкций, результатом которой могут быть одиночные значения. В выражении должен быть хотя бы один операнд, но может не быть инструкций.

### Операторы языка C#
Программа на языке С# состоит из последовательности *операторов* (**инструкций**), каждый из которых определяет законченное описание некоторого действия и заканчивается точкой с запятой. Все операторы (инструкции) можно разделить на 4 группы:
- операторы следования;
- операторы ветвления;
- операторы цикла;
- операторы передачи управления.

### Операторы следования
Операторы следования выполняются в естественном порядке: начиная с первого до последнего. К операторам следования относятся: *выражение* и *составной оператор*.

Любое **выражение**, завершающееся точкой с запятой, рассматривается как оператор, выполнение которого заключается вычислением значения выражения или выполнением законченного действия, например, вызовом метода. Например:
```c#
++i; //оператор инкремента
x+=y; //оператор сложения с присваиванием
Console.WriteLine(x); //вызов метода
x=Math.Pow(a,b)+a*b; //вычисление сложного выражения
```

**Составной оператор** или **блок** представляет собой последовательность операторов, заключенных в фигурные скобки `{}`. Блок обладает собственной областью видимости: объявленные внутри блока имена доступны только внутри данного блока или блоков, вложенных в него. Составные операторы применяются в случае, когда правила языка предусматривают наличие только одного оператора, а логика программы требует нескольких операторов. Например, тело цикла `while` должно состоять только из одного оператора. Если заключить несколько операторов в фигурные скобки, то получится блок, который будет рассматриваться компилятором как единый оператор.

### Операторы ветвления
Операторы ветвления позволяют изменить порядок выполнения операторов в
программе. К операторам ветвления относятся условный оператор `if` и оператор выбора
`switch`.

### Операторы цикла
Операторы цикла используются для организации многократно повторяющихся вычислений. К операторам цикла относятся: цикл с предусловием *while*, цикл с постусловием *do while*, цикл с параметром *for* и цикл перебора *foreach*.

### Операторы безусловного перехода
В С# есть несколько операторов, изменяющих естественный порядок выполнения команд: оператор безусловного перехода *goto*, оператор выхода *break*, оператор перехода к следующей итерации цикла *continue*, оператор возврата из метода *return* и оператор генерации исключения *throw*.

## 12. Основные типы данных языка С#.
http://smolapo.ru/sites/default/files/Prepod/Efremova/pril/13_2.pdf

С# является языком со строгой типизацией. В нем необходимо объявлять тип всех
создаваемых программных элементов (например, переменных, объектов, окон, кнопок и
т.д.), что позволяет среде CLR предотвращать возникновение ошибок, следя за тем, чтобы
объектам присваивались значения только разрешенного типа. Тип программного элемента
сообщает компилятору о его размере (например, тип `int` показывает, что объект занимает 4 байта) и возможностях (например, кнопка может быть нарисована, нажата и т. д.).

Тип данных характеризует одновременно:

- множество допустимых значений, которые могут принимать данные, принадлежащие к этому типу;
- набор операций, которые можно осуществлять над данными, принадлежащими к этому типу;
- размер выделяемой памяти;
- расположение в памяти.

В С# типы делятся на три группы:
1. *базовые* типы – предлагаемые языком;
2. типы, *определяемые пользователем*;
3. *анонимные* типы — типы, которые автоматически создаются на основе инициализаторов объектов (начиная с версии С# 3.0).

Кроме того, типы С# разбиваются на две другие категории: *размерные типы* (value
type) и *ссылочные типы* (reference type). Почти все базовые типы являются размерными
типами. Исключение составляют типы `Object` и `String`, которые являются базовыми, но
ссылочными типами данных. Все пользовательские типы, кроме структур, являются
ссылочными. Дополнительно к упомянутым типам, язык С# поддерживает типы
указателей, однако они используются только с неуправляемым кодом.

Принципиальное различие между размерными и ссылочными типами состоит в
способе хранения их значений в памяти. В первом случае фактическое значение хранится в
стеке (или как часть большого объекта ссылочного типа). Адрес переменной ссылочного
типа тоже хранится в стеке, но сам объект хранится в куче.

**Стек** – это структура, используемая для хранения элементов по принципу LIFO (Last
input – first output или *первым ушел - последним пришел*). В данном случае под стеком понимается область памяти, обслуживаемая процессором, в которой хранятся значения локальных переменных. **Куча** – область памяти, используемая для хранения данных, работа с которыми реализуется через указатели и ссылки. Память для размещения таких данных выделяется программистом динамически, а освобождается сборщиком мусора.

Сборщик мусора уничтожает программные элементы в стеке через некоторое время
после того, как закончит существование раздел стека, в котором они объявлены. То есть,
если в пределах блока (фрагмента кода, помещенного в фигурные скобки `{}`) объявлена
локальная переменная, соответствующий программный элемент будет удален по окончании
работы данного блока. Объект в куче подвергается сборке мусора через некоторое время
после того, как уничтожена последняя ссылка на него.

### Базовые типы
Базовые типы можно обобщённо разделить на следующие группы:
- объектный (базовый);
- логический;
- арифметические типы (*целый*, *вещественный*, *десятичный*);
- символьный;
- строковый.

*Целые числа* имеют несколько разновидностей:
- **знаковые** величины;
- **беззнаковые** величины (принимают только неотрицательные значения).

Язык С# предлагает обычный набор базовых типов, каждому из них соответствует
тип, поддерживаемый общеязыковой спецификацией .NET (CLS).

<table>
<thead>
<tr>
  <th>Тип в языке C#</th><th>Размер в байтах</th><th>Тип .NET</th><th>Описание</th>
</tr>
</thead>
<tbody>
<tr>
  <td colspan=4><i><b>Базовый тип</b></i></td>
</tr>
<tr>
  <td>object</td><td></td><td>Object</td>
  <td>Может хранить все что угодно, т.к. является всеобщим предком</td>
</tr>
<tr>
  <td colspan=4><i><b>Логический тип</b></i></td>
</tr>
<tr>
  <td>bool</td><td>1</td><td>Boolean</td>
  <td>true или false</td>
</tr>
<tr>
  <td colspan=4><i><b>Целые типы</b></i></td>
</tr>
<tr>
  <td>sbyte</td><td>1</td><td>SByte</td>
  <td>Целое со знаком (от -128 до 127)</td>
</tr>
<tr>
  <td>byte</td><td>1</td><td>Byte</td>
  <td>Целое без знака (от 0 до 255)</td>
</tr>
</tr>
<tr>
  <td>short</td><td>2</td><td>Int16</td>
  <td>Целое со знаком (от -32768 до 32767)</td>
</tr>
</tr>
<tr>
  <td>ushort</td><td>2</td><td>UInt16</td>
  <td>Целое без знака (от 0 до 65535)</td>
</tr>
</tr>
<tr>
  <td>int</td><td>4</td><td>Int32</td>
  <td>Целое со знаком (от -2147483648 до 2147483647)</td>
</tr>
</tr>
<tr>
  <td>uint</td><td>4</td><td>UInt32</td>
  <td>Целое число без знака ( от 0 до 4 294 967 295)</td>
</tr>
</tr>
<tr>
  <td>long</td><td>8</td><td>Int64</td>
  <td>Целое со знаком (от -9223372036854775808 до 9223372036854775807)</td>
</tr>
</tr>
<tr>
  <td>ulong</td><td>8</td><td>UInt64</td>
  <td>Целое без знака (от 0 до 0fffffffffffffff)</td>
</tr>
<tr>
  <td colspan=4><i><b>Вещественные типы</b></i></td>
</tr>
<tr>
  <td>float</td><td>4</td><td>Single</td>
  <td>Число с плавающей точкой двойной точности. Содержит значения приблизительно от ±1.5*10<sup>-45</sup> до ±3.4*10<sup>38</sup> c 7 значащими цифрами</td>
</tr>
<tr>
  <td>double</td><td>8</td><td>Double</td>
  <td>Число с плавающей точкой двойной точности. Содержит значения приблизительно от ±5. 0*10<sup>-324</sup> до ±1.7*10<sup>308</sup> c 15-16 значащими цифрами </td>
</tr>
<tr>
  <td colspan=4><i><b>Символьный тип</b></i></td>
</tr>
<tr>
  <td>char</td><td>2</td><td>Char</td>
  <td>Символ Unicode</td>
</tr>
</tr>
<tr>
  <td colspan=4><i><b>Строковый тип</b></i></td>
</tr>
<tr>
  <td>string</td><td></td><td>String</td>
  <td>Строка из Unicode-символов</td>
</tr>
</tr>
<tr>
  <td colspan=4><i><b>Финансовый (десятичный) тип</b></i></td>
</tr>
<tr>
  <td>decimal</td><td>12</td><td>Decimal</td>
  <td>Число до 28 знаков с фиксированным положением десятичной точки. Обычно используется в финансовых расчетах и требует суффикса <<m>> или <<М>></td>
</tr>
</tbody>
</table>

По умолчанию вещественным константам (константам, содержащим точку) присваивается тип `double`. Для указания константы типа `float` сразу за ней записывается `f` или `F`, например `3.14f`.

Вещественные константы можно записывать в полулогарифмическом виде, например `1.7е-5`.

## 13. Объявление переменных и констант в языке С#. Инициализация переменных.
http://smolapo.ru/sites/default/files/Prepod/Efremova/pril/13_2.pdf

### Переменные

***Переменная*** представляет собой типизированную область памяти. Программист
создает переменную, объявляя ее тип и указывая имя. При объявлении переменной ее
можно инициализировать (присвоить ей начальное значение), а затем в любой момент ей
можно присвоить новое значение, которое заменит собой предыдущее.

https://csharp.net-tutorials.com/ru/109/%D0%BE%D1%81%D0%BD%D0%BE%D0%B2%D1%8B/%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5/

Переменные сравнимы с хранилищем и являются основой для любого программиста. В C#, переменные задаются так:
```c#
<тип данных><имя>;
```
к примеру вот так:
```c#
string name;
```

Это наиболее общий вид, но переменной еще не присвоено значение. Вы можете присвоить его позже, или непосредственно во время определения, к примеру вот так:
```c#
<data type> <name> = <value>;
```
Если эта переменная не является локальной для текущего метода (не является членом класса), видимость переменной можно назначить:
```c#
<область видимости><тип данных><имя переменной>=<значение>
```
пример полностью:
```c#
private string name = "John Doe";
```
Область видимости связана с классами, поэтому вы можете найти более подробное объяснение в главе о классах. Давайте сконцентрируемся на переменных и примерах, где мы и будем их использовать:

```c#
static void Main()
{
 int i=10; //объявление и инициализация целочисленной переменной i
 Console.WriteLine(i); //просмотр значения переменной
 i=100; //изменение значение переменной
 Console.WriteLine(i);
}
```
В языках предыдущего поколения переменные можно было использовать без
инициализации. Это могло привести к множеству проблем и долгому поиску ошибок. В
языке С# требуется, чтобы переменные были явно проинициализированы до их
использования. Проверим этот факт на примере.
```c#
static void Main()
{
 int i; //объявление переменной без инициализации
 Console.WriteLine(i); //просмотр значения переменной
}
```
При попытке скомпилировать этот пример в списке ошибок будет выведено
следующее сообщение: "*Использование локальной переменной i, которой не присвоено
значение*".

Инициализировать каждую переменную сразу при объявлении необязательно, но
необходимо присвоить ей значение до того, как она будет использована.

Идентификаторы переменных состоят из букв латинского алфавита и цифр (возможно использование букв *национальных* языков).

Строчные и заглавные символы различаются.

Желательно делать имена переменных осмысленными.

Рекомендуется применять два типа обозначения переменных, в которых регистр символов указывает предназначение величины:
- `camelCase` – первое слово начинается со строчной буквы, последующие слова с заглавной, например `age`, `ozenkaZaDisp`. Применяют для *простых* переменных (целых, вещественных, булевых и т.д.);
- `PascalCase` – каждое слово в имени переменной начинается с большой буквы, например `Age`, `OzenkaZaDisp`. Применяют для обозначения *классов* и *сложных
переменных*, тип которых определяет программист.

Переменные до их использования следует *проинициализировать*, т.е. в них следует занести какие-либо допустимые значения, иначе в ходе выполнения программы могут возникнуть трудно обнаруживаемые ошибки.

Пример фрагмента программы с объявлением переменных:
```c#
static void Main(string[] args)
{
  int i=-1, ozenka=0;
  double sredniyBall=0.0;
  …
}
```

Можно разделять объявление переменных и их инициализацию:
```c#
double c, d1;
c = 17e-5; d1 = 1.0;
```

### Константы

**Константа**, в отличие от переменной, не может менять свое значение. Константы
бывают трех видов: *литералы*, *типизированные константы* и *перечисления*.

В операторе присваивания:
```c#
x=32;
```
число `32` является литеральной константой. Его значение всегда равно `32` и его нельзя
изменить.

*Типизированные константы* именуют постоянные значения. Объявление типизированной константы происходит следующим образом:
```c#
const <тип> <идентификатор> = <значение>;
```

Рассмотрим пример:
```c#
static void Main()
{
  const int i=10; //объявление целочисленной константы i
  Console.WriteLine(i); //просмотр значения константы
  i=100; //ошибка – недопустимо изменять значение константы
  Console.WriteLine(i);
}
```

> **Задание**. Измените программу так, чтобы при объявлении константы не происходила
инициализация. Как на это отреагирует компилятор и почему?

<details>
<summary><b>Ответ</b></summary>

```c#
const i;
```

Компилятор выдаёт ошибку `Compiler Error CS0145: A const field requires a value to be provided`, поскольку константы обязательно требуется инициализировать при объявлении (т.к. их значение впоследствии всё равно не может быть изменено).

</details>

### Перечисления

*Перечисления* (*enumerations*) являются альтернативой константам. **Перечисление** —
это особый размерный тип, состоящий из набора именованных констант (называемых
*списком перечисления*). Синтаксис объявления перечисления следующий:
```
[атрибуты] [модификаторы] enum <имя> [ : базовый тип]
{список-перечисления констант(через запятую)};
```

> **Замечание**. Атрибуты и модификаторы являются необязательными элементами этой
конструкции. Более подробные сведения о их можно найти в дополнительных источниках
информации.

**Базовый тип** — это тип самого перечисления. Если не указать базовый тип, то по
умолчанию будет использован тип `int`. В качестве базового типа можно выбрать любой
целый тип, кроме `char`. Пример использования перечисления:
```c#
class Program
{
  enum gradus:int
  {
    min=0,
    krit=72,
    max=100, //1
  }
  static void Main()
  {
    Console.WriteLine("минимальная температура=" + (int) gradus.min);
    Console.WriteLine("критическая температура=" + (int)gradus.krit);
    Console.WriteLine("максимальная температура=" + (int)gradus.max);
  }
}
```
> **Замечания**
> 1. В общем случае последнюю запятую в объявлении перечисления можно не ставить (см. строку 1). Но лучше ее поставить: если вам придется добавить еще несколько строк в перечисление, такая предусмотрительность избавит вас от возможных синтаксических ошибок.
> 2. Запись `(int) gradus.min` используется для явного преобразования перечисления к целому типу.<br>
> Если убрать `(int)`, то на экран будет выводиться название констант.
> 3. Символ `+` в записи `"минимальная температура=" + (int) gradus.min` при обращении к методу `WriteLine` означает, что строка `"минимальная температура="` будет «склеена» со строковым представлением значения `(int) gradus.min`. В результате получится новая строка, которая и будет выведена на экран

## 14. Операции и выражения в языке С#: арифметические, логические выражения. Основные математические функции.
http://smolapo.ru/sites/default/files/Prepod/Efremova/pril/13_2.pdf

### Операции
В данном разделе мы подробно рассмотрим только часть операций, остальные операции будут вводиться по мере необходимости.

> **Замечание**. Операции можно классифицировать по количеству операндов: **унарные** – воздействуют на один операнд, **бинарные** – воздействуют на два операнда, **тернарные** – воздействуют на три операнда. Некоторые символы используются для обозначения как унарных, так и бинарных операций. Например, символ «минус» используется как для обозначения унарной операции – арифметического отрицания, так и для обозначения бинарной операции вычитания. Будет ли данный символ обозначать унарную или бинарную операцию, определяется контекстом, в котором он используется.

Также операции можно разделить по типу операндов:

- *арифметические* и *сравнения*;
- *логические*;
- *битовые*;
- *строковые* (конкатенация).

1. **Инкремент** (`++`) и **декремент**(`--`).

    Эти операции имеют две формы записи — *префиксную*, когда операция записывается перед операндом, и *постфиксную* – операция записывается после операнда. Префиксная операция инкремента (декремента) увеличивает (уменьшает) свой операнд и возвращает измененное значение как результат. Постфиксные версии инкремента и декремента возвращают первоначальное значение операнда, а затем изменяют его.

    Рассмотрим эти операции на примере.
    ```c#
    static void Main()
    {
    int i = 3, j = 4;
    Console.WriteLine("{0} {1}", i, j);
    Console.WriteLine("{0} {1}", ++i, --j);
    Console.WriteLine("{0} {1}", i++, j--);
    Console.WriteLine("{0} {1}", i, j);
    }
    ```
    Результат работы программы:
    ```
    3 4
    4 3
    4 3
    5 2
    ```

    > **Задание**. Выясните, допустимы ли следующие способы записи `++(++i)`, `(i--)--`, `++(i--)` и т.д. И почему

    <details>
    <summary><b>Ответ</b></summary>

    Способы записи `++(++i)`, `(i--)--`, `++(i--)` и т.д. не являются допустимыми и возвращают ошибку `error CS1059: The operand of an increment or decrement operator must be a variable, property or indexer`, поскольку внутренний инкремент возвращает значение, а внешний инкремент не может быть применён к литералу (инкремент должен быть применён к идентификатору переменной, свойства или идексатора), что и утверждает сообщение об ошибке.

    </details>

2. **Операция `new`**.

    Используется для создания нового объекта. С помощью ее можно создавать как объекты ссылочного типа, так и размерные, например:
    ```c#
    object z=new object();
    int i=new int(); // то же самое, что и int i =0;
    ```

3. **Отрицание**.

   1. **Арифметическое отрицание** (`-`) – меняет знак операнда на противоположный.
   2. **Логическое отрицание** (`!`) – определяет операцию инверсии для логического типа.

    Рассмотрим эти операции на примере.
    ```c#
    static void Main()
    {
    int i = 3, j=-4;
    bool a = true, b=false;
    Console.WriteLine("{0} {1}", -i, -j);
    Console.WriteLine("{0} {1}", !a, !b);
    }
    ```
    Результат работы программы:
    ```
    -3 4
    False True
    ```

    > **Задание**. Выясните, допустимы ли следующие способы записи `!(-i)`, `-(!a)`. И почему.

    <details>
    <summary><b>Ответ</b></summary>

    > Способы записи `!(-i)`, `-(!a)` не являются допустимыми и возвращают ошибку `error CS0023: Operator '!' cannot be applied to operand of type 'int'`, поскольку логический оператор не может быть применён к операнду нелогического типа.

    </details>

4. **Явное преобразование типа**.

    Используется для явного преобразования из одного типа в другой. Формат операции:

        (<тип>) <выражение>;

    Рассмотрим эту операцию на примере.
    ```c#
    static void Main()
    {
    int i = -4;
    byte j = 4;
    int a = (int)j; //преобразование без потери точности
    byte b = (byte)i; //преобразование с потерей точности
    Console.WriteLine("{0} {1}", a, b);
    }
    ```
    Результат работы программы:
    ```
    4 252
    ```

    > **Задание**. Объясните, почему операция `(byte)i` вместо ожидаемого значения `-4` дала нам в качестве результата значение `252`.

    <details>
    <summary><b>Ответ</b></summary>

    Операция `(byte)i` вместо ожидаемого значения `-4` дала нам в качестве результата значение `252`, поскольку тип данных переменной `b` не предполагает хранение отрицательных значений (целое без знака &mdash; от 0 до 255), поэтому при преобразовании произошла потеря значимости (underflow), так как минимально хранимым значением в типе `byte` является `0`. Так, `-1` при подобном преобразовании будет представлена как `255`, `-2` — `254`, `-3` — `253`, `-4` — `252`.

    </details>

    > **Замечание**. В Pascal, C++ и других языках допускается неявное преобразование типов, которое в рамках предыдущего примера позволило бы записать: `b=i`. В этом случае происходит потеря точности вычислений, о чем компилятор либо "умалчивает", либо сообщает в виде предупреждения. Возможность неявного преобразования чревата вычислительными ошибками, которые очень трудно найти. Чтобы избежать подобных ошибок, в C# запрещены некоторые виды неявных преобразований.

5. **Умножение** (`*`), **деление** (`/`) и **деление с остатком** (`%`).

    Операции умножения и деления применимы для целочисленных и вещественных типов данных. Для других типов эти операции применимы, если для них возможно неявное преобразование к целым или вещественным типам. При этом тип результата равен «наибольшему» из типов операндов, но не менее `int`. Если оба операнда при делении целочисленные, то и результат тоже целочисленный.

    Рассмотрим эти операции на примере.
    ```c#
    static void Main()
    {
    int i = 100, j = 15;
    double a = 14.2, b = 3.5;
    Console.WriteLine("{0} {1} {2}", i*j, i/j, i%j);
    Console.WriteLine("{0} {1} {2}", a * b, a / b, a % b);
    }
    ```
    Результат работы программы:
    ```
    1500 6 10
    49.7 4.05714285714286 0.1999999999999999
    ```

    **Задания**

    1. Выполните фрагмент программы и объясните полученный результат:
    ```c#
    double a=100, b=33;
    Console.WriteLine(a/b);
    double d=100/33;
    Console.WriteLine(d);
    ```

    <details>
    <summary><b>Ответ</b></summary>

    ```c#
    3.03030303030303
    3
    >
    ```

    В обоих случаях результат соответствует типу операндов (`double`) — в первом случае операнды имеют тип `double`, поэтому результат содержит дробную часть, во втором же случае оба операнда имеют тип `int` (заданный неявно — самими литералами), поэтому результат не содержит дробной части, даже несмотря на тип переменной `d`.

    </details>

    2. Выясните, чему будет равен результат операции, и объясните, как получился данный
    результат:

    а) 1.0/0; б) 1/0

    <details>
    <summary><b>Ответ</b></summary>

    ```c#
    > 1.0 / 0
    ∞
    > 1 / 0
    (1,1): error CS0020: Division by constant zero
    >
    ```

    https://stackoverflow.com/questions/4262286/why-does-c-sharp-allow-dividing-a-non-zero-number-by-zero-in-floating-point-type

    **Short answer**: Floating point division is govered by IEEE754, which specifies that divide by zero should be infinity. There is no such standard for integer division, so they simply went with the standard rules of math.

    The IEEE Standard for Floating-Point Arithmetic (IEEE 754) is the most widely-used standard for floating-point computation, and is followed by many hardware and software implementations, including the C# compiler.

    This means that a floating-point variable in C# can contain a bit pattern that represents strange creatures such as `PositiveInfinity`, `NegativeInfinity`, and `Not-a-Number` (abbreviated as `NaN`). Under the IEEE 754 arithmetic rules, any of these non-finite floating-point values can be generated by certain operations. For example, an invalid floating-point operation such as dividing zero by zero results in `NaN`.

    In your specific examples, you can see that C# (unlike VB) overloads the `/` operator to mean either integer or floating-point division, depending on the numeric types of the numbers involved.

    In your first example the compiler sees `1.0`, and therefore uses floating-point division and puts the result into a floating-point variable. That variable contains a representation of infinity and the compiler is fine with that.

    In your second example the compiler sees `1`, and therefore uses integer division and puts the result into an integer variable. Because integral types in C# use two's complement system for representation, and don't use any special bit patterns to represent infinity (or `NaN`), the compiler gives an error.

    </details>

6. **Сложение** (`+`) и **вычитание** (`-`).

    Операции сложения и вычитания применимы для целочисленных и вещественных типов данных. Для других типов эти операции применимы, если для них возможно неявное преобразование к целым или вещественным типам.

7. **Операции отношения** (`<`, `<=`, `>`, `>=`, `==`, `!=`).

    Операции отношения сравнивают значения левого и правого операндов. Результат операции логического типа: `true` – если значения совпадают, `false` – в противном случае.

    *Операции сравнения*

    Обозначение | Значение
    -- | --
    `>` | больше
    `<` | меньше
    `>=` | больше или равно
    `<=` | меньше или равно
    `==` | равно
    `!=` | не равно

    Рассмотрим операции на примере:
    ```c#
    static void Main()
    {
    int i = 15, j = 15;
    Console.WriteLine(i<j); //меньше
    Console.WriteLine(i<=j); //меньше или равно
    Console.WriteLine(i>j); //больше
    Console.WriteLine(i>=j); //больше или равно
    Console.WriteLine(i==j); //равно
    Console.WriteLine(i!=j); //не равно
    }
    ```
    Результат работы программы:
    ```
    False
    True
    False
    True
    True
    False
    ```

    > **Задание**. Выясните, чему равен результат данного выражения:
    >
    > 1) `10<25<30` 2) `true<false`
    >
    > И объясните, как получился данный результат

    <details>
    <summary><b>Ответ</b></summary>

    ```c#
    > 10 < 25 < 30
    (1,1): error CS0019: Operator '<' cannot be applied to operands of type 'bool' and 'int'
    > true < false
    (1,1): error CS0019: Operator '<' cannot be applied to operands of type 'bool' and 'bool'
    ```

    В обоих случае компилятор возвращает ошибку, поскольку данные операции не могут быть применены к операндам логического типа (в первом случае сравнение `10 < 25` возвратит `true`, которое выступит левым операндом в выражении `true < 30`.

    </details>

8. **Логические и условные логические операции** (`&`, `|`, `^`, `~` и `&&`, `||`).

    Логические операции применяются к операндам логического типа.

    Результат логической операции И имеет значение истина тогда и только тогда, когда
    оба операнда принимают значение истина.

    Результат логической операции ИЛИ имеет значение истина тогда и только тогда,
    когда хотя бы один из операндов принимает значение истина.

    В языке C# есть тип данных `bool`, который используется для объявления переменных логических типа. Значения логических переменных: `true` (истина); `false` (ложь). Операции сравнения числовых величин `а<операция>b` в качестве результата дают логическое значение.

    *Логические операции над булевыми операндами*

    Обозначение | Пояснение
    -- | --
    `&` | Логическое **И** (**AND**) `x&y`
    `|` | Логическое **ИЛИ** (**OR**) `x|y`
    `^` | Отрицание равнозначности
    `~` | Логическое отрицание
    `&&` | Условное логическое **И** (`x&&y`, если `x` имеет значение `false`, то `y` не вычисляется — операция **И** имеет значение `false` вне зависимости от значения `y`).
    `||` | Условное логическое **ИЛИ** (`x||y`, если `x` имеет значение `true`, `y` не рассчитывается — результат операции **OR** является `true` независимо от значения `y`).

    Значение результата логических операций `true` или `false`.

    Логические операции `&`, `|`, `^` выполняются над *логическими* и над *целыми* величинами. В случае целых величин операции выполняются над *отдельными двоичными разрядами*:
    - `1` соответствует `true`,  `0` – `false`.

    К поразрядным относят операции:
    - логического сложения `|`,
    - логического умножения `&`,
    - сложения по модулю два `^` (отрицание равнозначности),
    - логического отрицания `~`.

    Например:

    $$
    7_{10} \& 4_{10} = 111_{2} \& 100_{2} = 100_{2} = 4_{10} \\~\\
    5_{10} \& 7_{10} = 101_{2} \& 111_{2} = 101_{2} = 5_{10} \\~\\
    5_{10} \text{}^\wedge 7_{10} = 101_{2} \text{}^\wedge 111_{2} = 010_{2} = 2_{10}
    $$

    Приоритет логических операций ниже арифметических. Старшинство логических операций убывает в следующей последовательности: операции сравнения, равенства и неравенства, `&`, `^`, `|`. Операция `~` относится к унарным префиксным операциям.

    Условные логические операции применимы к целым и вещественным величинам.

    *Примеры записи операций сравнения*:
    ```c#
    (nOzenka >= 3)&&(nOzenka<6)
    (nOzenka = =5)||(nOzenka= =4)
    (y1>=2 && y1<=7)
    (r>3.14) && (r<9.15)
    (dValue < dOldvalue) || (dValue != 0)
    ```

    *Примеры операторов с логическими данными*:
    ```c#
    bool dUsp;
    dUsp=true;
    dUsp=(nOzenka = =5)||(nOzenka= =4);
    ```

    Рассмотрим операции на примере:
    ```c#
    static void Main()
    {
    Console.WriteLine("x y x и y x или y");
    Console.WriteLine("{0} {1} {2} {3}", false, false, false&&false, false||false);
    Console.WriteLine("{0} {1} {2} {3}", false, true, false&&true, false||true);
    Console.WriteLine("{0} {1} {2} {3}", true, false, true&&false, true||false);
    Console.WriteLine("{0} {1} {2} {3}", true, true, true&&true, true||true);
    }
    ```
    Результат работы программы:
    ```
    x       y       x и y   x или y
    False   False   False   False
    False   True    False   True
    True    False   False   True
    True    True    True    True
    ```
    > **Замечание**. Фактически была построена таблица истинности для логических операций И и ИЛИ.

    > **Задание**. Объясните, какое значение примет переменная `t` в данном фрагменте программы:
    > ```c#
    > int a=10, b=3;
    > bool t=(a>=b && a!=2*b || a<0);
    > ```

    <details>
    <summary><b>Ответ</b></summary>

    ```c#
    > int a = 10, b = 3;
    > bool t = (a >= b && a != 2 * b || a < 0);
    > t
    true
    ```

    В соответствии с приоритетом сначала выполнится операция умножения, после чего — операции сравнения, которые в левой части от оператора ИЛИ вернут истину.

    </details>

9. **Условная операция**.

    Формат: `(<операнд1>)? <операнд2> : <операнд3>;`

    `Операнд1` – это логическое выражение, которое оценивается с точки зрения его
    эквивалентности константам `true` и `false`. Если результат вычисления `операнда1` равен `true`, то результатом условной операции будет значение `операнда2`, иначе — `операнда3`.

    Фактически условная операция является сокращенной формой условного оператора if,
    который будет рассмотрен позже.

    Пример использования условной операции:
    ```c#
    static void Main()
    {
    int x=5; int y=10;
    int max = (x > y) ? x : y;
    Console.WriteLine(max);
    }
    ```

    > Задание. Измените программу так, чтобы:
    > 1) вычислялось наименьшее значение из двух вещественных чисел `x` и `y`;
    > 2) если число двузначное, то на экран выводилось «Да», и «Нет» в противном случае.

    <details>
    <summary><b>Ответ</b></summary>

    ```c#
    > int x = 5; int y = 10;
    > int min = (x < y) ? x : y;
    > Console.WriteLine(min);
    5
    > Console.WriteLine(x / y != 0 ? "Да" : "Нет");
    Нет
    ```

    </details>

10. **Операции присваивания**: `=`, `+=`, `-=` и т.д.

    Формат операции **простого присваивания** (`=`):

        операнд_2 = операнд_1;

    В результате выполнения этой операции вычисляется значение `операнда_1`, и  результат записывается в `операнд_2`. Можно связать воедино сразу несколько операторов присваивания, записывая такие цепочки: `a=b=c=100`. Выражение такого вида выполняется справа налево: результатом выполнения `c=100` является число `100`, которое затем  присваивается переменной `b`, результатом чего опять является `100`, которое присваивается переменной `a`.

    Кроме простой операции присваивания существуют **сложные операции присваивания** (**составное присваивание**), например, *умножение с присваиванием* (`*=`), *деление с присваиванием* (`/=`),     *остаток от деления с присваиванием* (`%=`), *сложение с присваиванием* (`+=`), *вычитание с присваиванием* (`-=`) и т.д.

    В сложных операциях присваивания, например, при сложении с присваиванием, к
    `операнду_2` прибавляется `операнд_1`, и результат записывается в `операнд_2`. То есть, выражение `с += а` является более компактной записью выражения `с = с + а`.

    > **Задание**. Объясните, какие значения примут переменные `t` и `b` после выполнения данного фрагмента программы:
    > ```c#
    > int a=10, b=3;
    > int t=(a++)-b;
    > b+=t*a;
    > ```

    <details>
    <summary><b>Ответ</b></summary>

    ```c#
    > int a = 10, b = 3;
    > int t = (a++) - b;
    > b += t * a;
    > t
    7
    > b
    80
    ```

    Во время присвоения значения `t` инкремент в постпозиции вернёт изначальное значение `a`, поэтому `t` будет равно `10 - 3 = 7`. При присвоении `b` значение `a` уже будет увеличено инкрементом на `1`, поэтому `b = 3 + (7 * 11) = 3 + 77 = 80`.

    </details>

### Приоритет операций
https://learn.microsoft.com/ru-ru/dotnet/csharp/language-reference/operators/

https://intuit.ru/studies/courses/486/342/lecture/24837

https://ci-sharp.ru/obuchenie/osnovy/prioritety-operatorov-v-c-polnaya-tablicza/

Когда в выражении используется несколько операторов, C# должен определить, какой оператор выполнить первым. Вот тут и вступают в игру приоритеты операторов. Высший приоритет говорит компилятору выполнить данный оператор раньше других.
Полный список операций языка С# в соответствии с их приоритетами (по убыванию
приоритетов).

Приоритет | Оператор | Название | Описание |	Категория или имя
-- | -- | -- | -- | --
1 | | | | Primary / Основные
| | *x*`.`*y* | Member access expression (Dot operator) | Доступ к элементу | Member access and null-conditional operators and expressions
| | *f*`(`*x*`)` | Invocation expression | Вызов метода или делегата | Member access and null-conditional operators and expressions
| | *a*`[`*i*`]` | Indexer operator | Доступ к элементу массива или индексатору | Member access and null-conditional operators and expressions
| | *x*`?.`*y*, *x*`?[`*y*`]` | Null conditional operators | Доступ с условным значением NULL | Member access and null-conditional operators and expressions
| | *x*`++`, *x*`--` | Increment, Decrement operators | Постфиксное увеличение и уменьшение | Arithmetic operators
| | *x*`!` | Null-forgiving operator | Постфиксный оператор null-подавления (допускающий значение NULL) | Null-forgiving operator
| | `new` *F()* | New operator | Выделение памяти (создание экземпляра типа) | New operator
| | `typeof`*(x)* | Typeof operator | Получение типа | Type testing operators and cast expressions
| | `checked`*(x)*, `unchecked`*(x)* | Checked, Unchecked operators | Проверяемый и непроверяемый код | Checked and unchecked statements
| | `default`*(T)* | Default operator | Значение по умолчанию | Defaul value expressions
| | `nameof`*(x)* | Nameof operator | Имя переменной, типа или элемента в виде строковой константы | Nameof expression
| | `delegate`*(x) {}* | Delegate operator | Создание анонимного метода, преобразуемого в тип делегата | Delegate operator
| | `sizeof`*(T)* | Sizeof operator | Определение потребностей памяти для заданного типа | Sizeof operator
| | `stackalloc` *x* | Stackalloc operator | Выделяет блок памяти в стеке | Stackalloc expression
| | *x*`->`*y* | Pointer member access operator | Оператор доступа к элементу указателя | Pointer related operators
2 | | | | Unary / Унарные
| | `+`*x*, `-`*x* | Unary Plus and Minus operators | Унарный плюс и минус | Arithmetic operators
| | `!`*x* | Logical negation operator | Логическое отрицание операнда | Boolean logical operators
| | `~`*x* | Bitwise complement operator | Поразрядное отрицание (создает побитовое дополнение своего операнда путем инвертирования каждого бита) | Bitwise and shift operators
| | `++`*x*, `--`*x* | Increment, Decrement operator | Префиксный инкремент и декремент | Arithmetic operators
| | `^`*x* | Index from end operator | Указывает позицию элемента из конца последовательности | Member access and null-conditional operators and expressions
| | `(`*T*`)`*x* | Cast expression | Явное преобразование значения выражения *x* в тип *T* | Type testing operators and cast expressions
| | `await` *x* | Await operator | Асинхронное ожидание завершения задачи | Await operator
| |`&`*x* | Address-of operator | Возвращает адрес своего операнда | Pointer related operators
| | `*`*x* | Pointer indirection operator | Получает переменную, на которую указывает операнд (оператор разыменования) | Pointer related operators
| | `true` *x*, `false` *x* | True, False operators | Обрабатывают объекты как логическое значение | Logical operators
3 | | | | Range / Диапазон
| | *x*`..`*y* | Range operator | Задает начало и конец диапазона индексов в качестве операндов | Member access and null-conditional operators and expressions
4 | | | | Switch and with
| | *x* `switch` *E* | Switch expression | Сопоставление шаблонов | Switch expression |
| | *A* `with` *B* | With expression | Новый объект с измененными свойствами (недеструктивная мутация) | With expression
5 | | | | Multiplicative / Мультипликативные
| | *x* `*` *y*, *x* `/` *y*, *x* `%` *y* | Multiplication, Division, Remainder operators | Умножение, деление, остаток от деления | Arithmetic operators
6 | | | | Additive / Аддитивные
| | *x* `+` *y*, *x* `–` *y* | Addition, Subtraction operators | Сложение и вычитание | Arithmetic operators
7 | | | | Shift / Сдвиг
| | *x* `<<` *y*, *x* `>>` y, *x* `>>>` *y* | Left Shit, Right Shift, Unsigned Right Shift operators | Битовый сдвиг | Bitwise and shift operators
8 | | | | Relational and type-testing / Отношения и проверка типов
| | *x* `<` *y*, *x* `>` *y*, *x* `<=` *y*, *x* `>=` *y* | Less than, Greater then, Less than or Equal, Greater than or Equal | Сравнение величин | Comparison Operators
| | *E* `is` *T* | Is operator | Проверка принадлежности типа | Type testing operators and cast expressions
| | *E* `as` *T* | As operator | Приведение типа | Type testing operators and cast expressions
9 | | | | Equality / Равенство
| | *x* `==` *y*, *x* `!=` *y* | Equality, Inequality operators | Определение равенства и неравенства | Equality operators
10 | *x* `&` *y* | Logical AND operator | Логическое И или побитовое логическое И (Поразрядное И) | Boolean logical operators / Bitwise and shift operators
11 | *x* `^` *y* | Logical exclusive OR operator | Логическое исключающее ИЛИ или побитовое логическое исключающее ИЛИ (Поразрядное исключающее ИЛИ) | Boolean logical operators / Bitwise and shift operators
12 | *x* `\|` *y* | Logical OR operator | Логическое ИЛИ или побитовое логическое ИЛИ (Поразрядное ИЛИ) | Boolean logical operators / Bitwise and shift operators
13 | *x* `&&` *y* | Conditional logical AND operator (short-circuiting logical AND)	| Условное логическое И (Условное И) | Boolean logical operators
14 | *x* `\|\|` *y* | Conditional logical OR operator (short-circuiting logical OR) |	Условное логическое ИЛИ (Условное ИЛИ) | Boolean logical operators
15 | *x* `??` *y* | Null-coalescing operator | Оператор объединения с NULL | Null-coalescing operators
16 | *c* `?` *t* `:` *f* | Conditional operator |	Условная операция | Conditional operator
17 | | | | Assignment and lambda declaration / Назначение и объявление лямбда-выражений
| | *x* `=` *y* | Assignment operator | Простое присваивание | Assignment operators
| | *x* `+=` *y*, *x* `-=` *y*, *x* `*=` *y*, *x* `/=` *y*, *x* `%=` *y*, *x* `&=` *y*, *x* `\|=` *y*, *x* `^=` *y*, *x* `<<=` *y*,  *x* `>>=` *y*, *x* `>>>=` *y* | Compound assignment | Составное присваивание | Arithmetic operators
| | *x* `??=` *y* | Compound assignment with null-coalescing | Составное присваивание с null-слиянием | Null-coalescing operators
| | *x* `=>` *E* | Lambda expression operator | Назначение и объявление лямбда-выражения (используется для отделения входных параметров с левой стороны от тела лямбда-выражения с правой стороны) | Lambda expression operator

### Выражения и преобразование типов
**Выражение** – это синтаксическая единица языка, определяющая способ вычисления
некоторого значения. Выражения состоят из операндов, операций и скобок. Каждый
операнд является в свою очередь выражением или одним из его частных случаев –
константой, переменной или функций.

Примеры выражений:
```c#
(а + 0.12)/6 х && у || !z (t * Math.Sin(x)-l.05e4)/((2 * k + 2) * (2 * k + 3))
```

Вычисление значения выражения происходит с учетом приоритета операций, которые в нем участвуют. Если в выражении соседствуют операции одного приоритета, то унарные операции, условная операция и операции присваивания выполняются справа налево, остальные — слева направо. Например,

`а = b = с` означает `a=(b=c)`,

`a+b+c` означает `(а + b) + с`.

Если необходимо изменить порядок выполнения операций, то в выражении необходимо поставить круглые скобки.

> **Задания**
>
> 1. Укажите последовательность выполнения операций в данном выражении:
> ```c#
> (x*x+Math.Sin(x+1))/x-2.
> ```
> 2. Запишите заданное математическое выражение по правилам языка С#:
>
> a) $\sqrt{x^4 + \sqrt{|x+1|}}$; b) $\cfrac{a^2+b^2}{1 - \cfrac{a^3-b}{3}}$; c) $\ln{\left|(y - \sqrt{|x|})\left(x - \cfrac{y}{x+\cfrac{x^2}{4}}\right) \right|}$

<details>
<summary><b>Ответ</b></summary>

1.
   1. x*x
   2. (x+1)
   3. Math.Sin(x+1)
   4. (x*x+Math.Sin(x+1))
   5. (x*x+Math.Sin(x+1))/x
   6. (x*x+Math.Sin(x+1))/x-2

2.

```c#
// a)
Math.Sqrt(Math.Pow(x, 4) + Math.Abs(x + 1));
// b)
(a*a + b*b)/(1 - (Math.Pow(a, 3) - b)/3);
// c)
Math.Log(Math.Abs((y - Math.Sqrt(Math.Abs(x)))(x - y/(x + Math.Pow(x, 2)/4))))
```

</details>

Результат вычисления выражения характеризуется значением и типом. Например,
если `а` и `b` — переменные целого типа и описаны так:
```c#
int а = 2, b = 5;
```
то выражение `а + b` имеет значение `7` и тип `int`.

В выражение могут входить операнды различных типов. Если операнды имеют одинаковый тип, то результат операции будет иметь тот же тип. Если операнды разного типа, то перед вычислениями выполняются преобразования более коротких типов в более длинные для сохранения значимости и точности. Иерархия типов данных приведена в следующей схеме:

<div style="max-width: 300px">

![Type hierarchy](../img/type_hierarchy.png)

</div>

Преобразование типов в выражениях происходит *неявно* (без участия программистов) следующим образом. Если одни из операндов имеет тип, изображенный на более низком уровне, чем другой, то он приводится к типу второго операнда при наличии пути между ними. Если пути нет, то возникает ошибка компиляции (чтобы ее избежать, необходимо воспользоваться операцией явного преобразования). Если путей преобразования несколько, то выбирается наиболее короткий, не содержащий пунктирных линий.

Вернемся к рассмотрению операции явного преобразования из предыдущего
раздела:
```c#
static void Main()
{
 int i = -4;
 byte j = 4;
 int a = (int)j; //1
 byte b = (byte)i; //2
 Console.WriteLine("{0} {1}", a, b);
}
```

В строке 1 можно обойтись без явного преобразования типа, т.е. можно записать `a=j`,
т.к. тип `int` в иерархии типов находится выше типа `byte` и существует путь для неявного преобразования типа `byte` в тип `int`. Но пути для неявного преобразования от типа `int` к типу `byte` нет, поэтому в строке 2 нельзя записать `b=i` – компилятор выдаст сообщение об ошибке.

> **Замечание**. Рассмотрим один важный пример. В С++ допустим следующий фрагмент
кода:
>
> ```c++
> int x=10;
> int y= (x)? 1: 2; // 3
> ```
> В данном примере в строке 3 происходит неявное преобразование типа переменной `х`, т.е. типа `int`, к логическому типу. При этом, если `х` принимает значение `0` (или `null` для ссылочных типов), то ему ставится в соответствие логическая величина `false`, всем другим значениям в соответствие ставится логическое значение `true`. В нашем случае переменная `х` принимает ненулевое значение, поэтому оно будет преобразовано к значению `true`, и в переменную `y` запишется значение `1`.
>
> В языке С# подобное неявное преобразование невозможно. Необходимо обязательно
выполнять операцию сравнения значения `х` с `0`. Например, следующим образом:
> ```c#
> int x=10;
> int y= (x!=0)? 1: 2; // 3
> ```

### Основные математические функции
С# содержит большое количество встроенных математических функций, которые реализованы в классе `Math` пространства имен `System`.

Рассмотрим краткое описание некоторых математических функций, подробнее с ними можно познакомиться в справочной системе VS или технической документации. Особое внимание следует обратить на типы операндов и результатов, т.к. каждая *функция* может имееть несколько перегруженных версий.

> **Замечание**. Использование нескольких функций с одним и тем же именем, но с различными типами параметров, называется перегрузкой функции. Например, функция `Math.Abs()`, вычисляющая *модуль* числа, имеет 7 перегруженных версий: `double Math.Abs (double x)`, `float Math.Abs (float x)`, `int Math.Abs(int x)`, и т.д.

№ | Название | Описание
-- | -- | --
1. |  `Math.Abs(<выражение>)` | Модуль
2. |  `Math.Ceiling(<выражение>)` | Округление для большего целого
3. |  `Math.Cos(<выражение>)` | Косинус
4. |  `Math.Е` | Число $е$
5. |  `Math.Exp(<выражение>)` | Экспонента
6. |  `Math.Floor(<выражение>)` |	Округление до меньшего целого
7. |	`Math.Log(<выражение>)` | Натуральный логарифм
8. |	`Math.Log10(<выражение>)` |	Десятичный логарифм
9. |	`Math.Max(<выражение1>, <выражение2>)` |	Максимум из двух значений
10. |	`Math.Min(<выражение1>, <выражение2>)` |	Минимум из двух значений
11. |	`Math.PI`	| Число $\pi$
12. |	`Math.Pow(<выражение1>, <выражение2>)` |	Возведение в степень
13. |	`Math.Round(<выражение>)` |	Простое округление
14. |	`Math.Sign(<выражение>)` |	Знак числа
15. |	`Math.Sin(<выражение>)` |	Синус
16. |	`Math.Sqrt(<выражение>)` |	Квадратный корень
17. |	`Math.Тan(<выражение>)` |	Тангенс

## 15. Функция ввода.
http://smolapo.ru/sites/default/files/Prepod/Efremova/pril/13_2.pdf

Программа при вводе данных и выводе результатов взаимодействует с внешними
устройствами. Совокупность стандартных устройств ввода (клавиатура) и вывода (экран)
называется консолью. В языке С# нет операторов ввода и вывода. Вместо них для обмена
данными с внешними устройствами используются специальные классы. В частности, для
работы с консолью используется стандартный класс `Console`, определенный в пространстве имен `System`.

Для ввода данных обычно используется метод `ReadLine`, реализованный в классе
`Console`. Данный метод в качестве результата возвращает строку, тип которой `string`.

Пример:
```c#
static void Main()
{
 string s = Console.ReadLine();
 Console.WriteLine(s);
}
```

Для того чтобы получить числовое значение, необходимо воспользоваться
преобразованием данных. Пример:
```c#
static void Main()
{
 string s = Console.ReadLine();
 int x = int.Parse(s); //преобразование строки в число
 Console.WriteLine(x);
}
```
Или сокращенный вариант:
```c#
static void Main()
{
 //преобразование введенной строки в число
 int x = int.Parse(Console.ReadLine());
 Console.WriteLine(x);
}
```

Для преобразования строкового представления целого числа в тип `int` мы используем
метод `Parse()`, который реализован для всех числовых типов данных. Таким образом, если нам потребуется преобразовать строковое представление в вещественное, мы можем
воспользоваться методом `float.Parse()` или `double.Parse()`. В случае, если соответствующее преобразование выполнить невозможно, то выполнение программы прерывается и генерируется исключение. Например, если входная строка имела неверный формат, то будет сгенерировано исключение `System.FormatExeption`.

> **Задания**.
>
> 1. Подумайте, какие еще исключения могут возникнуть при использовании метода `Parse`. Проверьте свои предположения на практике.
> 2. Измените предыдущий фрагмент программы так, чтобы с клавиатуры вводилось вещественное число, а на экран это число выводилось с точностью до 3 знаков после запятой.

<details>
<summary><b>Ответы</b></summary>

1. При введении значения, которое не может быть помещено в заданный тип (слишком большое или слишком малое), возникнет ошибка `System.OverflowException: Value was either too large or too small for an Int32.`

2. **Solution**:

    ```c#
    double x = double.Parse(Console.ReadLine());
    Console.WriteLine("{0:.###}", x);
    ```
    **Output**:
    ```
    12.6687954
    12.669
    ```

</details>

При вводе информация от клавиатуры читается как *строка символов*, которую необходимо преобразовать в соответствующий тип данных. Непосредственный ввод осуществляется после нажатия клавиши <kbd>Enter</kbd>.

**Последовательность операторов для ввода целой величины**:
```c#
string sRab="";
int nOzenka=-1;
…
Console.WriteLine("Введите значение переменной nOzenka");
sRab=Console.ReadLine();
nOzenka = Convert.ToInt32(sRab);
```
**Последовательность операторов для ввода вещественной величины**:
```c#
string sRab="";
double dVes1 =0.0;
…
Console.WriteLine("Введите значение переменной dVes1");
sRab=Console.ReadLine();
dVes1= Convert.ToDouble(sRab);
```
Если запустить программу, например из папки *…\bin\Debug\Zan1.exe*,
то по завершению программы консольное окно закрывается автоматически. Аналогично ведет себя программа, если запустить ее в среде программирования командой `Отладка – Начать отладку`. Для приостановки завершения автономного выполнения программы и просмотра результатов ее работы можно вставить в конец программы операторы
```c#
Console.WriteLine("Нажмите <Enter> для завершения программы");
Console.Read();
```

## 16. Функции вывода.
http://smolapo.ru/sites/default/files/Prepod/Efremova/pril/13_2.pdf

Вывод на экран в текстовом режиме называют *консольным*. Любые символы (буквы, цифры) являются *текстом*. Текст заключается в двойные кавычки, он может содержать латинские символы и символы кириллицы. Возможна вставка управляющих символов (см. ниже).

В приведенных выше примерах мы уже рассматривали метод `WriteLine`, реализованный в классе `Console`, который позволяет организовывать вывод данных на экран. Однако существует несколько способов применения данного метода:
1. `Console.WriteLine(x); //на экран выводится значение идентификатора х`
2. `Console.WriteLine("x=" + x +"y=" + y); /* на экран выводится строка,
образованная последовательным слиянием строки "x=", значения x, строки "у=" и
значения у */`
3. `Console.WriteLine("x={0} y={1}", x, y); /* на экран выводится строка, формат
которой задан первым аргументом метода, при этом вместо параметра {0}
выводится значение x, а вместо {1} – значение y*/`

Далее мы будем использовать только третий вариант, поэтому рассмотрим его более
подробно. Пусть нам дан следующий фрагмент программы:
```c#
int i=3, j=4;
Console.WriteLine("{0} {1}", i, j);
```
При обращении к методу `WriteLine` через запятую перечисляются три аргумента:
`"{0} {1}"`, `i`, `j`. Первый аргумент `"{0} {1}"` определяет формат выходной строки. Следующие аргументы нумеруются с нуля, так переменная `i` имеет номер `0`, `j` – номер `1`. Значение переменной `i` будет помещено в выходную строку на место параметра `{0}`, а значение переменной `j` — на место параметра `{1}`. В результате на экран будет выведена строка: `3 4`.

Если мы обратимся к методу `WriteLine` следующим образом:
```c#
Console.WriteLine("{0} {1} {0)", j, i);
```
то на экран будет выведена строка: `4 3 4`.

Данный вариант использования метода WriteLine является наиболее универсальным, потому что он позволяет не только выводить данные на экран, но и управлять форматом их вывода. Рассмотрим несколько примеров:
1) *Использование управляющих последовательностей*:

    **Управляющей последовательностью** называют определенный символ, предваряемый
    обратной косой чертой. Данная совокупность символов интерпретируется как
    одиночный символ и используется для представления кодов символов, не имеющих
    графического обозначения (например, символа перевода курсора на новую строку) или
    символов, имеющих специальное обозначение в символьных и строковых константах
    (например, апостроф). Рассмотрим управляющие символы:

    Вид | Наименование
    -- | --
    `\a` | Звуковой сигнал
    `\b` | Возврат на шаг назад
    `\f` | Перевод страницы
    `\n` | Перевод строки
    `\r` | Возврат каретки
    `\t` | Горизонтальная табуляция
    `\v` | Вертикальная табуляция
    `\\` | Обратная косая черта
    `\’` | Апостроф
    `\”` | Кавычки

    Пример:
    ```c#
    static void Main()
    {
      Console.WriteLine("Ура!\nСегодня \"Информатика\"!!!");
    }
    ```
    ```
    Ура!
    Сегодня "Информатика"!!!
    Для продолжения нажмите любую клавишу...
    ```

    > **Замечание**. Вместо управляющей последовательности `\n` можно использовать константу `Enviropment.NewLine`. Она более универсальна, т.к. ее значение зависит от контекста и операционной системы, в которой запускается программа.

    > **Задание**. Измените программу так, чтобы все сообщение выводилось в одну строку, а после вывода сообщения раздавался звуковой сигнал.

    <details>
    <summary><b>Ответ</b></summary>

    **Solution**:
    ```c#
    static void Main()
    {
      Console.WriteLine("Ура! Сегодня \"Информатика\"!!!\a");
    }
    ```
    **Output**:
    ```
    Ура! Сегодня "Информатика"!!!
    ```

    </details>

2) *Управление размером поля вывода*:

    Первым аргументом `WriteLine` указывается строка вида `{n, m}` – где `n` определяет номер идентификатора из списка аргументов метода `WriteLine`, а `m` – количество позиций (размер поля вывода), отводимых под значение данного идентификатора. При этом
    значение идентификатора выравнивается по правому краю. Если выделенных позиций
    для размещения значения идентификатора окажется недостаточно, то автоматически
    добавится необходимое количество позиций. Пример:
    ```c#
    static void Main()
    {
    double x= Math.E;
    Console.WriteLine("E={0,20}", x);
    Console.WriteLine("E={0,10}", x);
    }
    ```
    ```
    E=    2.71828182845905
    E=2.71828182845905
    >
    ```

3) *Управление размещением вещественных данных*:

    Первым аргументом `WriteLine` указывается строка вида `{n: ##.###}` – где `n` определяет номер идентификатора из списка аргументов метода `WriteLine`, а `##.###` определяет формат вывода вещественного числа. В данном случае, под целую часть числа отводится две позиции, под дробную – три. Если выделенных позиций для размещения целой части значения идентификатора окажется недостаточно, то автоматически добавится необходимое количество позиций. Пример:
    ```c#
    static void Main()
    {
    double x= Math.E;
    Console.WriteLine("E={0:##.###}", x);
    Console.WriteLine("E={0:.####}", x);
    }
    ```
    ```
    E=2.718
    E=2.7183
    >
    ```

    > **Задание**. Измените программу так, чтобы число $e$ выводилось на экран с точностью до 6 знаков после запятой.

    <details>
    <summary><b>Ответ</b></summary>

    **Solution**:
    ```c#
    static void Main()
    {
      Console.WriteLine("E={0:.######}", x);
    }
    ```
    **Output**:
    ```
    E=2.718282
    ```

    </details>

4) *Управление форматом числовых данных*:

    Первым аргументом `WriteLine` указывается строка вида `{n:<спецификатор>m}` – где `n`
    определяет номер идентификатора из списка аргументов метода `WriteLine`,
    `<спецификатор>` — определяет формат данных, а `m` – количество позиций для дробной
    части значения идентификатора. В качестве спецификаторов могут использоваться
    следующие значения:

    Параметр | Формат | Значение
    -- | -- | --
    `C` или `c` | Денежный.<br>По умолчанию ставит денежный знак, определенный текущими региональными настройками. В русской Windows это р. | Задается количество десятичных разрядов.
    `D` или `d` | Целочисленный (используется только с целыми числами) | Задается инимальное количество цифр. При необходимости результат дополняется начальными нулями
    `E` или `e` | Экспоненциальное представление чисел | Задается количество символов после запятой. По умолчанию используется значение 6.
    `F` или `f` | Представление чисел с фиксированной точкой | Задается количество символов после запятой
    `G` или `g` | Общий формат (или экспоненциальный, или с фиксированной точкой) | Задается количество символов после запятой. По умолчанию выводится целая часть
    `N` или `n` | Стандартное форматирование с использованием запятых и пробелов в качестве разделителей между разрядами | Задается количество символов после запятой. По умолчанию – 2, если число целое, то ставятся нули
    `X` или `x` | Шестнадцатеричный формат
    `P` или `p` | Процентный

    Пример:
    ```c#
    static void Main()
    {
    Console.WriteLine("C Format:{0,14:C} \t{0:C2}", 12345.678);
    Console.WriteLine("D Format:{0,14:D} \t{0:D6}", 123);
    Console.WriteLine("E Format:{0,14:E} \t{0:E8}", 12345.6789);
    Console.WriteLine("G Format:{0,14:G} \t{0:G10}", 12345.6789);
    Console.WriteLine("N Format:{0,14:N} \t{0:N4}", 12345.6789);
    Console.WriteLine("X Format:{0,14:X} ", 1234);
    Console.WriteLine("P Format:{0,14:P} ", 0.9);
    }
    ```
    ```
    C Format:    $12,345.68 	$12,345.68
    D Format:           123 	000123
    E Format: 1.234568E+004 	1.23456789E+004
    G Format:    12345.6789 	12345.6789
    N Format:     12,345.68 	12,345.6789
    X Format:           4D2
    P Format:        90.00%
    >
    ```

**Пример вывода текста**:
```c#
Console.WriteLine("Пример \nвывода текста");
```
**Результат отображения на экране**
```
Пример
вывода текста
```
**Вывод на экран текста без перевода строки**
```c#
Console.Write("Введите аргумент ad1= ");
```
**Вывод значений переменной**:
```c#
Console.WriteLine(<имя переменной>);
```
**Например вывод значения переменной `dVes1`**:
```c#
Console.WriteLine(dVes1);
```
**Вывод пустой строки**
```c#
Console.WriteLine();
```
**Вывод с поясняющим текстом (`dVes1 равна 11.4`)**
```c#
Console.WriteLine("\ndVes1=" + dVes1);
```
**Результат отображения, например**
```
dVes1=11,4
```
Целая часть вещественных чисел от дробной отделяется установленным системным разделителем (в тексте программы это точка; при вводе и выводе запятая, если она установлена в Windows).
```c#
Console.WriteLine("вес={0} длина={1}", ves, dl+1.0);
```
Здесь строка – это «шаблон», в который встраиваются значения переменных. Каждый пара фигурных скобок является «заполнителем», на место которых во время выполнения будет заносится значение соответствующей переменной или выражения из списка вывода. Заполнитель содержит номер элемента списка вывода, нумерация начинается с нуля. При выводе числовые значения преобразуются в текст автоматически. Количество заполнителей должно соответствовать количеству элементов списка вывода. При несоответствии количества заполнителей и числа аргументов в ходе выполнения программы будет сформировано исключение `FormatException`.

Для *форматирования* чисел при выводе используют специальные символы:
- с фиксированным разделителем `f (F)`,
- в экспоненциальном формате `e(E)`,
- целых чисел `d(D)` и другие.

Символы форматирования добавляются в виде суффикса к соответствующему заполнителю, например в виде `{0:f3}`, `{0:E}`, `{0:d8}`.

В результате выполнения оператора
```c#
Console.WriteLine("пример f2 ={0:f2}", 1234.678);
```
отобразится текст
```
пример f2 = 1234,68.
```

## 17. Условный оператор в языке С#.
http://smolapo.ru/sites/default/files/Prepod/Efremova/pril/13_3.pdf

Условный оператор `if` используется для разветвления процесса обработки данных на два направления. Он может иметь одну из форм: *сокращенную* или *полную*.

Форма *полного оператора `if`*:
```c#
if (B) S1; else S2;
```
где
- `B` – логическое выражение, истинность которого проверяется;
- `S1`, `S2` — оператор: простой или составной.

При выполнении полной формы оператора `if` сначала вычисляется значение выражения `B`, затем анализируется его результат: если `B` истинно, то выполняется оператор `S1`, а оператор `S2` пропускается; если `B` ложно, то выполняется оператор `S2`, а `S1` – пропускается. Таким образом, с помощью полной формы оператора `if` можно выбрать одно из двух альтернативных действий процесса обработки данных.

*Полная форма*:
```c#
if (<условие>) {<операторы1>;} else {<операторы2>;}
```

Условие записывается в круглых скобках, оно представляет собой логическое выражение. Если условие соответствует истинности выполняется *операторы1*. В случае ложности выполняется *операторы2*. *Операторы* заканчивается символом "`;`".

*Пример записи условного оператора*:
```c#
if ((a>0)&&(a<=1)){ b=1./a;} else {b*=a;}
if (d>=0) {x1= –a+d; x2= –a–d;} else {x1=0; x2=0.0;}
```

После операторных скобок перед `else` символ "`;`" не ставится.

Форма *сокращенного оператора `if`*:
```c#
if (B) S;
```
где
- `В` – логическое выражение, истинность которого проверяется;
- `S` – оператор: простой или составной.

При выполнении сокращенной формы оператора `if` сначала вычисляется выражение
`B`, затем проводится анализ его результата: если `B` истинно, то выполняется оператор `S`; если `B` ложно, то оператор `S` пропускается. Таким образом, с помощью сокращенной формы оператора `if` можно либо выполнить оператор `S`, либо пропустить его.

*Сокращенный вариант записи*:
```c#
if (<условие>) {<операторы3>;}
```
*Операторы3* выполняются только в случае истинности условия. Если условие ложно, то условный оператор эквивалентен «пустому» оператору.

Перед закрывающей операторной скобкой символ "`;`" записывается обязательно. Условные операторы можно вкладывать друг в друга.

Рассмотрим несколько примеров записи условного оператора `if`:
```c#
if (a > 0) x=y; // Сокращенная форма c простым оператором
if (++i>0) {x=y; y=2*z;} // Сокращенная форма c составным оператором
if (a > 0 || b<0) x=y; else x=z; // Полная форма с простым оператором
if (i!=j-1) { x= 0; y= 1;} else {x=1; y:=0;} // Полная форма с составными операторами
```
Операторы `S1` и `S2` могут также являться операторами `if`. Такие операторы называют вложенными. При этом ключевое слово `else` связывается с ближайшим предыдущим словом `if`, которое еще не связано ни с одним `else`. Рассмотрим несколько примеров алгоритмов с использованием вложенных условных операторов:

![Nesting if](../img/nesting-if.png)

> **Замечание**. Т.к. оператор if допускает наличие только одного оператора действия, то можно записывать его без использования блока `{}`, например, так:
> ```c#
> if (x < 0) y = 0; else y=1;
> ```
> Однако предпочтительнее и в этом случае ставить блок, начиная его с новой строки. Это улучшает читабельность программы и значительно сокращает вероятность ошибки при внесении последующих изменений. В нашем случае оператор `if` следует записать так:
> ```c#
> if (x < 0)
> {
>   y = 0;
> }
> else
> {
>   y=1;
> }
> ```
> Далее будем придерживаться данного правила не только для оператора `if`, но и для других операторов.

Рассмотрим несколько примеров использования оператора `if`.

**Пример 1**. Найдем наибольшее значение из двух вещественных чисел:
```c#
static void Main()
{
  Console.Write("x= ");
  double x = double.Parse(Console.ReadLine());
  Console.Write("y=");
  double y = double.Parse(Console.ReadLine());
  double max;
  if (x > y )
  {
    max=x;
  }
  else
  {
    max=y;
  }
  Console.WriteLine("max= {0}", max);
}
```
Результат работы программы:
```
 x    y   max
 0    0   0
 1   -1   1
-2    2   2
```

> **Задания**.
>
> 1. Объясните, почему в данном примере не требуется инициализация переменной `max`.
> 2. Измените программу так, чтобы вычислялось наименьшее значение из двух
вещественных чисел.

<details>
<summary><b>Ответы</b></summary>

1. Инициализация не требуется, потому что невозможно заранее понять, какое значение должна принять переменная `max`. Она его принимает в зависимости от сравнения значений выражений `x` и `y`.
2. Программа:
    ```c#
    static void Main()
    {
        Console.Write("x=");
        double x = double.Parse(Console.ReadLine());
        Console.Write("y=");
        double y = double.Parse(Console.ReadLine());
        double min;
        if (x < y)
        {
            min = x;
        }
        else
        {
            min = y;
        }
        Console.WriteLine("min= {0}", min);
    }
    ```

</details>

> **Замечание**. Вычислить максимум из двух чисел можно с помощью метода `Math.Max(x,y)`.

**Пример 2**. Найдем наибольшее значение из трех вещественных чисел:
```c#
static void Main()
{
  Console.Write("x= ");
  double x = double.Parse(Console.ReadLine());
  Console.Write("y=");
  double y = double.Parse(Console.ReadLine());
  Console.Write("z=");
  double z = double.Parse(Console.ReadLine());
  double max;
  if (x > y && x>z)
  {
    max=x;
  }
  else
  {
    if (y>z)
    {
      max=y;
    }
    else
    {
      max=z;
    }
  }
  Console.WriteLine("max= {0}", max);
}
```
Результат работы программы:
```
 x   y   z   max
 0   0   0   0
 1  -1   2   2
-2  12   2   12
 4  -1  -3   4
```

> Задания.
>
> 1. Измените программу так, чтобы вычислялось наименьшее значение из трех
вещественных чисел.
> 2. Решите данную задачу используя метод `Math.Min(x,y)`.

<details>
<summary><b>Ответы</b></summary>

1. Программа.
    ```c#
    static void Main()
    {
      Console.Write("x= ");
      double x = double.Parse(Console.ReadLine());
      Console.Write("y=");
      double y = double.Parse(Console.ReadLine());
      Console.Write("z=");
      double z = double.Parse(Console.ReadLine());
      double min;
      if (x < y && x < z)
      {
          min = x;
      }
      else
      {
          if (y < z)
          {
              min = y;
          }
          else
          {
              min = z;
          }
      }
      Console.WriteLine("min= {0}", min);
    }
    ```

2. Программа:
    ```c#
    static void Main(string[] args)
    {
        Console.Write("x= ");
        double x = double.Parse(Console.ReadLine());
        Console.Write("y=");
        double y = double.Parse(Console.ReadLine());
        Console.Write("z=");
        double z = double.Parse(Console.ReadLine());
        double min = Math.Min(x, y);
        min = Math.Min(min, z);
        Console.WriteLine("min= {0}", min);
    }
    ```

</details>

*Условная трехместная операция*:
```c#
условие? операнд1: операнд2
```
Пример записи условной операции: `a>b?a:b`.

Применение:
```c#
y=a>b?a:b
```

## 18. Оператор выбора в языке С#.
http://smolapo.ru/sites/default/files/Prepod/Efremova/pril/13_3.pdf

Оператор выбора `switch` предназначен для разветвления процесса вычислений по нескольким направлениям. Формат оператора:
```c#
switch ( <выражение> )
{
 case <константное_выражение_1>:
 [<оператор 1>]; <оператор перехода>;
 case <константное_выражение_2>:
 [<оператор 2>]; <оператор перехода>;
 ...
 case <константное_выражение_n>:
 [<оператор n>]; <оператор перехода>;
 [default: <оператор>; ]
}
```
> **Замечание**. Операторы, записанные в квадратных скобках, являются необязательными
элементами в операторе `switch`. Если они отсутствуют, то могут отсутствовать и
соответствующие им операторы перехода.

Выполнение оператора:
- управление передается оператору `case`, метка которого совпадает со значением переменной в `switch`. Оператор `switch` может включать любое количество экземпляров `case`, но два оператора `case` не могут иметь одинаковое значение;
- переменная должна иметь целый, символьный тип или быть строкой символов. Нельзя использовать вещественные числа;
- значения `case` должны иметь тот же тип, что и переменная;
- после двоеточия за `case` может стоять один или несколько операторов;
- значения `case` должны быть константами;
- если ни одно выражение `case` не совпадает со значением переменной `switch`, управление передается операторам, следующим за необязательной меткой `default`. Если метки `default` нет, то управление передается за пределы оператора `switch`;
- оператор `break` передает управление за пределы конструкции `switch`.

```c#
int ozenka =0;
. . .
//Пример записи оператора
switch (ozenka)
{
  case 5:
  case 4: Console.WriteLine("Отл. и хор. успеваемость");
    break;
  case 3: Console.WriteLine("Уд. успеваемость");
    break;
  case 2:Console.WriteLine("Неуд. успеваемость");
    break;
  default: Console.WriteLine("Недопустимая оценка");
    break;
}
```

Выражение, стоящее за ключевым словом `switch`, должно иметь арифметический,
символьный, строковый тип или тип указатель. Все константные выражения должны иметь
разные значения, но их тип должен совпадать с типом выражения, стоящего внутри скобок
`switch` или приводиться к нему. Ключевое слово `case` и расположенное после него
константное выражение называют также меткой `case`.

Выполнение оператора начинается с вычисления выражения, расположенного за ключевым словом `switch`. Полученный результат сравнивается с меткой `case`. Если результат выражения соответствует метке `case`, то выполняется оператор, стоящий после этой метки, за которым обязательно должен следовать оператор перехода: `break`, `goto` и т.д. В случае отсутствия оператора перехода компилятор выдаст сообщении об ошибке. При использовании оператора `break` происходит выход из `switch` и управление передается оператору, следующему за `switch`. Если же используется оператор `goto`, то управление передается оператору, помеченному меткой, стоящей после `goto`.

*Оператор безусловного перехода*:
```c#
goto <метка>;
```
Метки специально объявлять не надо, они ставятся перед оператором:
```c#
goto met1;
…
met1: y=1;
```

> **Замечания**.
>
> Оператор перехода `goto` лучше использовать для перехода по меткам внутри `switch`, и не использовать его для выхода из оператора `switch`.
> Для повышения производительности рекомендуется размещать ветви, вероятность
выбора которых является наибольшей, ближе к началу. В этом случае будет на выбор требуемого варианта будет тратиться меньше времени.

**Пример**. По заданному виду арифметической операции (сложение, вычитание, умножение и деление) и двум операндам, вывести на экран результат применения данной операции к операндам.
```c#
static void Main()
{
  Console.Write("OPER= ");
  char oper=char.Parse(Console.ReadLine());
  bool ok=true;
  Console.Write("A= ");
  double a=double.Parse(Console.ReadLine());
  Console.Write("B= ");
  double b=double.Parse(Console.ReadLine());
  double res=0;
  switch (oper)
  {
    case '+' :
      res = a + b;
      break; //1
    case '-' :
      res = a - b;
      break;
    case '*' :
      res = a * b;
      break;
    case ':' :
      if (b != 0) //2
      {
        res = a / b;
        break;
      }
      else
      {
        goto default;
      }
    default:
      ok = false;
      break;
  }
  if (ok)
  {
    Console.WriteLine("{0} {1} {2} = {3}", a, oper, b, res);
  }
  else
  {
    Console.WriteLine("error");
  }
}
```
Результат выполнения программы:
```
oper  x   y   rez
+     4   5   9
:     4   0   error
%     4   3   error
```

Если необходимо, чтобы для разных меток выполнялось одно и то же действие, то метки перечисляются через двоеточие. Например:
```c#
switch (oper)
{
  case '+':
    res = a + b;
    break;
  case '-':
    res = a - b;
    break;
  case '*':
    res = a * b;
    break;
  case ':' : case '/' : //перечисление меток
    if (b != 0)
    {
      res = a / b;
      break;
    }
    else
    {
      goto default;
    }
  default:
    ok = false;
    break;
}
```

## 19. Циклические операторы в языке С#: цикл с предусловием, цикл с постусловием, цикл с параметром.
http://smolapo.ru/sites/default/files/Prepod/Efremova/pril/13_3.pdf

Операторы цикла используются для организации многократно повторяющихся вычислений. К операторам цикла относятся: цикл с предусловием `while`, цикл с постусловием `do while`, цикл с параметром `for` и цикл перебора `foreach`.

### Цикл с предусловием `while`

```c#
начальные установки
while (условие)
{
//тело цикла (может не выполнится ни разу)
}
```

Оператор цикла `while` организует выполнение одного оператора (простого или составного) неизвестное заранее число раз. Формат цикла `while`:
```c#
while (B) S;
```
где
- `B` – выражение, истинность которого проверяется (условие завершения цикла);
- `S` – тело цикла (простой или составной оператор).

Перед каждым выполнением тела цикла анализируется значение выражения `В`: если оно истинно, то выполняется тело цикла, и управление передается на повторную проверку условия `В`; если значение `В` ложно – цикл завершается и управление передается на оператор, следующий за оператором `S`.

Если результат выражения `B` окажется ложным при первой проверке, то тело цикла не выполнится ни разу. Отметим, что если внутри цикла не будет оператора (или операторов), в результате выполнения которых условие `B` на какой-то итерации станет ложным, то произойдет зацикливание, то есть невозможность выхода из цикла. Поэтому внутри тела должны находиться операторы, приводящие к изменению значения выражения `B` так, чтобы цикл мог корректно завершиться.

В качестве иллюстрации выполнения цикла `while` рассмотрим программу вывода на экран целых чисел из интервала от 1 до `n`.
```c#
static void Main()
{
  Console.Write("N= ");
  int n=int.Parse(Console.ReadLine());
  int i = 1;
  while (i <= n) //пока i меньше или равно n
  {
    //выводим i на экран, затем увеличиваем его на 1
    Console.Write(" {0}", i++ );
  }
}
```
Результаты работы программы:
```
n   ответ
10  1 2 3 4 5 6 7 8 9 10
```

### Цикл с постусловием `do while`

```c#
начальные установки
do
{
//тело цикла (выполняется хотя бы один раз)
}
while (условие);
```

Оператор цикла `do while` также организует выполнение одного оператора (простого или составного) неизвестное заранее число раз. Однако в отличие от цикла `while` условие завершения цикла проверяется после выполнения тела цикла. Формат цикла `do while`:
```c#
do S while (B);
```
где
- `В` – выражение, истинность которого проверяется (условие завершения цикла);
- `S` – тело цикла (простой или составной оператор).

Сначала выполняется оператор `S`, а затем анализируется значение выражения `В`: если оно истинно, то управление передается оператору `S`, если ложно — цикл завершается, и управление передается на оператор, следующий за условием `B`. Так как условие `В` проверяется после выполнения тела цикла, то в любом случае тело цикла выполнится хотя бы один раз.

В операторе `do while`, так же как и в операторе `while`, возможна ситуация зацикливания в случае, если условие `В` всегда будет оставаться истинным.

В качестве иллюстрации выполнения цикла `do while` рассмотрим программу вывода на экран целых чисел из интервала от $1$ до $n$.
```c#
static void Main()
{
 Console.Write("N= ");
 int n=int.Parse(Console.ReadLine());
 int i = 1;
 do
  Console.Write(" {0}", i++); //выводим i на экран, затем увеличиваем его на 1
 while (i <= n); //пока i меньше или равно n
}
```

### Цикл с параметром `for`

```c#
for(<операторы1>; <условие>; <операторы2>)
{
//тело цикла
}
```

Цикл с параметром имеет следующую структуру:
```c#
for ( <инициализация>; <выражение>; <модификация>) <оператор>;
```
*Инициализация* используется для объявления и/или присвоения начального значения величине, используемой в цикле в качестве параметра (счетчика). Областью действия переменной, объявленной в части инициализации цикла, является цикл и вложенные блоки. Инициализация выполняется один раз в начале исполнения цикла.

*Выражение* определяет условие выполнения цикла: если его результатом является истина, цикл выполняется. Истинность выражения проверяется перед каждым выполнением тела цикла, таким образом, цикл с параметром реализован как цикл с предусловием.

*Модификация* выполняется после каждой итерации цикла и служит обычно для изменения параметра цикла.

*Оператор* (простой или составной) представляет собой тело цикла.

Любая из частей оператора `for` (инициализация, выражение, модификация, оператор) может отсутствовать, но точку с запятой, определяющую позицию пропускаемой части, надо оставить.
```c#
static void Main()
{
 Console.Write("N= ");
 int n=int.Parse(Console.ReadLine());
 for (int i=1; i<=n; i++)
 {
  Console.Write("{0}", i);
 }
}
```

### Вложенные циклы
Циклы могут быть простые или вложенные (кратные, циклы в цикле). Вложенными могут быть циклы любых типов: `while`, `do while`, `for`. Каждый внутренний цикл должен быть полностью вложен во все внешние циклы. «Пересечения» циклов не допускаются.

Рассмотрим пример использования вложенных циклов, который позволит вывести
на экран числа следующим образом:
```
2 2 2 2 2
2 2 2 2 2
2 2 2 2 2
2 2 2 2 2
```
```c#
static void Main()
{
 for (int i = 1; i <= 4; ++i)
 {
  for (int j=1; j<=5; ++j)
  {
    Console.Write(”2 ”);
  }
 Console.WreLine();
 }
}
```

## 20. Операторы передачи управления `break` и `continue`.
http://smolapo.ru/sites/default/files/Prepod/Efremova/pril/13_3.pdf

В С# есть несколько операторов, изменяющих естественный порядок выполнения команд: оператор безусловного перехода `goto`, оператор выхода `break`, оператор перехода к следующей итерации цикла `continue`, оператор возврата из метода `return` и оператор генерации исключения `throw`.

### Оператор безусловного перехода `goto`
Оператор безусловного перехода `goto` имеет формат:
```c#
goto <метка>;
```
В теле того же метода должна присутствовать ровно одна конструкция вида:
```c#
<метка>: <оператор>;
```
Оператор `goto` передает управление оператору с меткой. Рассмотрим пример использования оператора `goto`:
```c#
static void Main()
{
  float x;
  label: Console.WriteLine("x="); //оператор, помеченный меткой
  x = float.Parse(Console.ReadLine());
  if (x!=0)
  {
    Console.WriteLine("y({0})={1}", x, 1 / x );
  }
  else
  {
    Console.WriteLine("функция не определена");
    goto label; // передача управление метке
  }
}
```
Следует учитывать, что использование оператора `goto` затрудняет чтение больших по объему программ, поэтому использовать метки нужно только в крайних случаях.

### Оператор выхода `break`
Оператор `break` используется внутри операторов цикла и оператора выбора для обеспечения перехода в точку программы, находящуюся непосредственно за оператором, внутри которого находится `break`.

*Пример использования внутри оператора `switch`*:
```c#
switch (<переменная порядкового типа>)
{
  case i1: /*действия для случая, когда переменная принимает значение, равное i1 */
    break;
  case i2: /* действия для случая, когда переменная принимает значение, равное i2 */
    break;
  … //конечно многоточие в программе отсутствует
  default: // действия для случая, когда переменная принимает значение, отличающееся от перечисленных значений
    break;
}
```

Мы уже применяли оператор `break` для выхода из оператора `switch`, аналогичным образом он может применяться для выхода из операторов цикла.

### Оператор перехода к следующей итерации цикла `continue`
Оператор перехода к следующей итерации цикла `continue` пропускает все операторы, оставшиеся до конца тела цикла, и передает управление на начало следующей итерации (повторение тела цикла). Рассмотрим оператор `continue` на примере.
```c#
static void Main()
{
 Console.WriteLine("n=");
 int n = int.Parse(Console.ReadLine());
 for (int i = 1; i <= n; i++)
 {
  if (i % 2 == 0)
  {
    continue;
  }
  Console.Write(" {0} ", i);
 }
}
```

> **Замечание**. Оператор `return` будет рассмотрен позже. Оператор `throw` рассматривается в следующей секции, посвященной обработке исключений.

### Обработка исключений
Язык С#, как и многие другие объектно-ориентированные языки, реагирует на ошибки и ненормальные ситуации с помощью механизма обработки исключений. **Исключение** — это объект, генерирующий информацию о "необычном программном происшествии". При этом важно проводить различие между ошибкой в программе, ошибочной ситуацией и исключительной ситуацией.

**Ошибка** в программе допускается программистом при ее разработке. Например, вместо операции сравнения (`==`) используется операция присваивания (`=`). Программист должен исправить подобные ошибки до передачи кода программы заказчику. Использование механизма обработки исключений не является защитой от ошибок в программе.

**Ошибочная ситуация** вызвана действиями пользователя. Например, пользователь вместо числа ввел строку. Такая ошибка способна вызывать исключение. Программист должен предвидеть ошибочные ситуации и предотвращать их с помощью операторов, проверяющих допустимость поступающих данных.

Даже если программист исправил все свои ошибки в программе, предвидел все ошибочные ситуации, он все равно может столкнуться с непредсказуемыми и неотвратимыми проблемами — **исключительными ситуациями**. Например, нехваткой доступной памяти или попыткой открыть несуществующий файл. Исключительные ситуации программист предвидеть не может, но он может отреагировать на них так, что они не приведут к краху программы.

Для обработки ошибочных и исключительных ситуаций в С# используется специальная подсистема обработки исключений. Преимущество данной подсистемы состоит в автоматизации создания большей части кода по обработке исключений. Раньше этот код приходилось вводить в программу "вручную". Кроме этого обработчик исключений способен распознавать и выдавать информацию о таких стандартных исключениях, как деление на нуль или попадание вне диапазона определения индекса.

#### Оператор `try`
В С# исключения представляются классами. Все классы исключений порождены от встроенного класса исключений `Exception`, который определен в пространстве имен `System`.

Управление обработкой исключений основывается на использовании оператора `try`. Синтаксис оператора:
```c#
try	// контролируемый блок
{
  …
}
catch //один или несколько блоков обработки исключений
{
  …
}
finally	//блок завершения
{
  …
}
```
Программные инструкции, которые нужно проконтролировать на предмет исключений, помещаются в блок `try`. Если исключение возникает в этом блоке, оно дает знать о себе выбросом определенного рода информации. Выброшенная информация может быть перехвачена и обработана соответствующим образом с помощью блока `catch`. Любой код, который должен быть обязательно выполнен при выходе из блока `try`, помещается в блок `finally`. Рассмотрим пример, демонстрирующий, как отследить и перехватить исключение.
```c#
static void Main()
{
  int  x = int.Parse(Console.ReadLine());
  int y =1 / x;
  Console.WriteLine(y);
}
```
Перечислим, какие исключительные ситуации могут возникнуть:

- пользователь может ввести нечисловое значение
- если ввести значение `0`, то произойдет деление на 0.

В первом случае система выведет ошибку `Unhandled exception. System.FormatException: The input string 'a' was not in a correct format.`, во втором — `Unhandled exception. System.DivideByZeroException: Attempted to divide by zero.`

> **Задание**. Переменные `x` и `y` объявлены целочисленными. Объясните, что будет выведено на экран, если заменить их тип на `double` и ввести с клавиатуры значение `х` равное `0`, и почему.

<details>
<summary><b>Ответ</b></summary>

Деление на ноль для `double` вместо исключения выдает специальное значение (`Infinity` или `NaN`), поэтому ошибки не возникнет.

</details>

Теперь попробуем обработать эти ситуации. Для этого изменим код следующим образом.
```c#
static void Main()
{
  try
  {
    int x = int.Parse(Console.ReadLine());
    int y =1 / x;
    Console.WriteLine("y={0}", y);
    Console.WriteLine("блок try выполнился успешно");
  }
  catch		// *
  {
    Console.WriteLine("возникла какая-то ошибка");
  }
  Console.WriteLine("конец программы");
}
```
Рассмотрим, как обрабатываются исключения в данном примере. Когда возникает исключение, выполнение программы останавливается и управление передается блоку `catch`. Этот блок *никогда* не возвращает управление в то место программы, где возникло исключение. Поэтому команды из блока `try`, расположенные ниже строки, в которой возникло исключение, никогда не будут выполнены. Блок `catch` обрабатывает исключение, и выполнение программы продолжается с оператора, следующего за этим блоком.

В нашем случае при вводе нечислового значения или `0` будет выведено сообщение "возникла ошибка", а затем сообщение "конец программы".

Обработчик исключений позволяет не только отловить ошибку, но и вывести полную информацию о ней. Для демонстрации сказанного заменим блок `catch` следующим фрагментом.
```c#
catch (Exception error)
{
  Console.WriteLine("Возникла ошибка {0}", error);
}
```
Теперь, если возникнет исключительная ситуация, "выброшенная" информация будет записана в идентификатор `error`. Данную информацию можно просмотреть с помощью метода `WriteLine`. Такое сообщение очень полное и будет полезно только разработчику на этапе отладки проекта.

Для пользователя на этапе эксплуатации приложения достаточно более краткой информации о типе ошибке. С этой целью в С# выделены стандартные классы исключений, такие как `DivideByZeroException`, `FormatException`. Внесем изменения в программу.
```c#
static void Main()
{
  try
  {
    int x = int.Parse(Console.ReadLine());    // 1 ситуация
    int y =1 / x;   // 2 ситуация
    Console.WriteLine("y={0}", y);
    Console.WriteLine("блок try выполнился успешно");
  }
  catch(FormatException)  // обработка 1 ситуации
  {
    Console.WriteLine("Ошибка: введено нечисловое значение!");
  }
  catch (DivideByZeroException) // обработка 2 ситуации
  {
    Console.WriteLine("Ошибка: деление на 0!");
  }
  Console.WriteLine("конец программы");
}
```
В данном примере обрабатывается каждая ситуация в отдельности, при этом пользователю сообщается лишь минимальная информация об ошибке. В следующей таблице содержится описание наиболее часто используемых обработчиков стандартных исключений.

Имя |	Описание
-- | --
`ArithmeticException` |	Ошибка в арифметических операциях или преобразованиях
`ArrayTypeMismatchException` |	Попытка сохранения в массиве элемента несовместимого типа
`DivideByZeroException` |	Попытка деления на ноль
`FormatException` |	Попытка передать в метод аргумент неверного формата
`IndexOutOfRangeException` |	Индекс массива выходит за границу диапазона
`InvalidCastException` |	Ошибка преобразования типа
`OutOfMemoryException` |	Недостаточно памяти для нового объекта
`OverflowException` |	Переполнение при выполнении арифметических операций
`StackOverflowException` |	Переполнение стека

Одно из основных достоинств обработки исключений состоит в том, что она позволяет программе отреагировать на ошибку и продолжить выполнение. Рассмотрим программу, которая строит таблицу значений для функции вида $y(x)=\frac{100}{(x^2-1)}$.
```c#
static void Main()
{
 Console.WriteLine("a=");
 int a = int.Parse( Console.ReadLine());
 Console.WriteLine("b=");
 int b = int.Parse(Console.ReadLine());
 for (int i = a; i <= b; ++i)
 {
  try
  {
   Console.WriteLine("y({0})={1}", i, 100 / (i * i - 1));
  }
  catch (DivideByZeroException)
  {
   Console.WriteLine("y({0})=Деление на 0", i);
  }
 }
}
```
Если встречается деление на нуль, генерируется исключение типа `DivideByZeroException`. В программе это исключение обрабатывается выдачей сообщения об ошибке, после чего выполнение программы продолжается. При этом попытка разделить на нуль не вызывает внезапную динамическую ошибку (т.к. блок обработки прерываний помещен внутрь цикла `for`). Вместо этого исключение позволяет красиво выйти из ошибочной ситуации и продолжить выполнение программы.

#### Операторы `checked` и `unchecked`
В С# предусмотрено специальное средство, которое связано с генерированием исключений, вызванных переполнением результата в арифметических вычислениях. Например, когда значение арифметического выражения выходит за пределы диапазона, определенного для типа данных выражения. Рассмотрим небольшой фрагмент программы:
```c#
static void Main()
{
 byte x = 200; byte y = 200;
 byte result = (byte) (x + y);
 Console.WriteLine(result);
}
```

Output
```
144
```

Здесь сумма значений `а` и `b` превышает диапазон представления значений типа `byte`. Следовательно, результат данного выражения не может быть записан в переменную `result`, тип которой `byte`.

Для управления подобными исключениями в С# используются операторы `checked` и `unchecked`. Чтобы указать, что некоторое выражение должно быть проконтролировано на предмет переполнения, используйте ключевое слово `checked`. А чтобы проигнорировать переполнение, используйте ключевое слово `unchecked`. В последнем случае результат будет усечен так, чтобы его тип соответствовал типу-результату выражения.

> **Замечание**. По умолчанию проверка переполнения отключена (галочка не стоит). В результате код выполняется быстро, но тогда программист должен быть уверен, что переполнения не случится или предусмотреть его возникновение. Как мы уже упоминали, можно включить проверку переполнения для всего проекта, однако она не всегда нужна. С помощью использования операторов `checked` и `unchecked` в С# реализуется механизм гибкого управления проверкой.

Можно задать (или отключить) проверку переполнения сразу для всего проекта. Для этого необходимо выполнить следующие действия

1. Щелкнуть правой кнопкой мыши на имени проекта
2. В выпадающем меню выбрать *Properties*
3. В появившемся окне (см. рис.) выбрать слева страницу *Build*
4. Щелкнуть на кнопке *Advanced*
5. В появившемся окошке поставить или убрать галочку напротив *Check for arithmetic overflow/underflow*.

![Check for arithmetic overflow/underflow property](../img/07_01.gif)

Оператор `checked` имеет две формы:

1. проверяет конкретное выражение и называется *операторной checked-формой*

    ```c#
    checked ((тип-выражения) expr)
    ```
    где  `expr` — выражение, значение которого необходимо контролировать. Если значение контролируемого выражения переполнилось, генерируется исключение типа `OverflowException`.

2. проверяет блок инструкций

    ```c#
    checked
    {
    // Инструкции, подлежащие проверке.
    }
    ```

Оператор `unchecked` также имеет две формы:

1. операторная форма, которая позволяет игнорировать переполнение для заданного выражения

    ```c#
    unchecked ((тип-выражения) expr)
    ```
    где `ехрr`  — выражение, которое не проверяется на предмет переполнения. В случае переполнения это выражение усекается.

2. игнорирует переполнение, которое возможно в блоке инструкций

    ```c#
    unchecked
    {
    // Инструкции, для которых переполнение игнорируется.
    }
    ```

Рассмотрим пример программы, которая демонстрирует использование `checked` и `unchecked`.
```c#
static void Main()
{
 byte x = 200; byte y = 200;
 try
 {
  byte result = unchecked((byte)(x + y));
  Console.WriteLine("1: {0}", result);
  result = checked((byte)(x + y));
  Console.WriteLine("2: ", result);
 }
 catch (OverflowException)
 {
  Console.WriteLine("возникло переполнение");
 }
}
```

Результат выполнения программы:
```
1: 144
```
возникло переполнение

> **Задание**. Уберите блок `uncheсked`. Посмотрите, что изменится в выполнении программы и дайте этому объяснение

<details>
<summary>Ответ</summary>

Ничего не изменилось, поскольку переполнение повторно контролируется оператором `checked`, предписывающим сгенерировать исключение в случае переполнения. В обоих случаях исполнение программы будет оборвано до выполнения инструкции `Console.WriteLine("2: ", result);`.

</details>

В данном примере мы посмотрели, как использовать `checked` и `uncheсked` для проверки выражения. А теперь посмотрим, как использовать их для контроля за блоком инструкций.
```c#
static void Main()
{
 byte n = 1; byte i;
 try
 {
  unchecked	//блок без проверки
  {
   for (i = 1; i < 10; i++) n *= i;
   Console.WriteLine("1: {0}", n);
  }
  checked 	//блок с проверкой
  {
   n=1;
   for (i = 1; i < 10; i++) n *= i;
   Console.WriteLine("2: ", n);
  }
 }
 catch (OverflowException)
 {
  Console.WriteLine("возникло переполнение");
 }
}
```
Результат выполнения программы:
```
1: 128
```
возникло переполнение

> **Задание**. Поменяйте местами блоки `unchecked` и `checked`. Посмотрите, что изменится в выполнении программы и дайте этому объяснение

<details>
<summary>Ответ</summary>

Результат выполнения:
```
возникло переполнение
```

В этом случае выполнение кода не дойдёт до инструкций `Console.WriteLine()`.

</details>

#### Генерация собственных исключений
До сих пор мы рассматривали исключения, которые генерирует среда, но сгенерировать исключение может и сам программист. Для этого необходимо воспользоваться оператором `throw`, указав параметры, определяющие вид исключения. Параметром должен быть объект, порожденный от стандартного класса `System.Exception`. Этот объект используется для передачи информации об исключении обработчику.
```c#
static void Main()
{
 try
 {
  int x = int.Parse(Console.ReadLine());
  if (x < 0) throw new Exception(); //1
  Console.WriteLine("ok");
 }
 catch
 {
  Console.WriteLine("введено недопустимое значение");
 }
}
```
В строчке 1 c помощью команды new был создан объект исключения типа `Exception`. При необходимости можно генерировать исключение любого типа.

При генерации исключения можно определить сообщение, которое будет "выбрасываться" обработчиком исключений. Например:
```c#
static void Main()
{
 try
 {
  int x = int.Parse(Console.ReadLine());
  if (x < 0) throw new Exception("введено недопустимое значение"); //1
  Console.WriteLine("ok");
 }
 catch (Exception error)
 {
  Console.WriteLine(error.Message);
 }
}
```

Рассмотрим несколько полезных приемов использования обработчиков исключений.

**Пример 1**. Один `try`-блок можно вложить в другой. Исключение, сгенерированное во внутреннем `try`-блоке и не перехваченное `catch`-инструкцией, которая связана с этим `try`-блоком, передается во внешний `try`-блок. Например, в следующей программе исключение типа `ArithmeticException` перехватывается не внутренним `try`-блоком, а внешним.
```c#
static void Main()
{
 Console.WriteLine("a=");
 byte a = byte.Parse(Console.ReadLine());
 Console.WriteLine("b=");
 byte b = byte.Parse(Console.ReadLine());
 int f=1;
 try //Внешний блок-try
 {
  for (byte i = a; i <= b; ++i)
  {
   try //Внутренний блок-try
   {
    f=checked((int)(f*i));
    Console.WriteLine("y({0})={1:f6}", i, 100 / (f - 1));
   }
   catch (DivideByZeroException)
   {
    Console.WriteLine("y({0})=Деление на 0", i);
   }
  }
 }
 catch (ArithmeticException)
 {
  Console.WriteLine("ERROR");
 }
}
```
Использование вложенных `try`-блоков обусловлено желанием обрабатывать различные категории ошибок различными способами. Одни типы ошибок носят катастрофический характер и не подлежат исправлению. Другие — неопасны для дальнейшего функционирования программы, и с ними можно справиться прямо на месте их возникновения. Поэтому внешний `try`-блок можно использовать для перехвата самых серьезных ошибок, позволяя внутренним `try`-блокам обрабатывать менее опасные.

**Пример 2**. Исключение, перехваченное одной `catch`-инструкцией, можно сгенерировать повторно, чтобы обеспечить возможность его перехвата другой (внешней) `catch`-инструкцией. Это позволяет нескольким обработчикам получить доступ к исключению.
```c#
static void genException ()
{
 Console.WriteLine("a=");
 double a = double.Parse(Console.ReadLine());
 Console.WriteLine("b=");
 double b = double.Parse(Console.ReadLine());
 int f = 1;
 try //Внешний блок-try
 {
  for (double i = a; i <= b; ++i)
  {
   try //Внутренний блок-try
   {
    f = checked((int)(f * i));
    Console.WriteLine("y({0})={1:f6}", i, 100 / (f - 1));
   }
   catch (DivideByZeroException)
   {
    Console.WriteLine("y({0})=Деление на 0", i);
   }
  }
 }
 catch (ArithmeticException)
 {
  Console.WriteLine("ERROR");
  throw ; //повторная генерация исключения
 }
}

static void Main()
{
 try
 {
  genException();
 }
 catch
 {
  Console.WriteLine("НЕИСПРАВИМАЯ ОШИБКА!!!");
 }
}
```
Нужно помнить, что при повторном генерировании исключения оно не будет повторно перехватываться той же `catch`-инструкцией, а передается следующей (внешней) `catch`-инструкции.

> **Задания**.
>
> 1. Объясните почему не было сгенерировано исключение `DivideByZeroException`.
> 2. Сгенерируйте собственное исключение `DivideByZeroException` и его обработку для ситуации `f-1<0.000001`.

**Пример 3**.Как упоминалось выше, тип исключения должен совпадать с типом, заданным в `catch`-инструкции. В противном случае это исключение не будет перехвачено. Можно перехватывать все исключения, используя `catch`-инструкцию без параметров. Кроме того, с `try`-блоком можно связать не одну, а несколько `catch`-инструкций. В этом случае все `catch`-инструкции должны перехватывать исключения различного типа. Если вы все же не уверены, что предусмотрели все ситуации, то последней можно добавить `catch`-инструкцию без параметров.

> **Замечание**. Иногда возникает потребность в обязательном выполнении каких-то действий, которые должны выполниться по выходу из `try/catch`-блока. Например, генерируется исключение и происходит преждевременное завершение выполнения программного фрагмента, но при этом остается открытым файл. Для выхода из такой ситуации С# предоставляет блок `finally`, который добавляется после всех блоков `catch`.
```c#
static void Main()
{
 for (int i = 0; i < 5; i++)
 {
  try
  {
   Console.WriteLine("Введите два числа");
   int a = int.Parse(Console.ReadLine());
   int b = int.Parse(Console.ReadLine());
   Console.WriteLine(a+"/"+b+"="+a/b);
  }
  catch (FormatException)
  {
   Console.WriteLine("Нужно ввести число!");
  }
  catch (DivideByZeroException)
  {
   Console.WriteLine("Делить на нуль нельзя!");
  }
  catch
  {
   Console.WriteLine("Какая-то ошибка");
  }
  finally
  {
   Console.WriteLine("после try-блока");
  }
 }
}
```
> **Задание**. Протестируйте данную программу, вводя поочередно следующие значения:
```
a=4, b=2
a=3, b=g
a=d, b=1
a=2, b=0,
a=123456789987654321, b=1
```

## 21. Методы в С#
https://intuit.ru/studies/courses/486/342/lecture/8231

### Основные понятия
**Метод** – это функциональный элемент класса, который реализует вычисления или другие действия, выполняемые классом или его экземпляром (объектом). Метод представляет собой законченный фрагмент кода, к которому можно обратиться по имени. Он описывается один раз, а вызываться может многократно. Совокупность методов класса определяет, что конкретно может делать класс. Например, стандартный класс `Math` содержит методы, которые позволяют вычислять значения математических функций.

Синтаксис метода:
```c#
[атрибуты] [спецификторы] тип_возвращаемого_результата имя_метода ([список_параметров])
{
  тело_метода;
  return значение
}
```
где:
- *Атрибуты* и *спецификторы* являются необязательными элементами синтаксиса описания метода. На данном этапе атрибуты нами использоваться не будут, а из всех спецификаторов мы в обязательном порядке будем использовать спецификатор `static`, который позволит обращаться к методу класса без создания его экземпляра.<br>
  > **Замечание**. Остальные спецификаторы будут рассмотрены в разделе "классы".
- *Тип_возвращаемого_результата* определяет тип значения, возвращаемого методом. Это может быть любой тип, включая типы классов, создаваемые программистом. Если метод не возвращает никакого значения, необходимо указать тип `void` (в этом случае в теле метода отсутствует оператор `return`).
- *Имя_метода* – идентификатор, заданный программистом с учетом требований, накладываемыми на идентификаторы в С#, отличный от тех, которые уже использованы для других элементов программы в пределах текущей области видимости.
- *Список_параметров* представляет собой последовательность пар, состоящих из типа данных и идентификатора, разделенных запятыми. **Параметры** — это переменные или константы, которые получают значения, передаваемые методу при вызове. Если метод не имеет параметров, то *список_параметров* остается пустым.
- *Значение* определяет значение, возвращаемое методом. Тип значения должен соответствовать *типу_возвращаемого_результата* или приводится к нему.

Рассмотрим простейший пример метода:
```c#
class Program
  {
     static void Func()	//дополнительный метод
     {
        Console.Write("x= ");
        double x=double.Parse(Console.ReadLine());
        double y = 1 / x;
        Console.WriteLine("y({0})={1}", x,y );
      }

      static void Main()	//точка входа в программу
      {
        Func();	//первый вызов метода Func
        Func();	//второй вызов метода Func
       }
   }
```
В даном примере в метод `Func` не передаются никакие значения, поэтому список параметров пуст. Кроме того метод ничего не возвращает, поэтому тип возвращаемого значения `void`. В основном методе `Main` мы вызвали метод `Func` два раза. Если будет необходимо, то данный метод можно будет вызвать еще столько раз, сколько потребуется для решения задачи.

Изменим исходный пример так, чтобы в него передавалось значение `х`, а сам метод возвращал значение `y`.
```c#
class Program
  {
    static double Func( double x) //дополнительный метод
    {
      return 1 / x; //Возвращаемое значение
    }

    static void Main()	//точка входа в программу
    {
      Console.Write("a=");
      double a=double.Parse(Console.ReadLine());
      Console.Write("b=");
      double b=double.Parse(Console.ReadLine());
      for (double x = a; x <= b; x += 0.5)
      {
          double y = Func(x); //вызов метода Func
          Console.WriteLine("y({0:f1})={1:f2}", x, y);
      }
    }
  }
```
В данном примере метод `Func` содержит параметр `х`, тип которого `double`. Для того, чтобы метод `Func` возвращал в вызывающий его метод `Main` значение выражения `1/x` (тип которого `double`), перед именем метода указывается тип возвращаемого значения – `double`, а в теле метода используется оператор передачи управления – `return`. Оператор `return` завершает выполнение метода и передает управление в точку его вызова.

Рассмотрим другой пример:
```c#
class Program
    {
        static int Func( int x, int y)	//строка 1
        {
            return (x>y)? x:y;
        }

        static void Main()
        {
            Console.Write("a=");
            int a = int.Parse(Console.ReadLine());
            Console.Write("b=");
            int b = int.Parse(Console.ReadLine());
            Console.Write("c=");
            int c = int.Parse(Console.ReadLine());
            int max = Func(Func(a, b), c);	//строка 2 - вызовы метода Func
            Console.WriteLine("max({0}, {1}, {2})={3}", a, b, c, max);
        }
      }
```
В данном примере метод `Func` имеет два целочисленных параметра – `x`, `y`, а в качестве результата метод возвращает наибольшее из них. На этапе описания метода (строка 1) указываются *формальные* параметры, на этапе вызова (строка 2) в метод передаются *фактические* параметры, которые по количеству и по типу совпадают с формальными параметрами. Если количество фактических и формальных параметров будет различным, то компилятор выдаст соответствующее сообщение об ошибке. Если параметры будут отличаться типами, то компилятор попытается выполнить *неявное преобразование типов*. Если *неявное преобразование* невозможно, то также будет сгенерирована ошибка.

> **Параметры** (формальные параметры) – это переменные, которые определяются в момент создания функции и служат как место для данных, которые будут использованы в этой функции. **Аргументы** (фактические параметры) – это конкретные значения, которые передаются в функцию при её вызове.

Обратите внимание на то, что при вызове метода `Func` использовалось вложение одного вызова в другой.

В общем случае параметры используются для обмена информацией между вызывающим и вызываемым методами. В С# для обмена предусмотрено четыре типа параметров:
- *параметры-значения*,
- *параметры-ссылки*,
- *выходные параметры*,
- *параметры-массивы*.

При передаче **параметра по значению** метод получает копии параметров, и операторы метода работают с этими копиями. Доступа к исходным значениям параметров у метода нет, а, следовательно, нет и возможности их изменить.

Замечание. Все примеры, рассмотренные ранее, использовали передачу данных по значению.
Рассмотрим небольшой пример:
```c#
class Program
  {
    static void Func(int x)
     {
        x += 10;	// изменили значение параметра
        Console.WriteLine("In Func: " + x);
      }

     static void Main()
      {
         int a=10;
         Console.WriteLine("In Main: "+ a);
         Func(a);
        Console.WriteLine("In Main: " + a);
      }
  }
```
Результат работы программы:
```
In Main: 10
In Func: 20
In Main: 10
```
В данном примере значение формального параметра `х` было изменено в методе `Func`, но эти изменения не отразились на фактическом параметре а метода `Main`.

При передаче **параметров по ссылке** метод получает копии адресов параметров, что позволяет осуществлять доступ к ячейкам памяти по этим адресам и изменять исходные значения параметров. Для того чтобы параметр передавался по ссылке, необходимо при описании метода перед формальным параметром и при вызове метода перед соответствующим фактическим параметром поставить служебное слово `ref`.
```c#
class Program
  {
     static void Func(int x, ref int y)
     {
       x += 10; y += 10;  //изменение параметров
       Console.WriteLine("In Func: {0}, {1}", x, y);
      }

     static void Main()
     {
        int a=10, b=10;  // строка 1
        Console.WriteLine("In Main: {0}, {1}", a, b);
        Func(a, ref b);
        Console.WriteLine("In Main: {0}, {1}", a, b);
      }
  }
```
Результат работы программы:
```
In Main: 10  10
In Func: 20  20
In Main: 10  20
```
В данном примере в методе `Func` были изменены значения формальных параметров `х` и `y`. Эти изменения не отразились на фактическом параметре `а`, т.к. он передавался по значению, но значение `b` было изменено, т.к. он передавался по ссылке.

Передача параметра по ссылке требует, чтобы аргумент был инициализирован до вызова метода (см. строку 1). Если в этой строке не проводить инициализацию переменных, то компилятор выдаст сообщение об ошибке.

Однако в некоторых случаях бывает невозможно инициализировать параметр до вызова метода. Тогда параметр следует передавать как **выходной**, используя спецификатор `out`.
```c#
class Program
  {
   static void Func(int x, out int y)
     {
       x += 10; y = 10;   // определение значения выходного параметра y
       Console.WriteLine("In Func: {0}, {1}", x, y);
      }

      static void Main()
      {
        int a=10, b;
        Console.WriteLine("In Main: {0}", a);
        Func(a, out b);
        Console.WriteLine("In Main: {0}, {1}", a, b);
      }
  }
```
Результат работы программы:
```
In Main: 10
In Func: 20  10
In Main: 10  10
```
В данном примере в методе `Func` формальный параметр `y` и соответствующий ему фактический параметр `b` метода `Main` были помечены спецификатором `out`. Поэтому значение `b` до вызова метода `Func` можно было не определять, но изменение параметра `y` отразились на изменении значения параметра `b`.

> **Замечание**. Параметры-массивы будут рассмотрены позже.

### Перегрузка методов
Иногда бывает удобно, чтобы методы, реализующие один и тот же алгоритм для различных типов данных, имели одно и то же имя. Использование нескольких методов с одним и тем же именем, но различными типами и количеством параметров называется **перегрузкой методов**. Компилятор определяет, какой именно метод требуется вызвать, по типу и количеству фактических параметров.

Рассмотрим следующий пример:
```c#
class Program
  {
     static int max(int a)	//первая версия метода max
      {
         int b = 0;
         while (a > 0)
         {
            if (a % 10 > b) b = a % 10;
            a /= 10;
          }
         return b;
      }

      static int max(int a, int b) //вторая версия метода max
       {
         if (a > b) return a;
         else return b;
       }

      static int max(int a, int b, int c) //третья версия метода max
      {
         if (a > b && a > c) return a;
         else if (b > c) return b;
         else return c;
      }

      static void Main()
      {
         int a = 1283, b = 45, c = 35740;
         Console.WriteLine(max(a));
         Console.WriteLine(max(a, b));
         Console.WriteLine(max(a, b, c));
      }
  }
```
При вызове метода `max` компилятор выбирает вариант, соответствующий типу и количеству передаваемых в метод аргументов. Если точного соответствия не найдено, выполняются неявные преобразования типов в соответствии с общими правилами. Если преобразование невозможно, выдается сообщение об ошибке. Если выбор перегруженного метода возможен более чем одним способом, то выбирается "лучший" из вариантов (вариант, содержащий меньшие количество и длину преобразований в соответствии с правилами преобразования типов). Если существует несколько вариантов, из которых невозможно выбрать лучший, выдается сообщение об ошибке.

*Перегрузка методов* является проявлением **полиморфизма**, одного из основных свойств ООП. Программисту гораздо удобнее помнить одно имя метода и использовать его для работы с различными типами данных, а решение о том, какой вариант метода вызвать, возложить на компилятор. Этот принцип широко используется в классах библиотеки .NET. Например, в стандартном классе `Console` метод `WriteLine` перегружен 19 раз для вывода величин разных типов.

## 22. Понятие массива. Объявление и инициализация одномерного массива в языке С#.
https://intuit.ru/studies/courses/486/342/lecture/8235

**Массив** — набор элементов одного и того же типа, объединенных общим именем. Массивы в С# можно использовать по аналогии с тем, как они используются в других языках программирования. Однако С#-массивы имеют существенные отличия: они относятся к ссылочным типам данных, более того — реализованы как объекты. Фактически имя массива является ссылкой на область кучи (динамической памяти), в которой последовательно размещается набор элементов определенного типа. Выделение памяти под элементы происходит на этапе инициализации массива. А за освобождением памяти следит система сборки мусора — неиспользуемые массивы автоматически утилизируются данной системой.

Рассмотрим различные типы массивов.

### Одномерные массивы
**Одномерный массив** — это фиксированное количество элементов одного и того же типа, объединенных общим именем, где каждый элемент имеет свой номер. Нумерация элементов массива в С# начинается с нуля, то есть, если массив состоит из 10 элементов, то его элементы будут иметь следующие номера: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9.

Одномерный массив в С# реализуется как объект, поэтому его создание представляет собой двухступенчатый процесс. Сначала объявляется ссылочная переменная на массив, затем выделяется память под требуемое количество элементов базового типа, и ссылочной переменной присваивается адрес нулевого элемента в массиве. Базовый тип определяет тип данных каждого элемента массива. Количество элементов, которые будут храниться в массиве, определяется размер массива.

В общем случае процесс объявления переменной типа массив, и выделение необходимого объема памяти может быть разделено. Кроме того на этапе объявления массива можно произвести его инициализацию. Поэтому для объявления одномерного массива может использоваться одна из следующих форм записи:

Форма записи |	Пояснения
-- | --
`базовый_тип [] имя__массива;`<br>*Например*:<br>`int [] a;` | Описана ссылка на одномерный массив, которая в дальнейшем может быть использована:<br>- для адресации на уже существующий массив;<br>- передачи массива в метод в качестве параметра;<br>- отсроченного выделения памяти под элементы массива.
`базовый_тип [] имя__массива = new базовый_тип [размер];`<br>*Например*:<br>`int []a=new int [10];` | Объявлен одномерный массив заданного типа и выделена память под одномерный массив указанной размерности. Адрес данной области памяти записан в ссылочную переменную. Элементы массива равны нулю.<br>**Замечание**. Надо отметить, что в C# элементам массива присваиваются начальные значения по умолчанию в зависимости от базового типа. Для арифметических типов — нули, для ссылочных типов — `null`, для символов — пробел.
`базовый_тип [] имя__массива={список инициализации};`<br>*Например*:<br>`int []a={0, 1, 2, 3};` | Выделена память под одномерный массив, размерность которого соответствует количеству элементов в списке инициализации. Адрес этой области памяти записан в ссылочную переменную. Значение элементов массива соответствует списку инициализации.

Обращения к элементам массива происходит с помощью индекса, для этого нужно указать имя массива и в квадратных скобках его номер. Например, `a[0]`, `b[10]`, `c[i]`.

Так как массив представляет собой набор элементов, объединенных общим именем, то обработка массива обычно производится в цикле. Рассмотрим несколько простых примеров работы с одномерными массивами.

**Пример 1**.
```c#
static void Main()
{
  int[] myArray = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
  int i;
  for (i = 0; i < 10; ++i)
  Console.WriteLine(myArray[i]);
}
```

> **Задание**. Измените программу так, чтобы числа выводились в строчку.

<details>
<summary><b>Решение</b></summary>

*Program*:
```c#
int[] myArray = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
Console.WriteLine(string.Join(", ", myArray));
```
*Output*:
```
0, 1, 2, 3, 4, 5, 6, 7, 8, 9
```

</details>

Хотя при инициализации массива нет необходимости использовать операцию `new`, все же массив можно инициализировать следующим образом:
```c#
int [ ] myArray = new int [ ] { 99, 10, 100, 18, 78, 23, 163, 9, 87, 49 };
```
Несмотря на избыточность, данная форма инициализации массива может оказаться полезной в том случае, когда уже существующей ссылке на одномерный массив присваивается ссылка на новый массив. Например:
```c#
static void Main()
{
  int[] myArray = { 0, 1, 2, 3, 4, 5};
  int i;
  for (i = 0; i < 6; i++)
  Console.Write(" "+myArray[i]);
  Console.WriteLine("\nНовый массив: ");
  myArray = new int[] { 99, 10, 100, 18, 78, 23, 163, 9, 87, 49 }; // 1
  for (i = 0; i < 10; i++)
  Console.Write(" " + myArray[i]);
}
```
Следует отметить, что первоначально переменная `myArray` ссылалась на 6-ти элементный массив. В строке 1 переменной `myArray` была присвоена ссылка на новый 10-элементный массив, в результате чего исходный массив оказался неиспользуемым, т.к. на него теперь не ссылается ни один объект. Поэтому он автоматически будет удален сборщиком мусора.

### Массивы и исключения
Выход за границы массива в C# расценивается как ошибка, в ответ на которую генерируется исключение — `IndexOutOfRangeException`.

Рассмотрим следующий пример:
```c#
static void Main()
{
  int[] myArray = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
  int i;
  try
  {
    for (i = 0; i <= 10; i++) Console.WriteLine(myArray[i]);
  }
  catch (IndexOutOfRangeException)
  {
    Console.WriteLine("Exception: Выход за границу диапазона");
  }
}
```

> **Задание**. Добавьте в программу обработчики исключений `FormatException` и `OutOfMemoryException`. Вспомните, что они контролируют.

<details>
<summary><b>Решение</b></summary>

```c#
static void Main(string[] args)
{
    int[] myArray = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
    int i;
    try
    {
        for (i = 0; i <= 10; i++) Console.WriteLine(myArray[i]);
    }
    catch (IndexOutOfRangeException)
    {
        Console.WriteLine("Exception: Выход за границу диапазона");
    }
    catch (FormatException)
    {
        Console.WriteLine("Exception: Попытка передать в метод аргумент неверного формата");
    }
    catch (OutOfMemoryException)
    {
        Console.WriteLine("Exception: Недостаточно памяти для нового объекта");
    }
}
```

</details>

### Массив как параметр
Так как имя массива фактически является ссылкой, то он передается в метод по ссылке и, следовательно, все изменения элементов массива, являющегося формальным параметром, отразятся на элементах соответствующего массива, являющимся фактическим параметром.

Рассмотрим пример передачи массива как параметра:
```c#
class Program
{
  static void Print(int n, int[] a) //n - размерность массива, а - ссылка на массив
  {
    for (int i = 0; i < n; i++) Console.Write("{0} ", a[i]);
    Console.WriteLine();
  }

  static void Change(int n, int[] a)
  {
    for (int i = 0; i < n; i++)
    if (a[i] > 0) a[i] = 0; // изменяются элементы массива
  }

  static void Main()
  {
    int[] myArray = { 0, -1, -2, 3, 4, 5, -6, -7, 8, -9 };
    Print(10, myArray);
    Change(10, myArray);
    Print(10, myArray);
  }
}
```

> **Задание**. Измените программу так, чтобы метод `Change` удваивал значения положительных элементов массива.

<details>
<summary><b>Решение</b></summary>

```c#
class Program
{
  static void Print(int n, int[] a) //n - размерность массива, а - ссылка на массив
  {
    for (int i = 0; i < n; i++) Console.Write("{0} ", a[i]);
    Console.WriteLine();
  }

  static void Change(int n, int[] a)
  {
    for (int i = 0; i < n; i++)
    if (a[i] > 0) a[i] *= 2; // изменяются элементы массива
  }

  static void Main()
  {
    int[] myArray = { 0, -1, -2, 3, 4, 5, -6, -7, 8, -9 };
    Print(10, myArray);
    Change(10, myArray);
    Print(10, myArray);
  }
}
```

</details>

### Массив как объект
Мы уже говорили о том, что массивы в С# реализованы как объекты. Если говорить более точно, то они реализованы на основе базового класса `Array`, определенного в пространстве имен `System`. Данный класс содержит различные свойства и методы. Например, свойство `Length` позволяет определять количество элементов в массиве. Преобразуем предыдущий пример:
```c#
class Program
{
  static void Print(int[] a) // передаем только ссылку на массив
  {
    for (int i = 0; i < a.Length; i++) Console.Write("{0} ", a[i]);
    Console.WriteLine();
  }

  static void Change(int[] a)
  {
    for (int i = 0; i < a.Length; i++)
    if (a[i] > 0) a[i] = 0;
  }

  static void Main()
  {
    int[] myArray = { 0, -1, -2, 3, 4, 5, -6, -7, 8, -9 };
    Print(myArray);
    Change(myArray);
    Print(myArray);
  }
}
```
Другие свойства и методы класса `Array` приведены в следующей таблице:

Элемент |	Вид |	Описание
-- | -- | --
`Length` |	свойство |	Количество элементов массива (по всем размерностям)
`BinarySearch` |	статический метод |	Двоичный поиск в отсортированном массиве
`Clear` |	статический метод |	Присваивание элементам массива значений по умолчанию
`Copy` |	статический метод |	Копирование заданного диапазона элементов одного массива в другой
`CopyTo` |	экземплярный метод |	Копирование всех элементов текущего одномерного массива в другой массив
`GetValue` |	экземплярный метод |	Получение значения элемента массива
`IndexOf` | статический метод |	Поиск первого вхождения элемента в одномерный массив
`LastIndexOf` |	статический метод |	Поиск последнего вхождения элемента в одномерный массив
`Reverse` |	статический метод |	Изменение порядка следования элементов на обратный
`SetValue` |	экземплярный метод |	Установка значения элемента массива
`Sort` |	статический метод |	Упорядочивание элементов одномерного массива

Вызов *статических методов* происходит через обращение к имени класса, например, `Array.Sort(myArray)`. В данном случае мы обращаемся к статическому методу `Sort` класса `Array` и передаем данному методу в качестве параметра объект `myArray` — экземпляр класса `Array`.

Обращение к *свойству* или вызов *экземплярного метода* производится через обращение к экземпляру класса, например, `myArray.Length` или `myArray.GetValue(i)`.

**Пример**:
```c#
class Program
{
  static void Main()
  {
    try
    {
      int[] MyArray;
      Console.Write("Введите размерность массива: ");
      int n = int.Parse(Console.ReadLine());
      MyArray = new int[n];
      for (int i = 0; i < MyArray.Length; ++i)
      {
        Console.Write("a[{0}]=",i);
        MyArray[i] = int.Parse(Console.ReadLine());
      }
      PrintArray("исходный массив:", MyArray);
      Array.Sort(MyArray);
      PrintArray("массив отсортирован по возрастанию", MyArray);
      Array.Reverse(MyArray);
      PrintArray("массив отсортирован по убыванию", MyArray);
    }
    catch (FormatException)
    {
      Console.WriteLine("неверный формат ввода данных");
    }
    catch (OverflowException)
    {
      Console.WriteLine("переполнение");
    }
    catch (OutOfMemoryException)
    {
      Console.WriteLine("недостаточно памяти для создания нового объекта");
    }
  }

  static void PrintArray(string a, int[] mas)
  {
    Console.WriteLine(a);
    for (int i = 0; i < mas.Length; i++) Console.Write("{0} ", mas[i]);
    Console.WriteLine();
  }
}

```

> **Задание**. Добавьте в программу метод `InputArray`, предназначенный для ввода с клавиатуры элементов массива. Продемонстрируйте работу данного метода.

<details>
<summary><b>Решение</b></summary>

```c#
internal class Program
{
    static void Main()
    {
        try
        {
            int[] MyArray;
            Console.Write("Введите размерность массива: ");
            int n = int.Parse(Console.ReadLine());
            MyArray = new int[n];

            InputArray(MyArray);
            PrintArray("исходный массив:", MyArray);
            Array.Sort(MyArray);
            PrintArray("массив отсортирован по возрастанию", MyArray);
            Array.Reverse(MyArray);
            PrintArray("массив отсортирован по убыванию", MyArray);
        }
        catch (FormatException)
        {
            Console.WriteLine("неверный формат ввода данных");
        }
        catch (OverflowException)
        {
            Console.WriteLine("переполнение");
        }
        catch (OutOfMemoryException)
        {
            Console.WriteLine("недостаточно памяти для создания нового объекта");
        }
    }

    static void PrintArray(string a, int[] mas)
    {
        Console.WriteLine(a);
        for (int i = 0; i < mas.Length; i++) Console.Write("{0} ", mas[i]);
        Console.WriteLine();
    }
    static void InputArray(int[] arr)
    {
        for (int i = 0; i < arr.Length; ++i)
        {
            Console.Write("a[{0}]=", i);
            arr[i] = int.Parse(Console.ReadLine());
        }
    }
}

```

</details>

## 23. Понятие массива. Объявление и инициализация многомерного массива в языке С#.
https://intuit.ru/studies/courses/486/342/lecture/8235?page=2

**Массив** — набор элементов одного и того же типа, объединенных общим именем. Массивы в С# можно использовать по аналогии с тем, как они используются в других языках программирования. Однако С#-массивы имеют существенные отличия: они относятся к ссылочным типам данных, более того — реализованы как объекты. Фактически имя массива является ссылкой на область кучи (динамической памяти), в которой последовательно размещается набор элементов определенного типа. Выделение памяти под элементы происходит на этапе инициализации массива. А за освобождением памяти следит система сборки мусора — неиспользуемые массивы автоматически утилизируются данной системой.

### Многомерные массивы
Многомерные массивы имеют более одного измерения. Чаще всего используются двумерные массивы, которые представляют собой таблицы. Каждый элемент массива имеет два индекса, первый определяет номер строки, второй — номер столбца, на пересечении которых находится элемент. Нумерация строк и столбцов начинается с нуля.

Объявить двумерный массив можно одним из предложенных способов:
```c#
тип [,] имя__массива;
тип [,] имя__массива = new тип [размер1, размер2];
тип [,] имя__массива={{элементы 1-ой строки}, … , {элементы n-ой строки}};
тип [,] имя__массива= new тип [,]{{элементы 1-ой строки}, … ,{элементы n-ой строки}};
```

Например:
```c#
int [,] a;
int [,] a= new int [3, 4];
int [,] a={{0, 1, 2}, {3, 4, 5}};
int [,] a= new int [,]{{0, 1, 2}, {3, 4, 5}};
```

**Замечания**.
1. Как и в случае с одномерными массивами, последние два описания являются избыточными.
2. При работе с многомерными массивами можно использовать приемы, которые мы рассмотрели для одномерных массивов.
3. При обращении к свойству `Length` для двумерного массива мы получим общее количество элементов в массиве. Чтобы получить количество строк нужно обратиться к методу `GetLength` с параметром `0`. Чтобы получить количество столбцов — к методу `GetLength` с параметром `1`.

**Пример**:
```c#
class Program
  {
    static void PrintArray(string a, int[,] mas)
    {
      Console.WriteLine(a);
      for (int i = 0; i < mas.GetLength(0); i++)
      {
        for (int j = 0; j < mas.GetLength(1); j++)
          Console.Write("{0} ", mas[i, j]);
        Console.WriteLine();
      }
    }

    static void Change(int[,] mas)
    {
      for (int i = 0; i < mas.GetLength(0); i++)
        for (int j = 0; j < mas.GetLength(1); j++)
          if (mas[i, j] % 2 == 0) mas[i, j] = 0;
    }

    static void Main()
    {
      try
      {
        int[,] MyArray ={ { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } };
        PrintArray("исходный массив:", MyArray);
        Change(MyArray);
        PrintArray("итоговый массив", MyArray);
      }
      catch (FormatException)
      {
            Console.WriteLine("неверный формат ввода данных");
      }
      catch (OverflowException)
      {
            Console.WriteLine("переполнение");
      }
      catch (OutOfMemoryException)
      {
            Console.WriteLine("недостаточно памяти для создания нового объекта");
      }
    }
  }
```
> **Задания**.
>
> 1. Добавьте в программу метод `InputArray`, предназначенный для ввода с клавиатуры элементов массива. Продемонстрируйте работу данного метода.
> 2. Измените метод `Change` так, чтобы он вычислял сумму четных элементов двумерного массива.

<details>
<summary><b>Решение</b></summary>

```c#
internal class Program
{
    static void PrintArray(string a, int[,] mas)
    {
        Console.WriteLine(a);
        for (int i = 0; i < mas.GetLength(0); i++)
        {
            for (int j = 0; j < mas.GetLength(1); j++)
                Console.Write("{0} ", mas[i, j]);
            Console.WriteLine();
        }
    }

    static int Change(int[,] mas)
    {
        int sum = 0;
        for (int i = 0; i < mas.GetLength(0); i++)
            for (int j = 0; j < mas.GetLength(1); j++)
                if (mas[i, j] % 2 == 0) sum += mas[i, j];
        return sum;
    }
    static void InputArray(int[,] arr)
    {
        for (int i = 0; i < arr.GetLength(0); i++)
        {
            for (int j = 0;j < arr.GetLength(1); j++)
            {
                Console.Write("a[{0}, {1}]=", i, j);
                arr[i, j] = int.Parse(Console.ReadLine());
            }
        }
    }

    static void Main()
    {
        try
        {
            int[,] MyArray;

            Console.WriteLine("Введите размерность массива: ");
            int[] size = { int.Parse(Console.ReadLine()), int.Parse(Console.ReadLine()) };
            MyArray = new int[size[0], size[1]];

            InputArray(MyArray);

            PrintArray("исходный массив:", MyArray);
            int sum = Change(MyArray);
            Console.WriteLine("Сумма чётных элементов массива: " + sum);
            PrintArray("итоговый массив", MyArray);
        }
        catch (FormatException)
        {
            Console.WriteLine("неверный формат ввода данных");
        }
        catch (OverflowException)
        {
            Console.WriteLine("переполнение");
        }
        catch (OutOfMemoryException)
        {
            Console.WriteLine("недостаточно памяти для создания нового объекта");
        }
    }
}

```

</details>

### Ступенчатые массивы
В ступенчатых массивах количество элементов в разных строках может быть различным. В памяти ступенчатый массив хранится в виде массива массивов. Структура ступенчатого массива:

| | | | | |
-- | -- | -- | -- | --
a[0] | | a[0][0] | a[0][1] | …
a[1] | | | | |
… | | a[1][0] |	a[1][1] |	…
a[n] | | | | |
| | | a[n][0] | a[n][1] |	…


Объявление ступенчатого массива:
```c#
тип [][] имя_массива;
```
Например:
```c#
int [][]a;
```
Фактически мы объявили одномерный массив ссылок на целочисленные одномерные массивы. При таком описании потребуется не только выделять память под одномерный массив ссылок, но и под каждый из целочисленных одномерных массивов. Такое распределение памяти позволяет определять произвольную длину каждой строки массива (отсюда и произошло название массива — ступенчатый). Например:
```c#
int [][] a= new int [3][];  // Создаем три строки
a[0]=new int [2];  // 0-ая строка ссылается на 2-х элементый одномерный массив
a[1]=new int [3];  // 1-ая строка ссылается на 3-х элементый одномерный массив
a[2]=new int [10];  // 2-ая строка ссылается на 10-ти элементый одномерный массив
```
Другой способ выделения памяти:
```c#
int [][] a= {new int [2], new int [3], new int [10]};
```
Так как каждая строка ступенчатого массива фактически является одномерным массивом, то с каждой строкой можно работать как с экземпляром класса `Array`. Это является преимуществом ступенчатых массивов перед двумерными массивами.

Пример:
```c#
class Program
{
  static void Main()
  {
    try
    {
      int[][] MyArray;
      Console.Write("Ввведите количество строк: ");
      int n = int.Parse(Console.ReadLine());
      MyArray = new int[n][];
      for (int i = 0; i < MyArray.Length; i++)
      {
        Console.Write("введите количество элементов в {0} строке: ", i);
        int j = int.Parse(Console.ReadLine());
        MyArray[i] = new int[j];
        for (j = 0; j < MyArray[i].Length; j++)
        {
          Console.Write("a[{0}][{1}]= ", i, j);
          MyArray[i][j] = int.Parse(Console.ReadLine());
        }
      }
      PrintArray("исходный массив:", MyArray);
      for (int i = 0; i < MyArray.Length; i++) Array.Sort(MyArray[i]);
      PrintArray("измененный массив", MyArray);
    }
    catch (FormatException)
    {
      Console.WriteLine("неверный формат ввода данных");
    }
    catch (OverflowException)
    {
      Console.WriteLine("переполнение");
    }
    catch (OutOfMemoryException)
    {
      Console.WriteLine("недостаточно памяти для создания нового объекта");
    }
  }

  static void PrintArray(string a, int[][] mas)
  {
    Console.WriteLine(a);
    for (int i = 0; i < mas.Length; i++)
    {
      for (int j = 0; j < mas[i].Length; j++) Console.Write("{0} ", mas[i][j]);
      Console.WriteLine();
    }
  }
}
```
> **Задание**. Добавьте в программу метод `MakeArray`, предназначенный для создания ступенчатого массива, в котором количество элементов в каждой строке больше номера строки в два раза. А сам элемент равен сумме номеров строки и столбца, в котором он находится. Продемонстрируйте работу данного метода.

<details>
<summary><b>Решение</b></summary>

```c#
internal class Program
{
    static void Main()
    {
        try
        {
            int[][] MyArray;
            Console.Write("Ввведите количество строк: ");
            int n = int.Parse(Console.ReadLine());
            MyArray = new int[n][];
            for (int i = 0; i < MyArray.Length; i++)
            {
                Console.Write("введите количество элементов в {0} строке: ", i);
                int j = int.Parse(Console.ReadLine());
                MyArray[i] = new int[j];
                for (j = 0; j < MyArray[i].Length; j++)
                {
                    Console.Write("a[{0}][{1}]= ", i, j);
                    MyArray[i][j] = int.Parse(Console.ReadLine());
                }
            }
            PrintArray("исходный массив:", MyArray);
            for (int i = 0; i < MyArray.Length; i++) Array.Sort(MyArray[i]);
            PrintArray("измененный массив", MyArray);

            // Method use and results
            int[][] madeArray = MakeArray(n);
            PrintArray("сгенерированный массив:", madeArray);
        }
        catch (FormatException)
        {
            Console.WriteLine("неверный формат ввода данных");
        }
        catch (OverflowException)
        {
            Console.WriteLine("переполнение");
        }
        catch (OutOfMemoryException)
        {
            Console.WriteLine("недостаточно памяти для создания нового объекта");
        }
    }

    static void PrintArray(string a, int[][] mas)
    {
        Console.WriteLine(a);
        for (int i = 0; i < mas.Length; i++)
        {
            for (int j = 0; j < mas[i].Length; j++) Console.Write("{0} ", mas[i][j]);
            Console.WriteLine();
        }
    }

    // New method
    static int[][] MakeArray(int n)
    {
        int[][] arr = new int[n][];
        for (int i = 0; i < arr.Length; i++)
        {
            arr[i] = new int[i*2];
            for (int j = 0; j < arr[i].Length; j++)
            {
                arr[i][j] = i + j;
            }
        }
        return arr;
    }
}

```

</details>

### Оператор `foreach` и его использование при работе с массивами
Оператор `foreach` применяется для перебора элементов в специальным образом организованной группе данных, в том числе и в массиве. Удобство этого вида цикла заключается в том, что нам не требуется определять количество элементов в группе и выполнять перебор по индексу - мы просто указываем на необходимость перебрать все элементы группы. Синтаксис оператора:
```c#
foreach (<тип> <имя> in <группа>) <тело цикла>
```
где *имя* определяет локальную по отношению к циклу переменную, которая будет по очереди принимать все значения из указанной *группы*, а *тип* соответствует базовому типу элементов *группы*.

Ограничением оператора `foreach` является то, что с его помощью можно только просматривать значения элементов в группе данных, но нельзя их изменять.

Рассмотрим несколько примеров использования оператора `foreach`:

1. для работы с одномерными массивами:
```c#
static void PrintArray(string a, int [] mas)
{
  Console.WriteLine(a);
  foreach (int x in mas)Console.Write("{0} ", x);
  Console.WriteLine();
}
```

2. для работы с двумерными массивами:
```c#
static int Sum (int [,] mas)
{
  int s=0;
  foreach (int x in mas) s += x;
  return s;
}

3. для работы со ступенчатыми массивами:
```c#
static void PrintArray3(string a, int[][] mas)
{
  Console.WriteLine(a);
  for (int i = 0; i < mas.Length; i++)
  {
    foreach (int x in mas[i]) Console.Write("{0} ", x);
    Console.WriteLine();
  }
}
```

## 24. Строки в языке С#. Функции для работы со строками.
https://intuit.ru/studies/courses/486/342/lecture/8236

Обработка текстовой информации является одной из самых распространенных задач современного программировании. С# предоставляет для ее решения широкий набор средств: символы `char`, неизменяемые строки `string`, изменяемые строки `StringBuider` и регулярные выражения `Regex`. В данном разделе мы рассмотрим работу с символами, неизменяемыми и изменяемыми строками.

### Символы `char`
Символьный тип `char` предназначен для хранения символа в кодировке Unicode. Символьный тип относится к встроенным типам данных С# и соответствует стандартному классу `Сhar` библиотеки .Net из пространства имен `System`. В этом классе определены статические методы, позволяющие задавать вид и категорию символа, а также преобразовывать символ в верхний или нижний регистр, в число. Рассмотрим основные методы:

Метод |	Описание
-- | --
`GetNumericValue` |	Возвращает числовое значение символа, если он является цифрой, и `-1` в противном случае.
`GetUnicodeCategory` |	Возвращает категорию Unicode-символа. В Unicode символы разделены на категории, например цифры (`DecimalDigitNumber`), римские цифры (`LetterNumber`), разделители строк (`LineSeparator`), буквы в нижнем регистре (`LowercaseLetter`) и т.д.
`IsControl` |	Возвращает `true`, если символ является управляющим.
`IsDigit` |	Возвращает `true`, если символ является десятичной цифрой.
`IsLetter` |	Возвращает `true`, если символ является буквой.
`IsLetterOrDigit` |	Возвращает `true`, если символ является буквой или десятичной цифрой.
`IsLower` |	Возвращает `true`, если символ задан в нижнем регистре.
`IsNumber` |	Возвращает `true`, если символ является числом (десятичным или шестнадцатеричным).
`IsPunctuation` |	Возвращает `true`, если символ является знаком препинания.
`IsSeparator` |	Возвращает `true`, если символ является разделителем.
`IsUpper` |	Возвращает `true`, если символ задан в верхнем регистре.
`IsWhiteSpace` |	Возвращает `true`, если символ является пробельным (пробел, перевод строки, возврат каретки).
`Parse` |	Преобразует строку в символ (строка должна состоять из одного символа).
`ToLower` |	Преобразует символ в нижний регистр
`ToUpper` |	Преобразует символ в верхний регистр

В следующем примере рассмотрим применение данных методов:
```c#
static void Main()
{
 try
 {
  char b = 'B', c = '\x64', d = '\uffff';
  Console.WriteLine("{0}, {1}, {2}", b, c, d);
  Console.WriteLine("{0}, {1}, {2}", char.ToLower(b), char.ToUpper(c), char.GetNumericValue(d));
  char a;
  do	//цикл выполнятеся до тех пор, пока не ввели символ e
  {
   Console.WriteLine("Введите символ: ");
   a = char.Parse(Console.ReadLine());
   Console.WriteLine("Введен символ {0}, его код  {1}, его категория {2}", a,
                      (int)a, char.GetUnicodeCategory(a));
   if (char.IsLetter(a)) Console.WriteLine("Буква");
   if (char.IsUpper(a)) Console.WriteLine("Верхний регистр");
   if (char.IsLower(a)) Console.WriteLine("Нижний регистр");
   if (char.IsControl(a)) Console.WriteLine("Управляющий символ");
   if (char.IsNumber(a)) Console.WriteLine("Число");
   if (char.IsPunctuation(a)) Console.WriteLine("Разделитель");
  } while (a != 'e');
 }
 catch
 {
  Console.WriteLine("Возникло исключение");
 }
}
```
Используя символьный тип можно оргранизовать массив символов и работать с ним на основе базового класса `Array`:
```c#
static void Main()
{
 char[] a ={ 'm', 'a', 'Х',  'i', 'M', 'u', 'S' , '!', '!', '!' };
 char [] b="кол около колокола".ToCharArray(); //преобразование строки в массив символов
 PrintArray("Исходный массив а:", a);
 for (int x=0;x<a.Length; x++)
 if (char.IsLower(a[x])) a[x]=char.ToUpper(a[x]);
 PrintArray("Измененный массив а:", a);
 PrintArray("Исходный массив b:", b);
 Array.Reverse(b);
 PrintArray("Измененный массив b:", b);
}

static void PrintArray(string line, Array a)
{
 Console.WriteLine(line);
 foreach( object x in a) Console.Write(x);
 Console.WriteLine('\n');
}
```

> **Задание**. Измените программу так, чтобы в ней подсчитывалось количество знаков пунктуации в массиве `a`.

<details>
<summary><b>Решение</b></summary>

```c#
static void Main()
{
    char[] a = { 'm', 'a', 'Х', 'i', 'M', 'u', 'S', '!', '!', '!' };
    char[] b = "кол около колокола".ToCharArray(); //преобразование строки в массив символов
    PrintArray("Исходный массив а:", a);

    int count = 0; // accumulator
    for (int x = 0; x < a.Length; x++)
    {
        if (char.IsLower(a[x])) a[x] = char.ToUpper(a[x]);
        // Count punctuation symbols
        if (char.IsPunctuation(a[x])) count++;
    }
    PrintArray("Измененный массив а:", a);
    // Print result
    Console.WriteLine("Количество знаков пунктуации: " + count);

    PrintArray("Исходный массив b:", b);
    Array.Reverse(b);
    PrintArray("Измененный массив b:", b);
}

static void PrintArray(string line, Array a)
{
    Console.WriteLine(line);
    foreach (object x in a) Console.Write(x);
    Console.WriteLine('\n');
}

```

</details>

### Неизменяемые строки `string`
Тип `string`, предназначенный для работы со строками символов в кодировке Unicode, является встроенным типом С#. Ему соответствует базовый тип класса `System.String` библиотеки .Net. Каждый объект `string` — это неизменяемая последовательность символов Unicode, т.е. методы, предназначенные для изменения строк, возвращают измененные копии, исходные же строки остаются неизменными.

Создать строку можно несколькими способами.

1. Отложенная инициализация:
    ```c#
    string s;
    ```

2. Инициализация строковым литералом:
    ```c#
    string s="кол около колокола";
    ```

3. Cимвол `@` сообщает конструктору `string`, что строку нужно воспринимать буквально, даже если она занимает несколько строк:
    ```c#
    string s = @"Привет!
    Сегодня хорошая погода!!!
    ";
    ```

4. Конструктор создает строку из нужного количества одинаковых символов:
    ```c#
    string s=new string (' ', 20);
    ```

5. Преобразование переменной другого типа к типу `string`:
    ```c#
    int x = 12344556;         //инициализировали целочисленную переменную
    string s = x.ToString();  //преобразовали ее к типу string
    ```


6. Создание строки из массива символов:
    ```c#
    char [] a={'a', 'b', 'c', 'd', 'e'};	//создали массив символов
    string v=new string (a);		          // создание строки из массива символов
    ```

7. Создание строки из части массива символов:
    ```c#
    char [] a={'a', 'b', 'c', 'd', 'e'};
    // создание строки из части массива символов, при этом: 0
    string v=new string (a, 0, 2)
    // показывает с какого символа, 2 - сколько символов
    // использовать для инициализации
    ```

Класс `string` обладает богатым набором методов для сравнения строк, поиска в строке и других действий со строками. Рассмотрим эти методы.

Название |	Вид |	Описание
-- | -- | --
`Compare` |	Статический метод |	Сравнение двух строк в лексикографическом (алфавитном) порядке. Разные реализации метода позволяют сравнивать строки с учетом или без учета регистра.
`CompareTo` |	Метод	| Сравнение текущего экземпляра строки с другой строкой.
`Concat` |	Статический метод |	Слияние произвольного числа строк.
`Copy` |	Статический метод |	Создание копии строки
`Empty` |	Статическое поле |	Открытое статическое поле, представляющее пустую строку
`Format` |	Статический метод |	Форматирование строки в соответствии с заданным форматом
`IndexOf`, `IndexOfAny`, `LastIndexOf`, `LastIndexOfAny` |	Экземплярные методы	|Определение индексов первого и последнего вхождения заданной подстроки или любого символа из заданного набора в данную строку.
`Insert` |	Экземплярный метод |	Вставка подстроки в заданную позицию
`Join` |	Статический метод |	Слияние массива строк в единую строку. Между элементами массива вставляются разделители.
`Length` |	Свойство |	Возвращает длину строки
`PadLeft`, `PadRigth` |	Экземплярные методы |	Выравнивают строки по левому или правому краю путем вставки нужного числа пробелов в начале или в конце строки.
`Remove` |	Экземплярный метод |	Удаление подстроки из заданной позиции
`Replace` |	Экземплярный метод |	Замена всех вхождений заданной подстроки или символа новыми подстрокой или символом.
`Split` |	Экземплярный метод |	Разделяет строку на элементы, используя разные разделители. Результаты помещаются в массив строк.
`StartWith`, `EndWith` |	Экземплярные методы |	Возвращают `true` или `false` в зависимости от того, начинается или заканчивается строка заданной подстрокой.
`Substring` |	Экземплярный метод |	Выделение подстроки, начиная с заданной позиции
`ToCharArray` |	Экземплярный метод |	Преобразует строку в массив символов
`ToLower`, `ToUpper` |	Экземплярные методы |	Преобразование строки к нижнему или верхнему регистру
`Trim`, `TrimStart`, `TrimEnd` |	Экземплярные методы |	Удаление пробелов в начале и конце строки или только с одного ее конца.

Напоминаем, что вызов статических методов происходит через обращение к имени класса, например, `String.Concat(str1, str2)`, в остальных случаях через обращение к экземплярам класса, например, `str.ToLower()`. На примере рассмотрим использование данных свойств и методов.
```c#
static void Main()
{
 string str1 ="Первая строка";
 string str2 = string.Copy(str1);
 string str3 = "Вторая строка";
 string str4 = "ВТОРАЯ строка";
 string strUp, strLow;
 int result, idx;
 Console.WriteLine("str1: " + str1);
 Console.WriteLine("Длина строки str1: " +str1.Length);

 // Создаем прописную и строчную версии строки str1.
 strLow = str1.ToLower();
 strUp = str1.ToUpper();
 Console.WriteLine("Строчная версия строки str1: " +strLow);
 Console.WriteLine("Прописная версия строки str1: " +strUp);
 Console.WriteLine();

 // Сравниваем строки,
 result = str1.CompareTo(str3);
 if (result == 0) Console.WriteLine("str1 и str3 равны.");
 else if (result < 0) Console.WriteLine("str1 меньше, чем str3");
 else Console.WriteLine("str1 больше, чем str3");
 Console.WriteLine();

 //сравниваем строки без учета регистра
 result = String.Compare(str3,str4,true);
 if (result == 0) Console.WriteLine("str3 и str4 равны без учета регистра.");
 else Console.WriteLine("str3 и str4 не равны без учета регистра.");
 Console.WriteLine();

 //сравниваем части строк
 result = String.Compare(str1, 4, str2, 4, 2);
 if (result == 0)  Console.WriteLine("часть str1 и str2 равны");
 else  Console.WriteLine("часть str1 и str2 не равны");
 Console.WriteLine();

 // Поиск строк.
 idx = str2.IndexOf("строка");
 Console.WriteLine("Индекс первого вхождения подстроки строка: " + idx);
 idx = str2.LastIndexOf("о");
 Console.WriteLine("Индекс последнего вхождения символа о: " + idx);

 //конкатенация
 string str=String.Concat(str1, str2, str3, str4);
 Console.WriteLine(str);

 //удаление подстроки
 str=str.Remove(0,str1.Length);
 Console.WriteLine(str);

 //замена подстроки "строка" на пустую подстроку
 str=str.Replace("строка","");
 Console.WriteLine(str);
}
```
Очень важными методами обработки строк, являются методы разделения строки на элементы `Split` и слияние массива строк в единую строку `Join`.

```c#
static void Main()
{
 string poems = "тучки небесные вечные странники";
 char[] div = { ' '}; //создаем массив разделителей
 // Разбиваем строку на части,
 string[] parts = poems.Split(div);
 Console.WriteLine("Результат разбиения строки на части: ");
 for (int i = 0; i < parts.Length; i++)
  Console.WriteLine(parts[i]);
 // Теперь собираем эти части в одну строку, в качестве разделителя используем символ |
 string whole = String.Join(" | ", parts);
 Console.WriteLine("Результат сборки: ");
 Console.WriteLine(whole);
}
```

> **Задание**. Измените программу так, чтобы слова в предложении записывались в обратном порядке.

<details>
<summary><b>Решение</b></summary>

```c#
static void Main()
{
    string poems = "тучки небесные вечные странники";
    char[] div = { ' ' }; //создаем массив разделителей
                          // Разбиваем строку на части,
    string[] parts = poems.Split(div);
    Console.WriteLine("Результат разбиения строки на части: ");
    // Iterate the array in reversed order
    for (int i = parts.GetUpperBound(0); i > -1; i--)
        Console.WriteLine(parts[i]);
    // Reverse array
    Array.Reverse(parts);
    // Теперь собираем эти части в одну строку, в качестве разделителя используем символ |
    string whole = String.Join(" | ", parts);
    Console.WriteLine("Результат сборки: ");
    Console.WriteLine(whole);
}

```

</details>

В общем случае строка может содержать и другие разделители:
```c#
static void Main()
{
 string poems = "Тучки небесные, вечные странники...";
 char[] div = { ' ', ',', '.'}; //создаем массив разделителей
 // Разбиваем строку на части,
 string[] parts = poems.Split(div);
 Console.WriteLine("Результат разбиения строки на части: ");
 for (int i = 0; i < parts.Length; i++)
 Console.WriteLine(parts[i]);
 // Теперь собираем эти части в одну строку,
 string whole = String.Join(" | ", parts);
 Console.WriteLine("Результат сборки: ");
 Console.WriteLine(whole);
}
```

> **Задания**.
> 1. Объясните, почему в массиве строк `parts` появились пустые строки.
> 2. Внесите изменения в программу так, чтобы пустых строк не было.

<details>
<summary><b>Ответы</b></summary>

1. Когда встречается два разделителя подряд, между которыми нет символов (как во фрагментах `"небесные, "` и `"странники..."`), ожидается, что метод вернет пустую строку.
2. В метод `Split` вторым аргументом следует добавить опцию `StringSplitOptions.RemoveEmptyEntries`:

    ```c#
    static void Main()
    {
        string poems = "Тучки небесные, вечные странники...";
        char[] div = { ' ', ',', '.' }; //создаем массив разделителей
                                        // Разбиваем строку на части,
        string[] parts = poems.Split(div, StringSplitOptions.RemoveEmptyEntries);
        Console.WriteLine("Результат разбиения строки на части: ");
        for (int i = 0; i < parts.Length; i++)
            Console.WriteLine(parts[i]);
        // Теперь собираем эти части в одну строку,
        string whole = String.Join(" | ", parts);
        Console.WriteLine("Результат сборки: ");
        Console.WriteLine(whole);
    }

    ```

</details>

Рассмотрим другой пример — используя метод `Split` вводить двумерный массив можно не поэлементно, а построчно:
```c#
static void Main()
{
 try
 {
  int[][] MyArray;
  Console.Write("введите количество строк: ");
  int n = int.Parse(Console.ReadLine());
  MyArray = new int[n][];
  for (int i = 0; i < MyArray.Length; i++)
  {
   string line = Console.ReadLine();
   string[] mas = line.Split(' ');
   MyArray[i] = new int[mas.Length];
   for (int j = 0; j < MyArray[i].Length; j++)
   {
    MyArray[i][j] = int.Parse(mas[j]);
   }
  }
  PrintArray("исходный массив:", MyArray);
  for (int i = 0; i < MyArray.Length; i++) Array.Sort(MyArray[i]);
  PrintArray("итоговый массив", MyArray);
 }
 catch
 {
  Console.WriteLine("возникло исключение");
 }
}

static void PrintArray(string a, int[][] mas)
{
 Console.WriteLine(a);
 for (int i = 0; i < mas.Length; i++)
 {
  foreach (int x in mas[i]) Console.Write("{0} ", x);
  Console.WriteLine();
 }
}
```
В этом примере могут возникнуть исключительные ситуации, если введенная строка элементов массива будет содержать лишние пробелы. Следовательно, от этих пробелов нужно избавиться:
```c#
static void Main()
{
 try
 {
  int[][] MyArray;
  Console.Write("введите количество строк: ");
  string line= Console.ReadLine();
  int n = int.Parse(line.Trim());
  MyArray = new int[n][];
  for (int i = 0; i < MyArray.Length; i++)
  {
   line = Console.ReadLine();
   line=line.Trim();	//удалаяем пробелы в начале и конце строки
   //удаляем лишние пробелы внутри строки
   n = line.IndexOf("  ");
   while (n > 0)
   {
    line = line.Remove(n, 1);
    n = line.IndexOf("  ");
   }
   string[] mas = line.Split(' ');
   MyArray[i] = new int[mas.Length];
   for (int j = 0; j < MyArray[i].Length; j++)
   {
    MyArray[i][j] = int.Parse(mas[j]);
   }
  }
  PrintArray("исходный массив:", MyArray);
  for (int i = 0; i < MyArray.Length; i++) Array.Sort(MyArray[i]);
  PrintArray("итоговый массив", MyArray);
 }
 catch
 {
  Console.WriteLine("возникло исключение");
 }
}

static void PrintArray(string a, int[][] mas)
{
 Console.WriteLine(a);
 for (int i = 0; i < mas.Length; i++)
 {
  foreach (int x in mas[i]) Console.Write("{0} ", x);
  Console.WriteLine();
 }
}
```

> **Задание**. Объясните, можно ли удалить внутри строки лишние пробелы, используя метод `Replace`. Например, следующим способом `str.Replace("  ", " ")`, где мы пытаемся заменить подстроку состоящую из двух, на подстроку из одиного пробела.

<details>
<summary><b>Ответы</b></summary>

Это возможно, но для замены любого количество пробелов также будет необходимо многократное последовательное применение метода `str.Replace("  ", " ")`, поскольку в данном виде метод удаляет только двойные (а не тройные и т.д.) пробелы.

https://learn.microsoft.com/ru-ru/dotnet/api/system.string.replace?view=net-8.0#system-string-replace(system-string-system-string)

```c#
static void Main()
{
    try
    {
        int[][] MyArray;
        Console.Write("введите количество строк: ");
        string line = Console.ReadLine();
        int n = int.Parse(line.Trim());
        MyArray = new int[n][];
        for (int i = 0; i < MyArray.Length; i++)
        {
            line = Console.ReadLine();
            line = line.Trim(); //удалаяем пробелы в начале и конце строки
            //удаляем лишние пробелы внутри строки
            n = line.IndexOf("  ");
            while (n > 0)
            {
                // Remove double spaces
                line = line.Replace("  ", " ");
                n = line.IndexOf("  ");
            }
            string[] mas = line.Split(' ');
            MyArray[i] = new int[mas.Length];
            for (int j = 0; j < MyArray[i].Length; j++)
            {
                MyArray[i][j] = int.Parse(mas[j]);
            }
        }
        PrintArray("исходный массив:", MyArray);
        for (int i = 0; i < MyArray.Length; i++) Array.Sort(MyArray[i]);
        PrintArray("итоговый массив", MyArray);
    }
    catch(Exception e)
    {
        Console.WriteLine("возникло исключение" + e);
    }
}

static void PrintArray(string a, int[][] mas)
{
    Console.WriteLine(a);
    for (int i = 0; i < mas.Length; i++)
    {
        foreach (int x in mas[i]) Console.Write("{0} ", x);
        Console.WriteLine();
    }
}

```

</details>

При работе с объектами класса `string` нужно учитывать их свойство неизменяемости, т.е. тот факт, что методы изменяют не сами строки, а их копии. Рассмотрим фрагмент программы:
```c#
string a="";
 for (int i = 1; i <= 100; i++) a +="!";
 Console.WriteLine(a);
```
В этом случае в памяти компьютера будет сформировано 100 различных строк вида:
```
!
!!
!!!
…
!!!...!!
```
И только последняя строка будет храниться в переменной `а`. Ссылки на все остальные строчки будут потеряны, но эти строки будут храниться в памяти компьютера и засорять память. Бороться с таким засорением придется сборщику мусора, что будет сказываться на производительности программы. Поэтому если нужно изменять строку, то лучше пользоваться классом `StringBuilder`.

### Изменяемые строки
https://intuit.ru/studies/courses/486/342/lecture/8236?page=2

Чтобы создать строку, которую можно изменять, в С# предусмотрен класс `StringBuilder`, определенный в пространстве имен `System.Text`. Объекты этого класса всегда объявляются с явным вызовом конструктора класса (через операцию `new`) . Примеры создания изменяемых строк:
```c#
StringBuilder a =new StringBuilder();	//создание пустой строки, размер по умолчанию 16 символов
//инициализация строки и выделение необходимой памяти
StringBuilder b = new StringBuilder("abcd");
//создание пустой строки и выделение памяти под 100 символов
StringBuilder с = new StringBuilder(100);
//инициализация строки и выделение памяти под 100 символов
StringBuilder d = new StringBuilder("abcd", 100);
//инициализация подстрокой "bcd", и выделение памяти под 100 символов
StringBuilder d = new StringBuilder("abcd", 1, 3,100);
```
Основные элементы класса приведены в таблице:

Название |	Вид |	Описание
-- | -- | --
`Append` |	*Экземплярный метод* |	Добавление данных в конец строки. Разные варианты метода позволяют добавлять в строку величины любых встроенных типов, массивы символов, строки и подстроки `string`.
`AppendFormat` |	*Экземплярный метод* |	Добавление форматированной строки в конец строки
`Capacity` | 	свойство |	Получение и установка емкости буфера. Если устанавливаемое значение меньше текущей длины строки или больше максимального, то генерируется исключение `ArgumentOutOfRangeException`
`Insert` |	*Экземплярный метод* |	Вставка подстроки в заданную позицию
`Length` |	изменяемое свойство |	Возвращает длину строки. Присвоение ему значения `0` сбрасывает содержимое и очищает строку
`MaxCapacity` |	неизменное свойство |	Возвращает наибольшее количество символов, которое может быть размещено в строке
`Remove` |	*Экземплярный метод* |	Удаление подстроки из заданной позиции
`Replace`	| *Экземплярный метод* |	Замена всех вхождений заданной подстроки или символа новой подстрокой или символом
`ToString` |	*Экземплярный метод* |	Преобразование в строку типа `string`
`Chars` |	изменяемое свойство |	Возвращает из массива или устанавливает в массиве символ с заданным индексом. Вместо него можно пользоваться квадратными скобками `[]`
`Equals` |	*Экземплярный метод* |	Возвращает `true`, только если объекты имеют одну и ту же длину и состоят из одних и тех же символов
`CopyTo` |	*Экземплярный метод* |	Копирует подмножество символов строки в массив `char`

Как видим, методы класса `StringBuilder` менее развиты, чем методы класса `String`, но они позволяют более эффективно использовать память за счет работы с изменяемыми строками. Рассмотрим примеры использования данных методов.
```c#
static void Main()
{
 try
 {
  StringBuilder str=new StringBuilder("Площадь");
  PrintString(str);
  str.Append(" треугольника равна");
  PrintString(str);
  str.AppendFormat(" {0:f2} см ", 123.456);
  PrintString(str);
  str.Insert(8, "данного ");
  PrintString(str);
  str.Remove(7, 21);
  PrintString(str);
  str.Replace("а", "о");
  PrintString(str);
  StringBuilder str1=new StringBuilder(Console.ReadLine());
  StringBuilder str2=new StringBuilder(Console.ReadLine());
  Console.WriteLine(str1.Equals(str2));
 }
 catch
 {
  Console.WriteLine("Вознико исключение");
 }
}

static void PrintString(StringBuilder a)
{
 Console.WriteLine("Строка: "+a);
 Console.WriteLine("Текущая длина строки " +a.Length);
 Console.WriteLine("Объем буфера "+a.Capacity);
 Console.WriteLine("Максимальный объем буфера "+a.MaxCapacity);
 Console.WriteLine();
}
```

> **Задание**. Самостоятельно изучите метод `CopyTo`.

С изменяемой строкой можно работать не только как с объектом, но как с массивом символов:
```c#
static void Main()
{
 StringBuilder a = new StringBuilder("2*3=3*2");
 Console.WriteLine(a);
 int k=0;
 for (int i = 0; i < a.Length; ++i )
 if (char.IsDigit(a[i])) k+=int.Parse(a[i].ToString());
 Console.WriteLine(k);
}
```
На практике часто комбинируют работу с изменяемыми и неизменяемыми строками. Однако если необходимо изменять строку, то в этом случае используют `StringBuilder`.

**Пример**. Дана строка, в которой содержится осмысленное текстовое сообщение. Слова сообщения разделяются пробелами и знаками препинания. Вывести все слова сообщения, которые начинаются и заканчиваются на одну и ту же букву.
```c#
static void Main()
{
 Console.WriteLine("Введите строку: ");
 StringBuilder a = new StringBuilder(Console.ReadLine());
 Console.WriteLine("Исходная строка: "+a);
 for (int i=0; i<a.Length;)
 if (char.IsPunctuation(a[i])) a.Remove(i,1);
 else ++i;
 string str=a.ToString();
 string []s=str.Split(' ');
 Console.WriteLine("Искомые слова: ");
 for (int i=0; i<s.Length; ++i)
 if (s[i][0]==s[i][s.Length-1]) Console.WriteLine(s[i]);
}
```

> **Задание**. Измените программу так, чтобы она корректно работала и для случая, когда в исходной строке встречаются лишние пробелы.

### Регулярные выражения
https://intuit.ru/studies/courses/486/342/lecture/8238

Стандартный класс `string` позволяет выполнять над строками различные операции, в том числе поиск, замену, вставку и удаление подстрок. Тем не менее, есть классы задач по обработке символьной информации, где стандартных возможностей явно не хватает. Чтобы облегчить решение подобных задач, в Net Framework встроен более мощный аппарат работы со строками, основанный на регулярных выражениях.

Регулярные выражения предназначены для обработки текстовой информации и обеспечивают:

1. Эффективный поиск в тексте по заданному шаблону;
2. Редактирование текста;
3. Формирование итоговых отчетов по результатам работы с текстом.

Подробно рассмотрим первые два аспекта применения регулярных выражений.

#### Метасимволы в регулярных выражениях
Регулярное выражение — это шаблон, по которому выполняется поиск соответствующего фрагмента текста. Язык описания регулярных выражений состоит из символов двух видов: обычных символов и метасимволов. **Обычный символ** представляет в выражении сам себя, а **метасимвол** — некоторый *класс символов*.

Рассмотрим наиболее употребительные метасимволы:

Класс символов |	Описание |	Пример
-- | -- | --
`.` |	Любой символ, кроме `\n`. |	Выражение `c.t` соответствует фрагментам: `cat`, `cut`, `c#t`, `c{t` и т.д.
`[]` |	Любой одиночный символ из последовательности, записанной внутри скобок. Допускается использование *диапазонов символов*. |	Выражение `c[aui]t` соответствует фрагментам: `cat`, `cut`, `cit`. Выражение `c[a-c]t` соответствует фрагментам: `cat`, `cbt`, `cct`.
`[^]` |	Любой одиночный символ, не входящий в последовательность, записанную внутри скобок. Допускается использование *диапазонов символов*. |	Выражение `c[^aui]t` соответствует фрагментам: `cbt`, `cct`, `c2t` и т.д. Выражение `c[^a-c]t` соответствует фрагментам: `cdt`, `cet`, `c%t` и т.д.
`\w` |	Любой алфавитно-цифровой символ. |	Выражение `c\wt` соответствует фрагментам: `cbt`, `cct`, `c2t` и т.д., но не соответствует фрагментам `c%t`, `c{t` и т.д.
`\W` |	Любой не алфавитно-цифровой символ. |	Выражение `c\Wt` соответствует фрагментам: `c%t`, `c{t`, `c.t` и т.д., но не соответствует фрагментам `cbt`, `cct`, `c2t` и т.д.
`\s` |	Любой пробельный символ. |	Выражение `\s\w\w\w\s` соответствует любому слову из трех букв, окруженному пробельными символами.
`\S` |	Любой не пробельный символ. |	Выражение `\s\S\S\S\s` соответствует любым трем непробельным символам, окруженным пробельными.
`\d` |	Любая десятичная цифра |	Выражение `c\dt` соответствует фрагментам: `c1t`, `c2t`, `c3t` и т.д.
`\D` |	Любой символ, не являющийся десятичной цифрой |	Выражение `c\Dt` не соответствует фрагментам: `c1t`, `c2t`, `c3t` и т.д.

Кроме метасимволов, обозначающие классы символов, могут применяться уточняющие метасимволы:

Уточняющие символы |	Описание
-- | --
`^` |	Фрагмент, совпадающий с регулярными выражениями, следует искать только в начале строки
`$` |	Фрагмент, совпадающий с регулярными выражениями, следует искать только в конце строки
`\А` |	Фрагмент, совпадающий с регулярными выражениями, следует искать только в начале многострочной строки
`\Z` |	Фрагмент, совпадающий с регулярными выражениями, следует искать только в конце многострочной строки
`\b` |	Фрагмент, совпадающий с регулярными выражениями, начинается или заканчивается на границе слова, т.е. между символами, соответствующими метасимволам `\w `и `\W`
`\B` |	Фрагмент, совпадающий с регулярными выражениями, не должен встречаться на границе слов

В регулярных выражениях часто используются повторители — метасимволы, которые располагаются непосредственно после обычного символа или группы символов и задают количество его повторений в выражении.

Повторители |	Описание |	Пример
-- | -- | --
`*` |	Ноль или более повторений предыдущего элемента |	Выражение `ca*t` соответствует фрагментам: `ct`, `cat`, `caat`, `caaat` и т.д.
`+` |	Одно или более повторений предыдущего элемента |	Выражение `ca+t` соответствует фрагментам: `cat`, `caat`, `caaat` и т.д.
`?` |	Не более одного повторения предыдущего элемента	Выражение `ca?t` соответствует фрагментам: `ct`, `cat`.
`{n}` |	Ровно `n` повторений предыдущего элемента |	Выражение `ca{3}t` соответствует фрагменту: `cаааt`. Выражение `(cat){2}` соответствует фрагменту: `cаtcat`.
`{n,}` |	По крайней мере `n` повторений предыдущего элемента |	Выражение `ca{3, }t` соответствует фрагментам: `cаааt`, `caaaat`, `caaaaaaat` и т.д. Выражение `(cat){2, }` соответствует фрагментам: `catcat`, `catcatcat` и т.д.
`{n, m}` |	От `n` до `m` повторений предыдущего элемента	Выражение `ca{2, 4}t` соответствует фрагментам: `cааt`, `caaat`, `caaaat`.

Регулярное выражение записывается в виде строкового литерала, причем перед строкой необходимо ставить символ `@,` который говорит о том, что строку нужно будет рассматривать и в том случае, если она будет занимать несколько строчек на экране. Однако символ `@` можно не ставить, если в качестве шаблона используется шаблон без метасимволов.

> **Замечание**. Если нужно найти какой-то символ, который является метасимволом, например, точку, можно это сделать защитив ее обратным слэшем. Т.е. просто точка означает любой одиночный символ, а `\.` означает просто точку.
Примеры регулярных выражений:

1. слово `rus`: `@"rus"` или `"rus"`;
2. номер телефона в формате `xxx-xx-xx`: `@"\d\d\d-\d\d-\d\d"` или `@"\d{3}(-\d\d){2}"`;
3. номер автомобиля: `@"[A-Z]\d{3}[A-Z]{2}\d{2,3}RUS"`

> **Задания**. Запишите регулярное выражение, соответствующее:
>
> 1. дате в формате дд.мм.гг или дд.мм.гггг
> 2. времени в формате чч.мм или чч:мм
> 3. целому числу (со знаком и без)
> 4. вещественному числу (со знаком и без, с дробной частью и без, с целой частью и без)

#### Поиск в тексте по шаблону
Пространство имен библиотеки базовых классов `System.Text.RegularExpressions` содержит все объекты платформы .NET Framework, имеющие отношение к регулярным выражениям. Важнейшим классом, поддерживающим регулярные выражения, является класс `Regex`, который представляет неизменяемые откомпилированные регулярные выражения. Для описания регулярного выражения в классе определено несколько перегруженных конструкторов:

1. `Regex()` — создает пустое выражение;
2. `Regex(String)` — создает заданное выражение;
3. `Regex(String, RegexOptions)` — создает заданное выражение и задает параметры для его обработки с помощью элементов перечисления `RegexOptions` (например, различать или нет прописные и строчные буквы).

Поиск фрагментов строки, соответствующих заданному выражению, выполняется с помощью методов `IsMatch`, `Match`, `Matches` класса `Regex`.

Метод `IsMatch` возвращает `true`, если фрагмент, соответствующий выражению, в заданной строке найден, и `false` в противном случае. Например, попытаемся определить, встречается ли в заданном тексте слово `собака`:
```c#
static void Main()
{
  Regex r = new Regex("собака",RegexOptions.IgnoreCase);
  string text1 = "Кот в доме, собака в конуре.";
  string text2 = "Котик в доме, собачка в конуре.";
  Console.WriteLine(r.IsMatch(text1));
  Console.WriteLine(r.IsMatch(text2));
}
```

> **Замечание**. `RegexOptions.IgnoreCase` — означает, что регулярное выражение применяется без учета регистра символов.

Можно использовать конструкцию выбора из нескольких элементов. Варианты выбора перечисляются через вертикальную черту. Например, попытаемся определить, встречается ли в заданном тексте слов `собака` или `кот`:
```c#
static void Main(string[] args)
{
  Regex r = new Regex("собака|кот",RegexOptions.IgnoreCase);
  string text1 = "Кот в доме, собака в конуре.";
  string text2 = "Котик в доме, собачка в конуре.";
  Console.WriteLine(r.IsMatch(text1));
  Console.WriteLine(r.IsMatch(text2));
}
```
Попытаемся определить, есть ли в заданных строках номера телефона в формате `xx-xx-xx` или `xxx-xx-xx`:
```c#
static void Main()
{
  Regex r = new Regex(@"\d{2,3}(-\d\d){2}");
  string text1 = "tel:123-45-67";
  string text2 = "tel:no";
  string text3 = "tel:12-34-56";
  Console.WriteLine(r.IsMatch(text1));
  Console.WriteLine(r.IsMatch(text2));
  Console.WriteLine(r.IsMatch(text3));
}
```

> **Задание**. Измените программу так, чтобы можно было определить, содержится в тексте дата в формате дд.мм.гг.

Метод `Match` класса `Regex` не просто определяет, содержится ли текст, соответствующий шаблону, а возвращает объект класса `Match` — последовательность фрагментов текста, совпавших с шаблоном. Следующий пример позволяет найти все номера телефонов в указанном фрагменте текста:
```c#
static void Main()
{
  Regex r = new Regex(@"\d{2,3}(-\d\d){2}");
  string text = @"Контакты в Москве tel:123-45-67, 123-34-56; fax:123-56-45
                  Контакты в Саратове tel:12-34-56; fax:12-56-45";
  Match tel = r.Match(text);
  while (tel.Success)
  {
    Console.WriteLine(tel);
    tel = tel.NextMatch();
  }
}
```

Следующий пример позволяет подсчитать сумму целых чисел, встречающихся в тексте:
```c#
static void Main()
{
  Regex r = new Regex(@"[-+]?\d+");
  string text = @"5*10=50 -80/40=-2";
  Match teg = r.Match(text);
  int sum = 0;
  while (teg.Success)
  {
    Console.WriteLine(teg);
    sum += int.Parse(teg.ToString());
    teg = teg.NextMatch();
  }
  Console.WriteLine("sum=" + sum);
}
```

> **Задание**. Измените программу так, чтобы на экран дополнительно выводилось количество найденных чисел.

#### Редактирование текста
Регулярные выражения могут эффективно использоваться для редактирования текста. Например, метод `Replace` класса `Regex` позволяет выполнять замену одного фрагмента текста другим или удаление фрагментов текста:

**Пример 1**. Изменение номеров телефонов:
```c#
static void Main(string[] args)
 {
 string text = @"Контакты в Москве tel:123-45-67, 123-34-56; fax:123-56-45.
Контакты в Саратове tel:12-34-56; fax:11-56-45";
 Console.WriteLine("Старые данные\n"+text);
 string newText=Regex.Replace(text, "123-", "890-");
 Console.WriteLine("Новые данные\n" + newText);
 }
```

> **Задание**. Измените программу так, чтобы шестизначные номера заменялись на семизначные добавлением `0` после первых двух цифр. Например, номер `12-34-56` заменился бы на `120-34-56`.

**Пример 2**. Удаление всех номеров телефонов из текста:
```c#
static void Main()
  {
    string text = @"Контакты в Москве tel:123-45-67, 123-34-56; fax:123-56-45.
                Контакты в Саратове tel:12-34-56; fax:12-56-45";
    Console.WriteLine("Старые данные\n"+text);
    string newText=Regex.Replace(text, @"\d{2,3}(-\d\d){2}", "");
    Console.WriteLine("Новые данные\n" + newText);
  }
```

> **Задание**. Измените программу так, чтобы из текста удалялись слова `tel` и `fax` (если после данных слов стоят двоеточия, то их тоже следует удалить).

**Пример 3**. Разбиение исходного текста на фрагменты:
```c#
static void Main()
{
  string text = @"Контакты в Москве tel:123-45-67, 123-34-56; fax:123-56-45.
            Контакты в Саратове tel:12-34-56; fax:12-56-45";
  string []newText=Regex.Split(text,"[ ,.:;]+");
  foreach( string a in newText)
  Console.WriteLine(a);
}
```

> **Задание**. Разместите текст на одной строке и посмотрите, как изменится вывод данных. Объясните результаты.

#### Группировка соответствий
https://intuit.ru/studies/courses/486/342/lecture/8238?page=2

Класс `Group` позволяет группировать соответствия на основе синтаксиса регулярных выражений и представлять результаты действия одного группирующего выражения. Группирующее выражение именует группу и задает регулярное выражение. Любой фрагмент строки, удовлетворяющий этому регулярному выражению, будет добавлен в группу. Например, группу `ip` можно задать следующим выражением:
```c#
@"(?<ip>(\d|\.)+)\s"
```
В данной записи `(?)` говорит о том, что начинает формироваться группа, `<ip>` определяет имя данной группы, а `(\d|\.)+)\s` определяет *шаблон регулярного выражения*, который будет связан с этой группой. Если при поиске фрагмент текста будет соответствовать данному шаблону, то этот фрагмент будет заноситься в группу ip.

Класс `Match` является производным от класса `Group` и имеет коллекцию `Groups`, которая содержит все группы, обнаруженные объектом `Match`. Создание и использование коллекции `Groups` и классов `Group` иллюстрируется следующим примером:
```c#
static void Main(string[] args)
{
 string text = @"04:55:34 223.34.12.156 www.aaa.ru
                 04:59:55 213.134.112.56 www.bbb.cc.com
                 05:05:01 223.34.12.156 www.aaa.ru";
 Regex theReg = new  Regex(@"(?<time>(\d|\:)+)\s"+
                           @"(?<ip>(\d|\.)+)\s"+
                           @"(?<site>\S+)");
 MatchCollection theMatches = theReg.Matches(text);
 foreach (Match theMatch in theMatches)
 {
  if (theMatch.Length != 0)
  {
   Console.WriteLine("\ntheMatch: {0}", theMatch.ToString()); //1
   Console.WriteLine("time: {0}", theMatch.Groups["time"]);  //2
   Console.WriteLine("ip: {0}", theMatch.Groups["ip"]);  //3
   Console.WriteLine("site: {0}", theMatch.Groups["site"]);  //4
  }
 }
}
```
В этом примере строка 1 целиком выводит фрагмент текста совпавший с регулярным выражением, а строки 2-4, то только тот текст, который был помещен в конкретную группу

> **Практическое задание**
>
> 1. Шаблоны регулярных выражений для групп `time`, `ip` и `site` записаны в упрощенном виде. Преобразуйте их к такому виду, чтобы они соответствовали ограничениям, накладываемым на формат времени, ip-адреса и адреса web-сайта.
> 2. Используя дополнительную литературу и Интернет, более подробно изучите работу с классом `Group` и коллекцией `Groups` класса `Match`.

## 25. Функции в языке С#. Структура функции. Вызов функции. Прототип функции.

> ?

## 26. Рекурсивные функции.
https://intuit.ru/studies/courses/486/342/lecture/8232

**Рекурсивным** называют метод, если он вызывает сам себя в качестве вспомогательного. В основе *рекурсивного метода* лежит так называемое "рекурсивное *определение*" какого-либо понятия. Классическим примером рекурсивного метода является метод, вычисляющий факториал.

Из курса математики известно, что $0!=1!=1, n!=1\cdot 2\cdot 3…\cdot n$. С другой стороны $n!=(n-1)!\cdot n$. Таким образом, известны два частных случая параметра $n$, а именно $n= 0$ и $n=1$, при которых мы без каких-либо дополнительных вычислений можем определить значение факториала. Во всех остальных случаях, то есть для $n>1$, значение факториала может быть вычислено через значение факториала для параметра $n-1$. Таким образом, рекурсивный метод будет иметь вид:
```c#
{
   static long F(int n)  //рекурсивный метод
   {
      if (n==0 || n==1)
       return 1;    //нерекурсивная ветвь
       else return n*F(n-1);  //шаг рекурсии - повторный вызов метода с другим параметром
    }

    static void Main()
    {
      Console.Write("n=");
       int n =int.Parse( Console.ReadLine());
       long f=F(n); //нерекурсивный вызов метода F
       Console.WriteLine("{0}!={1}",n, f);
      }
}
```
Рассмотрим работу описанного выше рекурсивного метода для $n=3$.

![Recursive method](../img/06_01.gif)

Первый вызов метода осуществляется из метода `Main`, в нашем случае командой `f=F(3)`. Этап вхождения в рекурсию обозначим жирными стрелками. Он продолжается до тех пор, пока значение переменной `n` не становится равной `1`. После этого начинается выход из рекурсии (тонкие стрелки). В результате вычислений получается, что `F(3)=3*2*1`.

Рассмотренный вид рекурсии называют **прямой**. Метод с *прямой* рекурсией обычно содержит следующую структуру:
```c#
if (<условие>)
<оператор>;
else <вызов данного метода с другими параметрами>;
```
В качестве `<условия>` обычно записываются некоторые граничные случаи параметров, передаваемых рекурсивному методу, при которых результат его работы заранее известен, поэтому далее следует простой оператор или блок, а в ветви `else` происходит рекурсивный вызов данного метода с другими параметрами.

Что необходимо знать для реализации рекурсивного процесса? Со входом в рекурсию осуществляется *вызов метода*, а для выхода необходимо помнить **точку возврата**, т.е. то *место* программы откуда мы пришли и куда нам нужно будет возвратиться после завершения метода. *Место* хранения точек возврата называется **стеком вызовов** и для него выделяется определенная область оперативной памяти. В этом стеке запоминаются не только адреса точек возврата, но и копии значений всех параметров. *По этим копиям* восстанавливается при возврате вызывающий метод. При развертывании рекурсии за счет создания копий параметров возможно **переполнение стека**. Это является основным недостатком рекурсивного метода. С другой стороны, *рекурсивные методы* позволяют перейти к более компактной записи алгоритма.

Следует понимать, что любой *рекурсивный метод* можно преобразовать в обычный метод. И практически любой метод можно преобразовать в рекурсивный, если выявить *рекуррентное соотношение* между вычисляемыми в методе значениями.

Далее для сравнения каждую задачу будем решать с использованием обычного и рекурсивного методов:

**Пример 1**: Найти сумму цифр числа $А$.

Известно, что любое *натуральное число* $A=a_n a_{n-1}... a_1 a_0$, где $a_n a_{n-1}... a_1 a_0$ — цифры числа, можно представить следующим образом:
$$
A=a_n a_{n-1}... a_1 a_0 =\\ A=a_n\cdot 10^n + a_{n-1}\cdot 10^{n-1} + ... a_1\cdot 10^1 + a_0\cdot 10^0 =\\ ((...((a_n\cdot 10 + a_{n-1})\cdot 10+ a_{n-2})\cdot 10...)\cdot 10 + a_1)\cdot 10 + a_0
$$
Например, число 1234 можно представить как:
$$
1234 = 1\cdot 10^3 + 2\cdot 10^2 + 3\cdot 10^1 + 4\cdot 10^0 = ((1\cdot 10 + 2)\cdot 10 + 3)\cdot 10 + 4
$$
Из данного представления видно, что получить последнюю цифру можно, если найти *остаток от деления* числа на $10$. В связи с этим для разложения числа на составляющие его цифры можно использовать следующий *алгоритм*:

1. Находим остаток при делении числа $А$ на $10$, т.е. получаем крайнюю правую цифру числа.
2. Находим целую часть числа при делении $A$ на $10$, т.е. отбрасываем от числа $A$ крайнюю правую цифру.
3. Если преобразованное $A > 0$, то переходим на пункт 1. Иначе число равно нулю и отделять от него больше нечего.

Данный *алгоритм* будет использоваться при разработке нерекурсивного метода.

С другой стороны, сумму цифр числа $1234$ можно представить следующим образом $\sum(1234)=\sum(123)+4=(\sum(12)+3)+4=(((\sum(1)+2)+3)+4)=(((\sum(0)+1)+2)+3)+4$. Таким образом, если $А=0$, то сумма цифр числа также равна нулю, т.е. $\sum=0$. В противном случае сумму цифр числа $A$ можно представить *рекуррентным соотношением* $\sum(A)=\sum(A/10)+A\%10$. Полученное рекуррентное соотношение будем использовать при разработке *рекурсивного метода*.
```c#
class Program
  {
    static long Sum(long a) //нерекурсивный метод
    {
      long sum=0;
      while (a>0) //пока a больше нуля
      {
        sum+=a%10;  //добавляем к сумме последнюю цифру числа а
        a/=10;   //отбрасываем от числа а последнюю цифру
      }
      return sum;  //возвращаем в качестве результата сумму цифр числа a
    }

    static long SumR(long a) //рекурсивный метод
    {
      if (a==0) //если a =0, то
        return 0; // возвращаем 0
      else return SumR(a/10)+ a%10; //иначе обращаемся к рекуррентному соотношению
    }

    static void Main()
    {
      Console.Write("n=");
      long n=long.Parse(Console.ReadLine());
      Console.WriteLine("Нерекурсивный метод: "+Sum(n));
      Console.WriteLine("Рекурсивный метод: "+SumR(n));
    }
  }

```

**Пример 2**: вычислить $n$-ный член последовательности Фиббоначи.

Первые два члена последовательности Фиббоначи равны $1$, остальные получаются по рекуррентной формуле $a_n=a_{n-1}+a_{n-2}$.
```c#
class Program
  {
    static int Fb(int n) //нерекурсивный алгоритм
    {
      int a, a1=1, a2=1;
      if (n==1||n==2) return 1;
      else
      {
        for (int i=2; i<=n; ++i)
        {
          a=a1+a2;
          a1=a2;
          a2=a;
        }
        return a1;
      }
    }

    static int FbR(int n) //рекурсивный алгоритм
    {
      if (n==1 || n==2 )return 1;
        else return FbR(n-1)+FbR(n-2);
    }

    static void Main()
    {
      Console.Write("n=");
      int n=int.Parse(Console.ReadLine());
      Console.WriteLine("Нерекурсивный метод: "+Fb(n));
      Console.WriteLine("Рекурсивный метод: "+FbR(n));
    }
  }
```
**Задание**. Изменить методы так, чтобы на экран выводилась сумма $n$ элементов последовательности Фиббоначи.

Рассмотренные выше *рекурсивные методы* возвращали некоторое *значение*, заданное *рекуррентным соотношением*. Однако, как мы знаем, не все методы возвращают *значение*. Кроме того, рассмотренные выше методы определяют простой вариант *рекурсивного метода*. В общем случае *рекурсивный метод* включает в себя некоторое множество операторов и один или несколько операторов рекурсивного вызова. Действия могут выполняться после рекурсивного вызова, до рекурсивного вызова, а также и до, и после рекурсивного вызова. Рассмотрим примеры "сложных" *рекурсивных методов*, не возвращающих *значение*.

**Пример 3**. Для заданного значения $n$ вывести на экран $n$ строк, в каждой из которых содержится $n$ звездочек. Например, для $n=5$ на экран нужно вывести следующую таблицу:
```
*
**
***
****
*****
```
```c#
  class Program
  {
    static void Stroka(int n) //выводит на экран строку из n звездочек
    {
      for (int i=1; i<=n; ++i)
      {
        Console.Write('*');
      }
      Console.WriteLine();
    }

    static void Star(int n) //нерекурсивный метод
    {
      for (int i=1; i<=n;++i) //выводит n строк по i звездочек в каждой
        Stroka(i);
    }

    //рекурсивный метод, где i – номер текущей строки, n – номер последней строк
    static void StarR(int i,int n)
    {
      if (i<=n ) //если номер текущей строки не больше номера последней строки, то
      {
        Stroka(i); //выводим i звездочек в текущей строке и
        StarR(i+1,n); //переходим к формированию следующей строки
      }
    }

    static void Main()
    {
      Console.Write("n=");
      int n=int.Parse(Console.ReadLine());
      Console.WriteLine("Нерекурсивный метод: ");
      Star(n);
      Console.WriteLine("Рекурсивный метод: ");
      StarR(1,n); // параметр 1 – это номер первой строки, n – номер последней строки
    }
  }
```

**Пример 4**. Для заданного значения $n$ (например для $n=7$) вывести на экран следующую таблицу:
```
* * * * * * *
  * * * * *
    * * *
      *
      *
    * * *
  * * * * *
* * * * * * *
```
Данную таблицу условно можно разделить на две части. Рассмотрим отдельно верхнюю часть:

Номер строки |	Содержимое экрана |	$i$ — количество пробелов в строке |	Количество звездочек в строке
-- | -- | -- | --
0 |	******* |	0 |	7
1 |	***** |	1 |	5
2 |	*** |	2 |	3
3 |	* |	3 |	1

Таким образом, если нумеровать строки с нуля, то номер строки совпадает с количеством пробелов, которых нужно напечатать в начале этой строки. При этом количество звездочек в строке, можно определить по формуле $n-2i$, где $n$ – это количество звездочек в нулевой строке. Так как количество звездочек в каждой строке уменьшается на 2, то всего нужно напечатать $n/2+1$ строк.

Аналогичную зависимость можно выявить и для нижней части таблицы.
```c#
class Program
  {
    static void Stroka(int n, char a) //выводит на экран n раз символ а
    {
      for (int i=1; i<=n; ++i)
      {
        Console.Write(a);
      }
    }

    static void Star(int n) //нерекурсивный метод
    {
      for (int i=0; i<=n/2;++i) //выводим верхнюю часть таблицы, в которой в каждой строке вначале
      {
        Stroka(i,' '); //печатаем пробелы
        Stroka(n-2*i,'*'); //затем звездочки
        Console.WriteLine(); //затем переводим курсор на новую строку
      }
      for (int i=n/2; i>=0;--i) // аналогично выводим нижнюю часть таблицы
      {
        Stroka(i,' ');
        Stroka(n-2*i,'*');
        Console.WriteLine();
      }
    }

    //рекурсивный метод, где i определяет номер текущей строки, n – количество звездочек в строке
    static void StarR(int i, int n)
    {
      if (n>0 )
      {
        //действия до рекурсивного вызова – позволят вывести верхнюю часть таблицы
        Stroka(i, ' ');
        Stroka(n, '*');
        Console.WriteLine();
        //вызываем этот же метод, увеличивая номер строки, и уменьшая количество звездочек в ней
        StarR(i+1,n-2);
        //действия после рекурсивного вызова – позволят вывести нижнюю часть таблицы
        Stroka(i, ' ');
        Stroka(n, '*');
        Console.WriteLine();
      }
    }

    static void Main()
    {
      Console.Write("n=");
      int n=int.Parse(Console.ReadLine());
      Console.WriteLine("Нерекурсивный метод: ");
      Star(n);
      Console.WriteLine("Рекурсивный метод: ");
      StarR(0,n);
    }
  }
```

Все примеры, рассмотренные ранее, относились к *прямой* рекурсии. Однако существует еще и **косвенная рекурсия**, в которой метод вызывает себя в качестве вспомогательного не непосредственно, а через другой вспомогательный метод. *Косвенную рекурсию* демонстрирует следующая программа, которая для заданного значения $n$ выводит на экран следующее за ним простое число.

Данная программа содержит метод `Prim`, который возвращает `true`, если его *параметр* является простым числом, `false` – в противном случае. Чтобы установить, является ли число `j` простым, нужно проверить делимость числа `j` на все простые числа, не превышающие квадратный корень из `j`. Перебор таких простых чисел можно организовать так: рассмотреть первое простое число – `2`, а затем, используя метод `NextPrim`, возвращающий следующее за значением ее параметра простое число, получить все простые числа, не превышающие квадрата числа `j`. В свою очередь метод `NextPrim` обращается к методу `Prim` для того, чтобы определить является ли заданное число простым.

Таким образом методы `Prim` и `NextPrim` перекрестно вызывают друг друга. В этом и проявляется косвенная рекурсия.
```c#
class Program
	{
		static bool Prim (int j)
		{
			int k=2; //первое простое число
			//значение k "пробегает" последовательность простых чисел, начиная с 2 до корня из j, при
			//этом проверяется делится ли j на одно из таких простых чисел
			while (k*k<=j && j%k!=0)
				k=NextPrim(k); //вызов метода NextPrim
			return (j%k==0)?false:true;
		}

		static int NextPrim(int i)
		{
			int p=i+1;
			while (!Prim(p))	//вызов метода Prim
				++p;
			return p;
		}

		static void Main()
		{
			Console.Write("n=");
			int n=int.Parse(Console.ReadLine());
			Console.WriteLine("Следующее за {0} простое число равно {1}.", n, NextPrim(n));
		}
	}
```

Рекурсия является удобным средством решения многих задач: сортировки числовых массивов, обхода таких структур данных как деревья и графы.

С другой стороны, применение рекурсивных методов в ряде случаев оказывается нерациональным. Вспомним рекурсивный метод подсчета $n$-ного члена последовательности Фиббоначи. Данный метод будет работать весьма неэффективно. `FbR(17)` вычисляется в ней как `FbR(16) + FbR(15)`. В свою очередь `FbR(16)` вычисляется в ней как `FbR(15) + FbR(14)`. Таким образом, `FbR(15)` будет вычисляться 2 раза, `FbR(14)` – 3 раза, `FbR(13)` – 5 раз и т.д. Всего для вычисления `FbR(17)` потребуется выполнить более тысячи операций сложения. Для сравнения при вычислении `Fb(17)`, т.е. используя не рекурсивный метод, потребуется всего лишь 15 операций сложения.

Таким образом, при разработке рекурсивного метода следует задуматься об его эффективности.

## 27. Область видимости переменных. Локальные и глобальные переменные. Статические и динамические переменные
https://metanit.com/sharp/tutorial/2.18.php

Каждая переменная доступна в рамках определенного контекста или области видимость. Вне этого контекста переменная уже не существует.

Существуют различные контексты:

- Контекст класса. Переменные, определенные на уровне класса, доступны в любом методе этого класса. Их еще называют **глобальными** переменными или полями

- Контекст метода. Переменные, определенные на уровне метода, являются **локальными** и доступны только в рамках данного метода. В других методах они недоступны

- Контекст блока кода. Переменные, определенные на уровне блока кода, также являются **локальными** и доступны только в рамках данного блока. Вне своего блока кода они не доступны.

Например, пусть код программы определен следующим образом:
```c#
Person tom = new();
tom.PrintName();
tom.PrintSurname();

class Person                            // начало контекста класса
{
    string type = "Person";             // переменная уровня класса
    public void PrintName()             // начало контекста метода PrintName
    {
        string name = "Tom";            // переменная уровня метода

        {                               // начало контекста блока кода
            string shortName = "Tomas"; // переменная уровня блока кода
            Console.WriteLine(type);    // в блоке доступна переменная класса
            Console.WriteLine(name);    // в блоке доступна переменная окружающего метода
            Console.WriteLine(shortName);// в блоке доступна переменная этого же блока
        }                               // конец контекста блока кода, переменная shortName уничтожается

        Console.WriteLine(type);        // в методе доступна переменная класса
        Console.WriteLine(name);        // в методе доступна переменная этого же метода
        //Console.WriteLine(shortName); //так нельзя, переменная c определена в блоке кода
        //Console.WriteLine(surname);     //так нельзя, переменная surname определена в другом методе

    }       // конец контекста метода PrintName, переменная name уничтожается

    public void PrintSurname()      // начало контекста метода PrintSurname
    {
        string surname = "Smith";   // переменная уровня метода

        Console.WriteLine(type);        // в методе доступна переменная класса
        Console.WriteLine(surname);     // в методе доступна переменная этого же метода
    }       // конец конекста метода PrintSurname, переменная surname уничтожается

}   // конец контекста класса, переменная type уничтожается
```

Здесь определенно четыре переменных: `type`, `name`, `shortName` и `surname`. Каждая из них существует в своем контексте. Переменная `type` существует в контексте всего класса `Person` и доступна в любом месте и блоке кода в методах `PrintName` и `PrintSurname`.

Переменная `name` существует только в рамках метода `PrintName`. Также как и переменная `surname` существует в рамках метода `PrintSurname`. В методе `PrintName` мы не можем обратиться к переменной `surname`, так как она в другом контексте.

Переменная `shortName` существует только в блоке кода, границами которого являются открывающая и закрывающая фигурные скобки. Вне его границ переменная `shortName` не существует и к ней нельзя обратиться.

Нередко границы различных контекстов можно ассоциировать с открывающимися и закрывающимися фигурными скобками, как в данном случае, которые задают пределы блока кода, метода, класса.

При работе с переменными надо учитывать, что локальные переменные, определенные в методе или в блоке кода, скрывают переменные уровня класса, если их имена совпадают:
```c#
class Person
{
    string name = "Tom";             // переменная уровня класса
    public void PrintName()
    {
        string name = "Tomas";      // переменная уровня метода скрывает переменную уровня класса

        Console.WriteLine(name);    // Tomas
    }
}
```

При объявлении переменных также надо учитывать, что в одном контексте нельзя определить несколько переменных с одним и тем же именем.

### Неявно типизированные переменные
https://csharp.net-tutorials.com/ru/402/%D0%B2%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5/%D0%BD%D0%B5%D1%8F%D0%B2%D0%BD%D0%BE-%D1%82%D0%B8%D0%BF%D0%B8%D0%B7%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B5-%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5-%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%B2%D0%BE%D0%B5-%D1%81%D0%BB%D0%BE%D0%B2%D0%BE-var/

Начиная с версии c# 3.0 можно использовать ключевое слово `var` в левой части объявления переменной вместо явного объявления типа переменной. Это возможно только внутри метода, а не на уровне класса, где всегда необходимо указывать Тип. Давайте посмотрим, как это выглядит при использовании ключевого слова `var`:
```c#
int age = 42; // Explicitly typed variable

var name = "John Doe"; // Implicitly typed variable
```

Две переменные: одна объявлена с типом `int`, в то время как другая объявлена с ключевым словом `var`, вместо того, чтобы определить его как строку. Обратите внимание, что я назначаю значение в обоих случаях, потому что, хотя это не требуется при объявлении типа, это требуется при использовании ключевого слова `var`. Причина в том, что компилятор C# выведет тип из правой части оператора — он просто смотрит на то, что вы пытаетесь назначить переменной во время компиляции, а затем изменяет ключевое слово `var` на соответствующий тип.

Это также означает, что при использовании ключевого слова `var` не возникает никаких накладных расходов — это так же быстро во время выполнения, как и явно объявленная переменная, потому что это, по сути, то, что происходит, когда .NET framework выполняет ваш код.

Наш первый пример очень тривиален — не так много времени сэкономлено на написании "var "вместо "string". Однако иногда вы будете объявлять гораздо более сложные типы, либо как новую переменную, либо как локальный результат функции (определяемой пользователем или из платформы). В таком примере есть шанс сохранить достаточное количество нажатий клавиш:

```c#
Dictionary<int, List<string>> dict1 = new Dictionary<int, List<string>>();

var dict2 = new Dictionary<int, List<string>>();
```

Результат будет точно таким же, но вы определенно сохраните некоторые нажатия клавиш в последнем примере, и поскольку вы указываете Тип с правой стороны в обоих случаях, практически нет потери читаемости вашего кода при использовании в таком примере ключевого слова `var`.

Вы также можете использовать ключевое слово `var` при объявлении локальной переменной в результате вызова метода:
```c#
var s = DateTime.Now.ToString;
```
Опять же, это быстрее, и все еще довольно ясно, что происходит и какой тип будет содержать переменную (строку). Однако это может быть не в таком случае:
```c#
var myVar = SomeMethodWithANameWhichDoesntIndicateTheReturnType();
```

В такой ситуации не совсем ясно, что будет содержать переменная, и вы можете пожертвовать удобочитаемостью своего кода. Здесь можно рассмотреть возможность использования явно типизированной переменной.

#### Ключевое слово `var` и анонимные типы
До сих пор примеры, которые мы видели с ключевым словом `var`, были в основном из отдела "синтаксического сахара" — они хороши и короче для ввода, но на самом деле не являются требованием. Однако при работе с анонимными типами (подробнее о них позже) имеет смысл объявлять объекты с помощью ключевого слова `var`:
```c#
var myObj = new
{
    Name = "John Doe",
    Age = 42
};
Console.WriteLine(myObj.Name);
```

В этом случае вам действительно нужно ключевое слово `var` для последующего доступа к полям анонимного типа, как показано в этом примере.

Таким образом, ключевое слово `var` позволяет объявлять локальную переменную (внутри метода или цикла) без явного указания типа. Вместо этого компилятор C# выводит тип из правой части объявления. Это может быть очень удобно во многих ситуациях, но также может сделать код немного менее читаемым. Вы можете использовать его или придерживаться явного объявления типов переменных — что угодно, но вам это нужно для анонимных типов, как уже объяснялось.

### DLR в C#. Ключевое слово dynamic
https://metanit.com/sharp/tutorial/9.1.php

Хотя C# относится к статически типизированным языкам, в последних версиях языка были добавлены некоторые динамические возможности. Так, начиная с .NET 4.0 была добавлена новая функциональность под названием DLR (Dynamic Language Runtime). DLR представляет среду выполнения динамических языков, например, таких языков как IronPython и IronRuby.

Чтобы понять значение данного нововведение, нужно осознавать разичие между языками со статической и динамической типизицией. В языках со статической типизацией выявление всех типов и их членов — свойств и методов происходит на этапе компиляции. А в динамических языках системе ничего не известно о свойствах и методах типов вплоть до выполнения.

Благодаря этой среде DLR C# может создавать динамические объекты, члены которых выявляются на этапе выполнения программы, и использовать их вместе с традиционными объектами со статической типизацией.

Ключевым моментом использования DLR в C# является применение типов `dynamic`. Это ключевое слово позволяет опустить проверку типов во время компиляции. Кроме того, объекты, объявленные как `dynamic`, могут в течение работы программы менять свой тип. Например:
```c#
dynamic obj = 3;            // здесь obj - целочисленное int
Console.WriteLine(obj);     // 3

obj = "Hello world";        // obj - строка
Console.WriteLine(obj);     // Hello world

obj = new Person("Tom", 37); // obj - объект Person
Console.WriteLine(obj);      // Person { Name = Tom, Age = 37 }

record class Person(string Name, int Age);
```

Несмотря на то, что переменная `x` меняет тип своего значения несколько раз, данный код будет нормально работать. В этом использование типов `dynamic` отличается от применения ключевого слова `var`. Для переменной, объявленной с помощью ключевого слова `var`, тип выводится во время компиляции и затем во время выполнения больше не меняется.

Также можно найти общее между использованием `dynamic` и типом `object`. Если в предыдущем примере мы заменим `dynamic` на `object`: `object x = 3;`, то результат будет тот же. Однако и тут есть различия. Например:
```c#
object obj = 24;
dynamic dyn = 24;
obj += 4; // так нельзя
dyn += 4; // а так можно
```

На строке `obj += 4;` мы увидим ошибку, так как операция `+=` не может быть применена к типам `object` и `int`. С переменной, объявленной как `dynamic`, это пройдет, так как ее тип будет известен только во время выполнения.

Еще одна отличительная особенность использования `dynamic` состоит в том, что это ключевое слово применяется не только к переменным, но и к свойствам и методам. Например:
```c#
class Person
{
    public string Name { get;}
    public dynamic Age { get; set; }
    public Person(string name, dynamic age)
    {
        Name = name; Age = age;
    }

    // выводим зарплату в зависимости от переданного формата
    public dynamic GetSalary(dynamic value, string format)
    {
        if (format == "string") return $"{value} euro";
        else if (format == "int") return value;
        else return 0.0;
    }

    public override string ToString() => $"Name: {Name}  Age: {Age}";
}
```

В классе `Person` определено динамическое свойство `Age`, поэтому при задании значения этому свойству мы можем написать и `person.Age=22`, и `person.Age="twenty-two"`. Оба варианта будут допустимыми. А через параметр `age` в конструкторе этому свойству можно передать любое значение.

Также есть метод `GetSalary`, который возвращает значение `dynamic`. Например, в зависимости от параметра мы можем вернуть или строковое представление суммы дохода или численное. Также метод принимает `dynamic` в качестве параметра. Таким образом, мы можем передать в качестве значения дохода как целое, так и дробное число или строку. Посмотрим на конкретное применение:
```c#
dynamic tom = new Person("Tom", 22);
Console.WriteLine(tom);
Console.WriteLine(tom.GetSalary(28, "int"));

dynamic bob = new Person("Bob", "twenty-two");
Console.WriteLine(bob);
Console.WriteLine(bob.GetSalary("twenty-eight", "string"));
```

Консольный вывод программы:
```
Name: Tom  Age: 22
28
Name: Bob  Age: twenty-two
twenty-eight euro
```

## 28. Ввод/вывод в С#. Форматированный ввод/вывод в С#.
https://intuit.ru/studies/courses/486/342/lecture/8239

С#-программы выполняют операции ввода-вывода посредством потоков, которые построены на иерархии классов. **Поток** (stream) — это абстракция, которая генерирует и принимает данные. С помощью потока можно читать данные из различных источников (клавиатура, файл) и записывать в различные источники (принтер, экран, файл). Несмотря на то, что потоки связываются с различными физическими устройствами, характер поведения всех потоков одинаков. Поэтому классы и методы ввода-вывода можно применить ко многим типам устройств.

На самом низком уровне иерархии потоков ввода-вывода находятся потоки, оперирующие байтами. Это объясняется тем, что многие устройства при выполнении операций ввода-вывода ориентированы на байты. Однако для человека привычнее оперировать символами, поэтому разработаны символьные потоки, которые фактически представляют собой оболочки, выполняющие преобразование байтовых потоков в символьные и наоборот. Кроме этого, реализованы потоки для работы с `int-`, `double-`, `short-` значениями, которые также представляют оболочку для байтовых потоков, но работают не с самими значениями, а с их внутренним представлением в виде двоичных кодов.

Центральную часть потоковой С#-системы занимает класс `Stream` пространства имен `System.IO`. Класс `Stream` представляет байтовый поток и является базовым для всех остальных потоковых классов. Из класса `Stream` выведены такие байтовые классы потоков как:

1. `FileStream` — байтовый поток, разработанный для *файлового ввода-вывода*.
2. `BufferedStream` — заключает в оболочку байтовый поток и добавляет буферизацию, которая во многих случаях увеличивает производительность программы;
3. `MemoryStream` — байтовый поток, который использует память для хранения данных.
Программист может вывести собственные потоковые классы. Однако для подавляющего большинства приложений достаточно встроенных потоков.

Подробно мы рассмотрим класс `FileStream`, классы `StreamWriter` и `StreamReader`, представляющие собой оболочки для класса `FileStream` и позволяющие преобразовывать байтовые потоки в символьные, а также классы `BinaryWriter` и `BinaryReader`, представляющие собой оболочки для класса `FileStream` и позволяющие преобразовывать байтовые потоки в двоичные для работы с `int-`, `double-`, `short-` и т.д. значениями.

### Байтовый поток
Чтобы создать байтовый поток, связанный с файлом, создается объект класса     `FileStream`. При этом в классе определено несколько конструкторов. Чаще всего используется конструктор, который открывает поток для чтения и/или записи:
```c#
FileStream(string filename, FileMode mode)
```
где:

1. параметр `filename` определяет имя файла, с которым будет связан поток ввода-вывода данных; при этом `filename` определяет либо полный путь к файлу, либо имя файла, который находится в папке *bin/debug* вашего проекта.
2. параметр `mode` определяет режим открытия файла, который может принимать одно из возможных значений, определенных перечислением `FileMode`:
   - `FileMode.Append` — предназначен для добавления данных в конец файла;
   - `FileMode.Create` — предназначен для создания нового файла, при этом если существует файл с таким же именем, то он будет предварительно удален;
   - `FileMode.CreateNew` — предназначен для создания нового файла, при этом файл с таким же именем не должен существовать;
   - `FileMоde.Open` — предназначен для открытия существующего файла;
   - `FileMode.ОpenOrCreate` — если файл существует, то открывает его, в противном случае создает новый
   - `FileMode.Truncate` — открывает существующий файл, но усекает его длину до нуля

Если попытка открыть файл оказалась неуспешной, то генерируется одно из исключений:
- `FileNotFoundException` — файл невозможно открыть по причине его отсутствия,
- `IOException` — файл невозможно открыть из-за ошибки ввода-вывода,
- `ArgumentNullException` — имя файла представляет собой `null`-значение,
- `ArgumentException` — некорректен параметр `mode`,
- `SecurityException` — пользователь не обладает правами доступа,
- `DirectoryNotFoundException` — некорректно задан каталог.

Другая версия конструктора позволяет ограничить доступ только чтением или только записью:
```c#
FileStream(string filename, FileMode mode, FileAccess how)
```
где:

1. параметры `filename` и `mode` имеют то же назначение, что и в предыдущей версии конструктора;
2. параметр `how`, определяет способ доступа к файлу и может принимать одно из значений, определенных перечислением `FileAccess`:
   - `FileAccess.Read` — только чтение;
   - `FileAccess.Write` — только запись;
   - `FileAccess.ReadWrite` — и чтение, и запись.

После установления связи байтового потока с физическим файлом внутренний указатель потока устанавливается на начальный байт файла.

Для чтения очередного байта из потока, связанного с физическим файлом, используется метод `ReadByte()`. После прочтения очередного байта внутренний указатель перемещается на следующий байт файла. Если достигнут конец файла, то метод `ReadByte()` возвращает значение `-1`.

Для побайтовой записи данных в поток используется метод `WriteByte()`.

По завершении работы с файлом его необходимо закрыть. Для этого достаточно вызвать метод `Close()`. При закрытии файла освобождаются системные ресурсы, ранее выделенные для этого файла, что дает возможность использовать их для работы с другими файлами.

Рассмотрим пример использования класса `FileStream`, для копирования одного файла в другой. Но вначале создадим текстовый файл *text.txt* в папке *bin/debug* текущего проекта. И внесем в него произвольную информацию, например:
```
12    456
Hello!
23,67  4: Message
```
```c#
using System;
using System.Text;
using System.IO; //для работы с потоками

namespace MyProgram
{
 class Program
 {
  static void Main()
  {
   try
   {
   FileStream fileIn = new FileStream("text.txt",
                                       FileMode.Open,
                                       FileAccess.Read);
   FileStream fileOut = new FileStream("newText.txt",
                                        FileMode.Create,
                                        FileAccess.Write);
   int i;
   while ((i = fileIn.ReadByte())!=-1)
   {
    //запись очередного файла в поток, связанный с файлом fIleOut
    fileOut.WriteByte((byte)i);
   }
   fileIn.Close();
   fileOut.Close();
   }
   catch (Exception EX)
   {
    Console.WriteLine(EX.Message);
   }
  }
 }
}
```

> **Задание**. Подумайте, почему для переменной `i` указан тип `int`. Можно было бы указать тип `byte`?

### Символьный поток
Чтобы создать символьный поток нужно поместить объект класса `Stream` (например, `FileStream`) "внутрь" объекта класса `StreamWriter` или объекта класса `StreamReader`. В этом случае байтовый поток будет автоматически преобразовываться в символьный.

**Класс `StreamWriter`** предназначен для организации выходного символьного потока. В нем определено несколько конструкторов. Один из них записывается следующим образом:
```c#
StreamWriter(Stream stream);
```
где параметр `stream` определяет имя уже открытого байтового потока.

Например, создать экземпляр класса `StreamReader` можно следующим образом:
```c#
StreamWriter fileOut=new StreamWriter(new FileStream("text.txt",
                                                      FileMode.Create,
                                                      FileAccess.Write));
```
Этот конструктор генерирует исключение типа `ArgumentException`, если поток stream не открыт для вывода, и исключение типа `ArgumentNullException`, если он (поток) имеет null-значение.

Другой вид конструктора позволяет открыть поток сразу через обращения к файлу:
```c#
StreamWriter(string name);
```
где параметр `name` определяет имя открываемого файла.

Например, обратиться к данному конструктору можно следующим образом:
```c#
StreamWriter fileOut=new StreamWriter("c:\temp\t.txt");
```
И еще один вариант конструктора `StreamWriter`:
```c#
StreamWriter(string name, bool appendFlag);
```
где
- параметр `name` определяет имя открываемого файла;
- параметр `appendFlag` может принимать значение `true`, если нужно добавлять данные в конец файла, или `false`, если файл необходимо перезаписать.

Например:
```c#
StreamWriter fileOut=new StreamWriter("t.txt", true);
```
Теперь для записи данных в поток `fileOut` можно обратиться к методу `WriteLine`. Это можно сделать следующим образом:
```c#
fileOut.WriteLine("test");
```
В данном случае в конец файла *t.txt* будет дописано слово `test`.

**Класс `StreamReader`** предназначен для организации входного символьного потока. Один из его конструкторов выглядит следующим образом:
```c#
StreamReader(Stream stream);
```
где параметр `stream` определяет имя уже открытого байтового потока.

Этот конструктор генерирует исключение типа `ArgumentException`, если поток `stream` не открыт для ввода.

Например, создать экземпляр класса `StreamWriter` можно следующим образом:
```c#
StreamReader fileIn = new StreamReader(new FileStream("text.txt",
                                                       FileMode.Open,
                                                       FileAccess.Read));
```
Как и в случае с классом `StreamWriter` у класса `StreamReader` есть и другой вид конструктора, который позволяет открыть файл напрямую:
```c#
StreamReader (string name);
```
где параметр `name` определяет имя открываемого файла.

Обратиться к данному конструктору можно следующим образом:
```c#
StreamReader fileIn=new StreamReader ("c:\temp\t.txt");
```
В C# символы реализуются кодировкой Unicode. Для того, чтобы можно было обрабатывать текстовые файлы, содержащие русские символы, созданные, например, в Блокноте, рекомендуется вызывать следующий вид конструктора `StreamReader`:
```c#
StreamReader fileIn=new StreamReader ("c:\temp\t.txt",
                                       Encoding.GetEncoding(1251));
```
Параметр `Encoding.GetEncoding(1251)` говорит о том, что будет выполняться преобразование из кода Windows-1251 (одна из модификаций кода ASCII, содержащая русские символы) в Unicode. `Encoding.GetEncoding(1251)` реализован в пространстве имен `System.Text`.

Теперь для чтения данных из потока `fileIn` можно воспользоваться методом `ReadLine`. При этом если будет достигнут конец файла, то метод `ReadLine` вернет значение `null`.

Рассмотрим пример, в котором данные из одного файла копируются в другой, но уже с использованием классов `StreamWriter` и `StreamReader`.
```c#
static void Main()
{
  StreamReader fileIn = new StreamReader("text.txt",
                                          Encoding.GetEncoding(1251));
  StreamWriter fileOut=new StreamWriter("newText.txt", false);
  string line;
  while ((line=fileIn.ReadLine())!=null) //пока поток не пуст
  {
    fileOut.WriteLine(line);
  }
  fileIn.Close();
  fileOut.Close();
}
```

> **Задание**. Выясните, для чего предназначен метод `ReadToEnd()` и когда имеется смысл его применять.

Таким образом, данный способ копирования одного файла в другой, даст нам тот же результат, что и при использовании байтовых потоков. Однако, его работа будет менее эффективной, т.к. будет тратиться дополнительное время на преобразование байтов в символы. Но у символьных потоков есть свои преимущества. Например, мы можем использовать регулярные выражения для поиска заданных фрагментов текста в файле.
```c#
static void Main()
{
  StreamReader fileIn = new StreamReader("text.txt");
  StreamWriter fileOut=new StreamWriter("newText.txt", false);
  string text=fileIn.ReadToEnd();
  Regex r= new Regex(@"[-+]?\d+");
  Match integer = r.Match(text);
  while (integer.Success)
  {
    fileOut.WriteLine(integer);
    integer = integer.NextMatch();
  }
  fileIn.Close();
  fileOut.Close();
}
```

### Двоичные потоки
Двоичные файлы хранят данные в том же виде, в котором они представлены в оперативной памяти, то есть во внутреннем представлении. Двоичные файлы не применяются для просмотра человеком, они используются только для программной обработки.

Выходной поток `BinaryWriter` поддерживает произвольный доступ, т.е. имеется возможность выполнять запись в произвольную позицию двоичного файла. Наиболее важные методы потока `BinaryWriter`:

Член класса |	Описание
-- | --
`BaseStream` |	Определяет базовый поток, с которым работает объект `BinaryWriter`
`Close` |	Закрывает поток
`Flush` |	Очищает буфер
`Seek` |	Устанавливает позицию в текущем потоке
`Write` |	Записывает значение в текущий поток

Наиболее важные методы выходного потока `BinaryReader`:

Член класса |	Описание
-- | --
`BaseStream` |	Определяет базовый поток, с которым работает объект `BinaryReader`
`Close` |	Закрывает поток
`PeekChar` |	Возвращает следующий символ потока без перемещения внутреннего указателя в потоке
`Read` |	Считывает очередной поток байтов или символов и сохраняет в массиве, передаваемом во входном параметре
`ReadBoolean`, `ReadByte`, `ReadInt32` и т.д | 	Считывает из потока данные определенного типа

Двоичный поток открывается на основе базового потока (например, `FileStream`), при этом двоичный поток будет преобразовывать байтовый поток в значения `int-`, `double-`, `short-` и т.д.

Рассмотрим пример формирования двоичного файла:
```c#
static void Main()
  {
    //открываем двоичный поток
    BinaryWriter fOut=new BinaryWriter(new FileStream("t.dat",FileMode.Create));
    //записываем данные в двоичный поток
    for (int i=0; i<=100; i+=2)
    {
     fOut.Write(i);
    }
    fOut.Close(); //закрываем двоичный поток
  }
```
Попытка просмотреть двоичный файл через текстовый редактор неинформативна. Двоичный файл просматривается программным путем, например следующим образом:
```c#
static void Main()
  {
     FileStream f=new FileStream("t.dat",FileMode.Open);
    BinaryReader fIn=new BinaryReader(f);
    long n=f.Length/4; //определяем количество чисел в двоичном потоке
    int a;
    for (int i=0; i<n; i++)
    {
     a=fIn.ReadInt32();
     Console.Write(a+" ");
    }
    fIn.Close();
    f.Close();
  }
```
Двоичные файлы являются файлами с произвольным доступом, при этом нумерация элементов в двоичном файле ведется с нуля. Произвольный доступ обеспечивает метод `Seek`. Рассмотрим его синтаксис:
```c#
Seek(long newPos, SeekOrigin pos)
```
где параметр `newPos` определяет новую позицию внутреннего указателя файла в байтах относительно исходной позиции указателя, которая определяется параметром `pos`. В свою очередь параметр `pos` должен быть задан одним из значений перечисления `SeekOrigin`:

Значение |	Описание
-- | --
`SeekOrigin.Begin` |	Поиск от начала файла
`SeekOrigin.Current` |	Поиск от текущей позиции указателя
`SeekOrigin.End` |	Поиск от конца файла

После вызова метода `Seek` следующие операции чтения или записи будут выполняться с новой позиции внутреннего указателя файла.

Рассмотрим пример организации произвольного доступа к двоичному файлу (на примере файла `t.dat`):
```c#
static void Main()
  {
    //изменение данных в двоичном потоке
    FileStream f=new FileStream("t.dat",FileMode.Open);
    BinaryWriter fOut=new BinaryWriter(f);
    long n=f.Length; //определяем количество байт в байтовом потоке
    int a;
    for (int i=0; i<n; i+=8) //сдвиг на две позиции, т.к. тип int занимает 4 байта
    {
     fOut.Seek(i,SeekOrigin.Begin);
     fOut.Write(0);
    }
    fOut.Close();
    //чтение данных из двоичного потока
    f=new FileStream("t.dat",FileMode.Open);
    BinaryReader fIn=new BinaryReader(f);
    n=f.Length/4; //определяем количество чисел в двоичном потоке
    for (int i=0; i<n; i++)
    {
     a=fIn.ReadInt32();
     Console.Write(a+" ");
    }
    fIn.Close();
    f.Close();
 }
```

Поток `BinaryReader` не имеет метода `Seek`, однако используя возможности потока `FileStream` можно организовать произвольный доступ при чтении двоичных файлов. Рассмотрим следующий пример:
```c#
static void Main()
{
 //Записываем в файл t.dat целые числа от 0 до 100
 FileStream f=new FileStream("t.dat",FileMode.Open);
 BinaryWriter fOut=new BinaryWriter(f);
 for (int i=0; i<100; ++i)
 {
  fOut.Write(i);
 }
 fOut.Close();
 //Объекты f и fIn связаны с одним и тем же файлом
 f=new FileStream("t.dat",FileMode.Open);
 BinaryReader fIn=new BinaryReader(f);
 long n=f.Length; //определяем количество байт потоке
 //Читаем данные из файла t.dat, перемещая внутренний указатель на 8 байт, т.е. на два целых числа
 for (int i=0; i<n; i+=8)
 {
  f.Seek(i,SeekOrigin.Begin);
  int a=fIn.ReadInt32();
  Console.Write(a+" ");
 }
 fIn.Close();
 f.Close();
}
```

### Перенаправление стандартных потоков
Тремя стандартными потоками, доступ к которым осуществляется через свойства `Console.Out`, `Console.In` и `Console.Error`, могут пользоваться все программы, работающие в пространстве имен `System`. Свойство `Console.Out` относится к стандартному выходному потоку. По умолчанию это консоль. Например, при вызове метода `Console.WriteLine()` информация автоматически передается в поток `Console.Out`. Свойство `Console.In` относится к стандартному входному потоку, источником которого по умолчанию является клавиатура. Например, при вводе данных с клавиатуры информация автоматически передается потоку `Console.In`, к которому можно обратиться с помощью метода `Console.ReadLine()`. Свойство `Console.Error` относится к ошибкам в стандартном потоке, источником которого также по умолчанию является консоль. Однако эти потоки могут быть перенаправлены на любое совместимое устройство ввода-вывода, например, на работу с физическими файлами.

Перенаправить стандартный поток можно с помощью методов `SetIn()`, `SetOut()` и `SetError()`, которые являются членами класса `Console`:
```c#
static void Setln(TextReader input)
static void SetOut(TextWriter output)
static void SetError(TextWriter output)
```
Пример *перенаправления потоков* проиллюстрирован следующей программой, в которой двумерный массив вводится из файла *input.txt*, а выводится в файл *output.txt*
```c#
static void Main()
{
 try
 {
  int[,] MyArray;
  StreamReader file=new StreamReader("input.txt");
  Console.SetIn(file);  // перенаправляем стандартный входной поток на file
  string line=Console.ReadLine();
  string []mas=line.Split(' ');
  int n=int.Parse(mas[0]);
int m=int.Parse(mas[1]);
  MyArray = new int[n,m];
  for (int i = 0; i < n; i++)
  {
   line = Console.ReadLine();
   mas = line.Split(' ');
   for (int j = 0; j < m; j++)
   {
    MyArray[i,j] = int.Parse(mas[j]);
   }
  }
  PrintArray("исходный массив:", MyArray, n, m);
  file.Close();
}

static void PrintArray(string a, int[,] mas, int n, int m)
{
 StreamWriter file=new StreamWriter("output.txt"); // перенаправляем стандартный входной поток на file
 Console.SetOut(file);
 Console.WriteLine(a);
 for (int i = 0; i < n; i++)
 {
  for (int j=0; j<m; j++) Console.Write("{0} ", mas[i,j]);
  Console.WriteLine();
 }
 file.Close();
}
```
```
___input.txt_________
3 4
1 4 2 8
4 9 0 1
5 7 4 2
```
При необходимости восстановить исходное состояние потока `Console.In` можно следующим образом:
```c#
TextWriter str = Console.In;  // первоначально сохраняем исходное состояние входного потока
…
Console.SetIn(str);    // при необходимости восстанавливаем исходное состояние входного потока
```
Аналогичным образом можно восстановить исходное состояние потока `Console.Out`:
```c#
TextWriter str = Console.Out;  // первоначально сохраняем исходное состояние выходного потока
…
// при необходимости восстанавливаем исходное состояние выходного потока
Console.SetOut(str);
```

> **Задание**. Подумайте для чего нужно два потока `Console.Out` и `Console.Error`, если они оба при стандартной работе выводят информацию на экран.

## 29. Файловый ввод/вывод в С#. Функции для работы с файлами.
https://intuit.ru/studies/courses/486/342/lecture/8241

В пространстве имен `System.IO` предусмотрено четыре класса, которые предназначены для работы с файловой системой компьютера, т.е для создания, удаления переноса и т.д. файлов и каталогов.

Первые два типа — `Directory` и `Filе` реализуют свои возможности с помощью статических методов, поэтому данные классы можно использовать без создания соответствующих объектов (экземпляров классов).

Следующие типы — `DirectoryInfo` и `FileInfo` обладают схожими функциональными возможностями c `Directory` и `File`, но порождены от класса `FileSystemInfo` и поэтому реализуются путем создания соответствующих экземпляров классов.

> **Замечание**. Перед изучением данной лекции скопируйте на диск d своего компьютера архив *prim*. Внимательно изучите содержимое данного архива.

### Работа с каталогами

#### Абстрактный класс `FileSystemInfo`
Значительная часть членов `FileSystemInfo` предназначена для работы с общими характеристиками файла или каталога (метками времени, атрибутами и т. п.). Рассмотрим некоторые свойства `FileSystemInfo`:

Свойство |	Описание
-- | --
`Attributes` |	Позволяет получить или установить атрибуты для данного объекта файловой системы. Для этого свойства используются значения и перечисления `FileAttributes`
`CreationTime` |	Позволяет получить или установить время создания объекта файловой системы
`Exists` |	Может быть использовано для того, чтобы определить, существует ли данный объект файловой системы
`Extension` |	Позволяет получить расширение для файла
`FullName` |	Возвращает имя файла или каталога с указанием пути к нему в файловой системе
`LastAccessTime` |	Позволяет получить или установить время последнего обращения к объекту файловой системы
`LastWriteTime` |	Позволяет получить или установить время последнего внесения изменений в объект файловой системы
`Name` |	Возвращает имя указанного файла. Это свойство доступно только для чтения. Для каталогов возвращает имя последнего каталога в иерархии, если это возможно. Если нет, возвращает полностью определенное имя

В `FileSystemInfo` предусмотрено и несколько методов. Например, метод `Delete()` — позволяет удалить объект файловой системы с жесткого диска, a `Refresh()` — обновить информацию об объекте файловой системы.

#### Класс `DirectoryInfo`
Данный класс наследует члены класса `FileSystemInfo` и содержит дополнительный набор членов, которые предназначены для создания, перемещения, удаления, получения информации о каталогах и подкаталогах в файловой системе. Наиболее важные члены класса содержатся в следующей таблице:

Член |	Описание
-- | --
`Create()`<br>`CreateSubDirectory()` |	Создают каталог (или подкаталог) по указанному пути в файловой системе
`Delete()` |	Удаляет пустой каталог
`GetDirectories()` |	Позволяет получить доступ к подкаталогам текущего каталога (в виде массива объектов `DirectoryInfo`)
`GetFiles()` |	Позволяет получить доступ к файлам текущего каталога (в виде массива объектов `FileInfo`)
`MoveTo()` |	Перемещает каталог и все его содержимое на новый адрес в файловой системе
`Parent` |	Возвращает родительский каталог в иерархии файловой системы

Работа с типом `DirectoryInfo` начинается с того, что мы создаем экземпляр класса (объект), указывая при вызове конструктора в качестве параметра путь к нужному каталогу. Если мы хотим обратиться к текущему каталогу (то есть каталогу, в котором в настоящее время производится выполнение приложения), вместо параметра используется обозначение "`.`". Например:
```c#
// Создаем объект DirectoryInfo, которому будет обращаться к текущему каталогу
DirectoryInfo dir1 = new DirectoryInfo(".");
// Создаем объект DirectoryInfo, которому будет обращаться к каталогу d:\prim
DirectoryInfo dir2 = new DirectoryInfo(@"d:\prim");
```
Если мы попытаемся создать объект `DirectoryInfo`, связав его с несуществующим каталогом, то будет сгенерировано исключение `System.IO.DirectoryNotFoundException`. Если же все нормально, то мы сможем получить доступ к данному каталогу. В примере, который приведен ниже, мы создаем объект `DlrectoryInfo`, который связан с каталогом *d:\prim*, и выводим информацию о данном каталоге:
```c#
using System;
using System.Text;
using System.IO;

namespace MyProgram
{
 class Program
 {
  static void Main(string[] args)
  {
    DirectoryInfo dir = new DirectoryInfo(@"d:\prim");
    Console.WriteLine("***** "+dir.Name+" *****");
    Console.WriteLine("FullName: {0}", dir.FullName);
    Console.WriteLine("Name: {0}", dir.Name);
    Console.WriteLine("Parent: {0}", dir.Parent);
    Console.WriteLine("Creation: {0}", dir.CreationTime);
    Console.WriteLine("Attributes: {0}", dir.Attributes.ToString());
    Console.WriteLine("Root: {0}", dir.Root);
   }
 }
}
```
Свойство `Attributes` позволяет получить информацию об атрибутах объекта файловой системы. Возможные значения данного свойства приведены в следующей таблице:

Значение |	Описание
-- | --
`Archive` |	Этот атрибут используется приложениями при проведении резервного копирования, а в некоторых случаях — удаления старых файлов
`Compressed` |	Определяет, что файл является сжатым
`Directory` |	Определяет, что объект файловой системы является каталогом
`Encrypted` |	Определяет, что файл является зашифрованным
`Hidden` |	Определяет, что файл является скрытым (такой файл не будет выводиться при обычном просмотре каталога)
`Normal` |	Определяет, что файл находится в обычном состоянии и для него установлены любые другие атрибуты. Этот атрибут не может использоваться с другими атрибутами
`Offline` |	Файл (расположенный на сервере) кэширован в хранилище off-line на клиентском компьютере. Возможно, что данные этого файла уже устарели
`Readonly` |	Файл доступен только для чтения
`System` |	Файл является системным (то есть файл является частью операционной системы или используется исключительно операционной системой)

Через `DirectoryInfo` можно не только получать доступ к информации о текущем каталоге, но получить доступ к информации о его подкаталогах:
```c#
class Program
{
 static void printDirect( DirectoryInfo dir)
 {
  Console.WriteLine("***** "+dir.Name+" *****");
  Console.WriteLine("FullName: {0}", dir.FullName);
  Console.WriteLine("Name: {0}", dir.Name);
  Console.WriteLine("Parent: {0}", dir.Parent);
  Console.WriteLine("Creation: {0}", dir.CreationTime);
  Console.WriteLine("Attributes: {0}", dir.Attributes.ToString());
  Console.WriteLine("Root: {0}", dir.Root);
 }

 static void Main(string[] args)
 {
  DirectoryInfo dir = new DirectoryInfo(@"d:\prim");
  printDirect(dir);
  DirectoryInfo[] subDirects = dir.GetDirectories();
  Console.WriteLine("Найдено {0} подкаталогов", subDirects.Length);
  foreach (DirectoryInfo d in subDirects)
  {
   printDirect(d);
  }
  }
}
```

> **Задание**. Преобразуйте метод `printDirect` в рекурсивный метод таким образом, чтобы можно было просмотреть информацию о всех подкаталогах текущего каталога, независимо от уровня вложенности.

Метод `CreateSubdirectory()` позволяет создать в выбранном каталоге как единственный подкаталог, так и множество подкаталогов (в том числе, и вложенных друг в друга). Создадим в каталоге несколько дополнительных подкаталогов:
```c#
DirectoryInfo dir = new DirectoryInfo(@"d:\prim");
dir.CreateSubdirectory("doc"); //создали подкаталог
dir.CreateSubdirectory(@"book\2008"); //создали вложенный подкаталог
```

> **Задание**. Создайте вложенный подкаталог *best\2008* для каталога *d:\prim\bmp*.

Метод `MoveTo()` позволяет переместить текущий каталог по заданному в качестве параметра адресу. При этом возможно произвести переименование каталога. Например:
```c#
DirectoryInfo dir = new DirectoryInfo(@"d:\prim\bmp");
dir.MoveTo(@"d:\prim\letter\bmp");
```
В данном случае каталог *bmp* перемещается по адресу *d:\prim\letter\bmp*. Так как имя перемещаемого каталога совпадает с крайним правым именем в адресе нового местоположения каталога, то переименования не происходит. Следующий пример позволит нам переименовать текущий каталог:
```c#
DirectoryInfo dir = new DirectoryInfo(@"d:\prim\letter");
dir.MoveTo(@"d:\prim\archive");
```

#### Класс `Directory`
Работать с каталогами файловой системы компьютера можно и при помощи класса `Directory`, функциональные возможности которого во многом совпадают с возможностями `DirectoryInfo`. Но члены данного класса реализованы статически, поэтому для их использования нет необходимости создавать объект.

Рассмотрим работу с методами данного класса на примерах.

> **Замечание**. Удалите с диска *d* измененную папку *prim*. И еще раз скопируйте ее исходную версию из раздела 12 данного электронного учебника.
```c#
Directory.CreateDirectory(@"d:\prim\2008");//создали подкаталог 2008
Directory.Move(@"d:\prim\bmp",
             @"d:\prim\2008\bmp");//перенесли каталог bmp в каталог 2008
Directory.Move(@"d:\prim\letter",
             @"d:\prim\archives");//переименовали каталог letter в archives
```

> **Замечания**.
>
> 1. Удаление каталога возможно только тогда, когда он пуст.
> 2. На практике комбинируют использование классов `Directory` и `DirectoryInfo`.

### Работа с файлами

#### Класс `Filelnfo`
Класс `Filelnfo` предназначен для организации доступа к физическому файлу, который содержится на жестком диске компьютера. Он позволяет получать информацию об этом файле (например, о времени его создания, размере, атрибутах и т. п.), а также производить различные операции, например, по созданию файла или его удалению. Класс `FileInfo` наследует члены класса `FileSystemInfo` и содержит дополнительный набор членов, который приведен в следующей таблице:

Член |	Описание
-- | --
`AppendText()` |	Создает объект `StreamWriter` для добавления текста к файлу
`CopyTo()` |	Копирует уже существующий файл в новый файл
`Create()` |	Создает новый файл и возвращает объект `FileStream` для взаимодействия с этим файлом
`CreateText()` |	Создает объект `StreamWriter` для записи текстовых данных в новый файл
`Delete()` |	Удаляет файл, которому соответствует объект `FileInfo`
`Directory` |	Возвращает каталог, в котором расположен данный файл
`DirectoryName` |	Возвращает полный путь к данному файлу в файловой системе
`Length` |	Возвращает размер файла
`MoveTo()` |	Перемещает файл в указанное пользователем место (этот метод позволяет одновременно переименовать данный файл)
`Name` |	Позволяет получить имя файла
`Ореn()` |	Открывает файл с указанными пользователем правами доступа на чтение, запись или совместное использование с другими пользователями
`OpenRead()` |	Создает объект `FileStream`, доступный только для чтения
`OpenText()` |	Создает объект `StreamReader` (о нем также будет рассказано ниже), который позволяет считывать информацию из существующего текстового файла
`OpenWrite()` |	Создает объект `FileStream`, доступный для чтения и записи

Как мы видим, большинство методов `FileInfo` возвращает объекты (`FIleStream`, `StreamWriter`, `StreamReader` и т. п.), которые позволяют различным образом взаимодействовать с файлом, например, производить чтение или запись в него. Приемы работы с данными потоками нам уже известны. Поэтому рассмотрим другие возможности класса `FileInfo`.
```c#
using System;
using System.Text;
using System.IO; //для работы с файловым вводом-выводом
using System.Text.RegularExpressions;

namespace MyProgram
{
 class Program
 {
 static void Main()
 {
   //создаем новый файл  и связываем с ним строковый поток
   FileInfo f = new FileInfo("text.txt");
   StreamWriter fOut = new StreamWriter(f.Create());
   //записываем в файл данные и закрываем строковый поток,
// при этом  связь с физическим файлом для f не рвется
   fOut.WriteLine("ОДИН ДВА ТРИ...");
   fOut.Close();
   //получаем информацию о файле
   Console.WriteLine("*******"+f.Name File Inf+"**************");
   Console.WriteLine("File size: {0}", f.Length);
   Console.WriteLine("Creation: {0}", f.CreationTime);
   Console.WriteLine("Attributes: {0}", f.Attributes.ToString());
  }
 }
}
```

> **Замечание**. Еще раз удалите с диска *d* измененную папку *prim*, затем скопирует ее исходную версию из раздела 12 данного электронного учебника.
Рассмотрим следующий пример:
```c#
static void Main()
  {
    FileInfo f = new FileInfo(@"d:\prim\letter\letter1.txt");
    f.CopyTo(@"d:\prim\bmp\letter.txt");
    Directory.CreateDirectory(@"d:\prim\archives");
    f.MoveTo(@"d:\prim\archives\letter1.txt");
    f = new FileInfo(@"d:\prim\letter\letter2.txt");
    f.Delete();
  }
```

> **Задание**. Посмотрите, что произойдет, если запустить эту программу еще раз. Дайте этому объяснение.

Рассмотрим еще один пример по удалению файлов:
```c#
static void printFile( FileInfo file)
{
 Console.WriteLine("***** "+file.Name+" *****");
 Console.WriteLine("File size: {0}", file.Length);
 Console.WriteLine("Creation: {0}", file.CreationTime);
 Console.WriteLine("Attributes: {0}", file.Attributes.ToString());
}

static void Main(string[] args)
{
 DirectoryInfo dir = new DirectoryInfo(@"d:\prim\bmp");
 FileInfo[] files = dir.GetFiles();
 if (files.Length!=0)
  {
   Console.WriteLine("Найдено {0} файла", files.Length);
   foreach (FileInfo f in files)
   {
    printFile(f);
    f.Delete();
   }
   Console.WriteLine("\nТеперь в каталоге содержится {0} файлов и можно его удалить",
   dir.GetFiles().Length);
   dir.Delete();
  }
}
```

#### Класс `File`
Доступ к физическим файлам можно получать и через статические методы класса `File`. Большинство методов объекта `Fileinfo` представляют в этом смысле зеркальное отражение методов объекта `File`.

> **Замечание**. В последний раз удалите с диска *d* измененную папку *prim*, затем скопирует ее исходную версию из раздела 12 данного электронного учебника.
```c#
static void Main(string[] args)
{
 File.Copy(@"d:\prim\letter\letter1.txt",@"d:\prim\bmp\letter1.txt");
 Directory.CreateDirectory(@"d:\prim\archives");
 File.Move(@"d:\prim\letter\letter1.txt",@"d:\prim\archives\letter1.txt");
 File.Delete(@"d:\prim\letter\letter2.txt");
 Directory.Delete(@"d:\prim\letter");
}
```

Имеет прямой смысл использовать статический класс `File`, когда требуется осуществить единственный вызов метода на объект. В этом случае вызов будет выполнен быстрее, поскольку .NET Framework не придется проходить через процедуру создания экземпляра нового объекта с последующим вызовом метода. Однако если приложение осуществляет несколько операций над файлом, то более разумным представляется создать экземпляр объекта `FileInfo` и использовать его методы. Это позволит сэкономить определенное время, поскольку объект будет заранее настроен на нужный файл в файловой системе, в то время как статическому классу придется каждый раз осуществлять его поиск заново.

Аналогичное правило действует и при выборе между классами `Directory` и `DirectoryInfo`.

## 30. Структуры в языке С#. Определение и инициализация структуры. Создание экземпляра структуры.

### Интерфейсы
https://intuit.ru/studies/courses/486/342/lecture/8245

В объектно-ориентированном программировании иногда требуется определить, что класс должен делать, а не как он будет это делать. Такой подход может быть реализован с помощью абстрактного класса, при этом в абстрактном классе часть методов может быть реализована, часть нет. Кроме этого в С# предусмотрена возможность полностью отделить структуру класса от его реализации. Это делается с помощью интерфейса.

**Интерфейс** — это "крайний случай" абстрактного класса, в котором не предусмотрена ни одна реализация члена класса. Таким образом, интерфейс описывает функциональность классов, но не определяет способа ее реализации. Каждый класс, наследуя интерфейс, может реализовать его элементы по-своему. Так достигается полиморфизм — объекты разных классов по-разному реагируют на вызовы одного и того же метода.

Синтаксис интерфейса:
```c#
[атрибуты] [спецификаторы] interface имя_интерфейса : [предки]
{
//объявление функциональных членов интерфейса без реализации
...
}
```
Для интерфейса могут быть указаны спецификаторы `new`, `public`, `internal` и `private`. Спецификатор `new` применяется для вложенных интерфейсов и имеет такой же смысл, как и соответствующий спецификатор метода класса. По умолчанию интерфейс доступен только из сборки, в которой он описан (`internal`).

Все функциональные члены интерфейса по умолчанию являются открытыми (`public`) и абстрактными (`abstract`), поэтому при описании метода указывается только тип возвращаемого им значения и сигнатуры.

В качестве функциональных членов в интерфейсе можно объявлять сигнатуры методов, свойств, индексаторов и событий (для Windows-приложений). Интерфейсы не могут содержать члены данных, конструкторы, деструкторы или операторные методы (методы, переопределяющие операции). Ни один член интерфейса не может быть объявлен статическим.

Напомним, что класс может наследовать один базовый класс и несколько интерфейсов. Класс, наследующий интерфейс, должен реализовать его в полном объеме. Т.к. функциональные члены, объявленные внутри интерфейса, являются открытыми, то их реализация также должна быть открытой. Кроме того, сигнатура функционального члена в реализации должна в точности совпадать с сигнатурой, заданной в определении интерфейса.

В качестве примера рассмотрим интерфейс `IDemo` и его реализацию для классов `DemoPoint` и `DemoLine` из предыдущей лекции:
```c#
//определение интерфейса
interface IDemo
 {
  void Show();   //объявление метода
  double Dlina();   //объявление метода
  int X {get;}   //объявление свойства, доступного только для чтения
  int this [int i]{get;set;} //объявление индексатора, доступного для чтения-записи
 }

//класс DemoPoint наследует интерфейс IDemo
class DemoPoint:IDemo
 {
  protected int x;
  protected int y;
  public DemoPoint ( int x, int y)
  {
   this.x=x; this.y=y;
   }
  public void Show() //реализация метода, объявленного в интерфейсе
  {
   Console.WriteLine("точка на плоскости: ({0}, {1})",x, y);
  }
  public double Dlina() //реализация метода, объявленного в интерфейсе
  {
   return Math.Sqrt(x*x+y*y);
  }
  public int X //реализация свойства, объявленного в интерфейсе
  {
   get
   {
    return x;
   }
  }

  public int this [int i] //реализация индексатора, объявленного в интерфейсе
  {
   get
   {
    if (i==0) return x;
    else if (i==1) return y;
    else throw new Exception ("недопустимое значение индекса");
}
   set
   {
    if (i==0) x=value;
    else if (i==1) y=value;
    else throw new Exception ("недопустимое значение индекса");
   }
  }
 }

//класс DemoShape наследует класс DemoPoint и интерфейс IDemo
class DemoShape : DemoPoint, IDemo
{
  protected int z;
  public DemoShape(int x, int y, int z):base(x, y)
  {
   this.z=z;
  }
  // реализация метода, объявленного в интерфейсе, с сокрытием одноименного метода из
  //базового класса
  public new void Show()
  {
   Console.WriteLine("точка в пространстве: ({0}, {1}, {2})", x, y, z);
  }
  // реализация метода, объявленного в интерфейсе, с сокрытием одноименного метода из
  //базового класса
  public new double Dlina()
  {
   return Math.Sqrt(x*x+y*y+z*z);
  }
  // реализация индексатора, объявленного в интерфейсе, с сокрытием одноименного
  // индексатора из базового класса
  public new int this [int i]
  {
   get
   {
    if (i==0) return x;
    else if (i==1) return y;
     else if (i==2) return z;
      else throw new Exception ("недопустимое значение индекса");
   }
   set
   {
    if (i==0) x=value;
    else if (i==1) y=value;
     else if (i==2) z=value;
     else throw new Exception ("недопустимое значение индекса");
   }
  }
 }

class Program
 {
  static void Main()
  {
   //создание массива интерфейсных ссылок
   IDemo []a =new IDemo[4];
   //заполнение массива
   a[0]=new DemoPoint(0,1);
   a[1]=new DemoPoint(-3, 0);
   a[2]=new DemoShape(3,4,0);
   a[3]= new DemoShape(0,5, 6);
   //просмотр массива
   foreach (IDemo x in a)
   {
    x.Show();
    Console.WriteLine("Dlina={0:f2}",x.Dlina());
    Console.WriteLine("x="+x.X);
    x[1]+=x[0];
    Console.Write("новые координаты - ");
    x.Show();
    Console.WriteLine();
   }
  }
}
```
Обратите внимание, что в интерфейсе `IDemo` было объявлено свойство `Х`, доступное только для чтения. Наследуя интерфейс `IDemo`, класс `DemoPoint` определил реализацию данного свойства. Класс `DemoShape`, наследуя класс `DemoPoint` и `IDemo`, не предложил собственной реализации свойства `Х`, поэтому при обращении к объекту типа `DemoShape` вызывается реализация данного свойства, определенная в базовом классе.

> **Задания**.
>
> 1. Добавьте в интерфейс `IDemo` свойство `Y`, которое позволит обращаться для чтения к значению поля `у`. Реализуйте работу с данным свойством в классах `DemoPoint` и `DemoShape`.
> 2. Добавьте свойство `Z` для обращения к полю `z` класса `DemoShape`. Подумайте, куда именно нужно добавить определение данного свойства и почему.

### Стандартные интерфейсы .Net
https://intuit.ru/studies/courses/486/342/lecture/8245?page=2

В библиотеке классов .Net определено множество стандартных интерфейсов, задающих желаемую функциональность объектов. Например, интерфейс `IComparable` задает метод сравнения объектов по принципу больше и меньше, что позволяет переопределить соответствующие операции в рамках класса, наследующего интерфейс `IComparable`. Реализация интерфейсов `IEnumerable` и `IEnumerator` дает возможность просматривать содержимое объекта с помощью оператора `foreach`.

Можно создавать собственные классы, реализующие стандартные интерфейсы, что позволит использовать объекты этих классов стандартными способами.

Более подробно рассмотрим стандартный интерфейс `IComparable`.

Интерфейс `IComparable` определен в пространстве имен `System` и содержит единственный метод `CompareTo`, возвращающий результат сравнения двух объектов — текущего и переданного ему в качестве параметра:
```c#
interface IComparable
{
 int CompareTo(object obj);
}
```
Реализация данного метода должна возвращать:

1. `0` — если текущий объект и параметр равны;
2. отрицательное число, если текущий объект меньше параметра;
3. положительное число, если текущий объект больше параметра.

В качестве примера рассмотрим реализацию классом `DemoPoint` стандартного интерфейса `IComparable`.
```c#
// класс DemoPoint реализует стандартный интерфейс IComparable
class DemoPoint:IComparable
{
 protected int x;
 protected int y;
 public DemoPoint ( int x, int y)
 {
  this.x=x; this.y=y;
 }
 public void Show()
 {
  Console.WriteLine("точка на плоскости: ({0}, {1})",x, y);
 }
 public double Dlina()
 {
  return Math.Sqrt(x*x+y*y);
 }
 //реализация метода CompareTo
 public int CompareTo (object obj)
 {
  DemoPoint b=(DemoPoint) obj; //преобразуем к типу DemoPoint
  //определяем критерии сравнения текущего объекта с параметром в
  // зависимости от удаленности точки от начала координат
  if (this.Dlina()==b.Dlina()) return 0;
  else if (this.Dlina()>b.Dlina()) return 1;
  else return -1;
}
}

class Program
{
 static void Main()
 {
  //создаем массив ссылок
DemoPoint []a =new DemoPoint[4];
  a[0]=new DemoPoint(5,-1);
  a[1]=new DemoPoint(-3, 3);
  a[2]=new DemoPoint(3,4);
  a[3]= new DemoPoint(0,1);
  //сортируем массив точек, при этом в качестве критерия сортировки будет
//использоваться собственная реализация метода CompareTo
  Array.Sort(a);
  Console.WriteLine();
  foreach (DemoPoint x in a)
  {
   x.Show();
   Console.WriteLine("Dlina={0:f2} ",x.Dlina());
  }
 }
 }
```

> **Задание**. Измените метод `CompareTo` так, чтобы метод `Sort` сортировал массив точек по убыванию расстояния между точкой и началом координат.

Обратите внимание на то, что во время реализации метода `CompareTo` в качестве параметра передавалась ссылка на объект типа `object`. Напомним, что класс `object` является корневым классом для всех остальных в С#. Поэтому он может ссылаться на объект любого типа. Но чтобы потом получить доступ к членам объекта произвольного класса, нужно выполнить приведение типов.

Используя собственную реализацию метода `CompareTo` можно перегрузить операции отношения. Напомним, что операции отношения должны перегружаться парами: `<` и `>`, `<=` и `>=`, `==` и `!=`.

В следующем примере для класса `DemoPoint` перегрузим операции `==` и `!=` таким образом, чтобы при сравнении двух объектов возвращалось значение `true`, если точки находятся на равном удалении от начала координат, в противном случае — `false`.
```c#
class DemoPoint:IComparable
{
protected int x;
 protected int y;
 public DemoPoint ( int x, int y)
 {
  this.x=x; this.y=y;
 }
 public void Show()
 {
  Console.WriteLine("точка на плоскости: ({0}, {1})",x, y);
 }
 public double Dlina()
 {
  return Math.Sqrt(x*x+y*y);
 }
 public int CompareTo (object obj)
 {
  DemoPoint b=(DemoPoint) obj;
  if (this.Dlina()==b.Dlina()) return 0;
  else if (this.Dlina()>b.Dlina()) return 1;
  else return -1;
}
  public static bool operator ==(DemoPoint a, DemoPoint b)
 {
  return (a.CompareTo(b)==0);
 }
 public static bool operator !=(DemoPoint a, DemoPoint b)
 {
  return (a.CompareTo(b)!=0);
 }
}

class Program
{
 static void Main()
 {
  DemoPoint a =new DemoPoint(-3,0);
  DemoPoint b=new DemoPoint(0,3);
  if (a==b) Console.WriteLine("равно удалены от начала координат");
   else Console.WriteLine("не равно удалены от начала координат");
 }
}
```

> **Задание**. Перегрузите в классе `DemoPoint` следущие пары операций:
>
1. `>` и `<,` так чтобы при сравнении двух объектов возвращалось значение `true`, если первая точка расположена дальше от начала координат, чем вторая, иначе `false`.
2. `>=` и `<=`, так чтобы при сравнении двух объектов возвращалось значение `true` если первая точка расположена не ближе к началу координат, чем вторая, иначе `false`.

### Структуры
Классы, как вы уже знаете, являются ссылочными данными. Это означает, что к экземплярам классов можно обратиться только через ссылку. В С# реализован тип данных, аналогичный классу, но который в отличие от классов является размерным типом. Таким типом является **структура**.

Так как структура является размерным типом, то экземпляр структуры хранит значение своих элементов, а не ссылки на них, и располагается в стеке данных, а не в куче. В связи с этим фактом структура не может участвовать в иерархии наследования, а может только реализовывать интерфейсы. Кроме того, структуре запрещено:

1. определять конструктор по умолчанию, поскольку он определен неявно и присваивает всем своим элементам значения по умолчанию (нули соответствующего типа);
2. определять деструктор, поскольку это бессмысленно.

Синтаксис структуры:
```c#
[атрибуты][спецификаторы] struct имя_структуры [: интерфейсы]
{
 тело_структуры
}
```
Спецификаторы структуры имеют такой же смысл, как и для класса. Однако из спецификаторов доступа допускается использовать только `public`, `internal` и для вложенных структур еще и `private`. Кроме того, структуры не могут быть абстрактными, поскольку по умолчанию они бесплодны.

Интерфейсы, реализуемые структурой, перечисляются через запятую.

Тело структуры может содержать: константы, поля, конструкторы, методы, свойства, индексаторы, операторные методы, *вложенные типы* и события.

При описании структуры задавать значение по умолчанию можно только для статических полей. Остальным полям с помощью конструктора по умолчанию будут присвоены нули для полей размерных типов и `null` для полей ссылочных типов.

Параметр `this` интерпретируется как значение, поэтому его можно использовать для ссылок, но не для присваивания.

Так как структуры не могут участвовать в иерархии, то для ее членов недопустимо использовать спецификаторы `protected` и `protected internal`. Методы структур не могут быть абстрактными и виртуальными. А переопределяться могут только те методы, которые унаследованы от базового класса `object`.

Рассмотрим пример структуры `SPoint`, реализующей стандартный интерфейс `IComparable`. В данной структуре определены:

1. поля `x` и `у`;
2. конструктор, в который передаются заданные координаты точки;
3. метод `Dlina`, который позволяет вычислить расстояние от точки до начала координат;
4. перегружен метод `ToString` базового класса `object`;
5. реализован метод `CompareTo` стандартного интерфейса `IComparable`;
6. перегружены операции `==` и `!=`.

```c#
//описание структуры
 struct SPoint: IComparable
 {
  public int x, y;
  public SPoint (int x, int y)
  {
   this.x=x; this.y=y;
  }
  public double Dlina() //метод
  {
   return Math.Sqrt(x*x+y*y);
}
  public override string ToString()
  {
   return "("+x.ToString()+", "+y.ToString()+")";
  }
  public int CompareTo (object obj)
  {
   SPoint b=(SPoint) obj;
   if (this.Dlina()==b.Dlina()) return 0;
   else if (this.Dlina()>b.Dlina()) return 1;
   else return -1;
  }
  public static bool operator ==(SPoint a, SPoint b)
  {
   return (a.CompareTo(b)==0);
  }
  public static bool operator !=(SPoint a, SPoint b)
  {
   return (a.CompareTo(b)!=0);
  }
 }

 class Program
 {
  static void Main()
  {
   //создание и заполнение массива структур
   SPoint []a =new SPoint[4];
   a[0]=new SPoint(-3,0);
   a[1]=new SPoint(-0, 3);
   a[2]=new SPoint(3,4);
   a[3]= new SPoint(0,1);
   //сравнение двух структур
   if (a[0]==a[1])
   Console.WriteLine("точки {0} и {1} равноудалены от начала координат\n",
       a[0].ToString(),a[1].ToString());
   else Console.WriteLine("точки {0} и {1} не равноудалены от начала координат\n",
       a[0].ToString(),a[1].ToString());
   Array.Sort(a); //сортировка массива структур
   //просмотр массива структур
   foreach (SPoint x in a)
   {
    Console.WriteLine("Точка: "+x.ToString());
    Console.WriteLine("удалена от начала координат на расстояние равное: "+x.Dlina());
     Console.WriteLine();
   }
  }
 }
```
Как видно из примера, экземпляр структуры, как и экземпляр класса, создаются с помощью оператора `new`, но это не обязательно. Если оператор `new` не используется, то структура все равно создается, но не инициализируется. По этой причине следующая последовательность команд будет ошибочна:
```c#
SPoint one;
Console.WriteLine(one.ToString());
```
Если при объявлении структуры не был вызван конструктор, то поля нужно инициализировать вручную:
```c#
SPoint one;
one.x=100; one.y=100;
Console.WriteLine(one.ToString());
```
Так как структуры являются размерными типами, то присваивание одной структуры другой создает копию экземпляра структуры. Этот факт является важным отличием структуры от класса. В результате выполнения следующего фрагмента программы мы убедимся, что структуры one и two не зависят друг от друга.
```c#
SPoint one=new SPoint(); //вызов конструктора по умолчанию
SPoint two=new SPoint(1,1); //вызов собственного конструктора
Console.WriteLine(one.ToString());
Console.WriteLine(two.ToString());
one=two;
one.x=100;
Console.WriteLine(one.ToString());
Сonsole.WriteLine(two.ToString());
```
Как при решении практических задач выбрать, что использовать - класс или структуру? Если создаваемые типы данных содержат небольшое количество полей, с которыми удобнее работать как со значениями, а не как со ссылками, то расходы на выделение динамической памяти для небольших объектов снизят быстродействие программы, поэтому такие типы данных эффективнее реализовывать через структуры. Во всех остальных случаях эффективнее использовать классы. Однако передача структуры в методы по значению потребует и дополнительного времени, и дополнительной памяти для создания копии. В таких случаях эффективнее использовать классы.

### Интерфейсы `System.Collection`
https://intuit.ru/studies/courses/486/342/lecture/8245?page=3

В пространстве имен `System.Collection` определено несколько интерфейсов, определяющих функциональность многих стандартных классов в С#, в том числе и коллекций (которые будет рассматриваться в следующем разделе). Рассмотрим более подробно интерфейсные коллекции, описание которых приведено в следующей таблице:

Интерфейс |	Описание
-- | --
`IEnumerator` |	Содержит методы, которые позволяют поэлементно получать содержимое коллекции
`IEnumerable` |	Определяет метод `GetEnumerator()`, который поддерживает нумератор для любого класса коллекции
`ICollection` |	Определяет элементы, которые должны иметь все коллекции
`IComparer` |	Определяет метод `Compare()` , который выполняет сравнение объектов, хранимых в коллекции
`IList` |	Определяет коллекцию, к которой можно получить доступ посредством индексатора
`IDictionary` |	Определяет коллекцию (словарь), которая состоит из пар ключ/значение
`IDictionaryEnumerator` |	Определяет нумератор для коллекции, которая реализует интерфейс `IDictionary`
`IHashCodeProvider` |	Определяет хеш-функцию

Основополагающим для всех коллекций является реализация перечислителя (нумератора),который поддерживается интерфейсами `IEnumerator` и `IEnumerable`. Перечислитель обеспечивает стандартизованный способ поэлементного доступа к содержимому коллекции, в том числе и через использование цикла `foreach`.

Интерфейс `ICollection` наследует интерфейс `IEnumerable`. В `ICollection` объявлены основные методы и свойства, без которых не может обойтись ни одна коллекция:

Элемент интерфейса |	Его тип |	описание
-- | -- | --
`int Сount {get;}` |	Свойство |	Определяет количество элементов коллекции в данный момент. Если `Count` равно нулю, то коллекция пуста.
`void CopyTo (Array target, int startIdx)` |	Метод |	Обеспечивает переход от коллекции к стандартному С#-массиву, копируя содержимое коллекции в массив, заданный параметром `target`, начиная с индекса, заданного параметром `startIdx`.

Интерфейс `IList` наследует интерфейс `ICollection` и определяет поведение коллекции, доступ к элементам которой разрешен посредством индекса с отсчетом от нуля. Помимо методов, определенных в интерфейсе `ICollection`, интерфейс `IList` определяет и собственные методы:

Элемент интерфейса |	Его тип |	Описание
-- | -- | --
`int Add(object obj)` |	Метод |	Добавляет объект `obj` в вызывающую коллекцию. Возвращает индекс, по которому этот объект сохранен
`void Clear()` |	Метод	| Удаляет все элементы из вызывающей коллекции
`bool Contains(object obj)` |	Метод |	Возвращает значение `true`, если вызывающая коллекция содержит объект, переданный в параметре `obj`, и значение `false` в противном случае
`int` IndexOf(object obj)` |	Метод |	Возвращает индекс объекта `obj`, если он (объект) содержится в вызывающей коллекции. Если объект `obj` не обнаружен, метод возвращает `-1`
`void Insert(int idx, object obj)` |	Метод |	Вставляет в вызывающую коллекцию объект `obj` по индексу, заданному параметром `idx`. Элементы, находившиеся до этого по индексу `idx` и далее, смещаются вперед, чтобы освободить место для вставляемого объекта `obj`
`void Remove(object obj)` |	Метод |	Удаляет первое вхождение объекта `obj` из вызывающей коллекции. Элементы, находившиеся до этого за удаленным элементом, смещаются назад, чтобы ликвидировать образовавшуюся "брешь"
`void RemoveAt(int idx)` |	Метод |	Удаляет из вызывающей коллекции объект, расположенный по индексу, заданному параметром `idx`. Элементы, находившиеся до этого за удаленным элементом, смещаются, ликвидируя образовавшуюся "брешь"
`bool IsFixedSize { get; }` |	Свойство |	Принимает значение `true`, если коллекция имеет фиксированный размер. Это означает, что в такую коллекцию нельзя вставлять элементы и удалять их из нее.
`bool IsReadOnly { get; }` |	Свойство |	Принимает значение `true`, если коллекция предназначена только для чтения.
`object this[int idx] { get; set; }` |	Индексатор |	Используется для считывания или записи значения элемента с индексом `idx`. Нельзя применить для добавления в коллекцию нового элемента.

Интерфейс `IDictionary` наследует интерфейс `ICollection`. Он определяет поведение коллекции, которая устанавливает соответствие между уникальными ключами и значениями. Коллекции, реализующии интерфейс `IDictionary` называют **словарями**. **Ключ** — это объект, который используется для получения соответствующего ему значения. Сохраненную однажды пару можно затем извлечь по заданному ключу.

Элемент интерфейса |	Его тип |	Описание
-- | -- | --
`void Add (object k, object v)` |	метод |	Добавляет в вызывающую коллекцию пару ключ/значение, заданную параметрами `k` и `v`. Ключ `k` не должен быть нулевым. При попытке задать нулевой ключ генерируют исключение типа `NotSupportedException`. Если окажется, что ключ к уже хранится в коллекции, генерируется исключение типа `ArgumentException`
`void Clear()` |	метод |	Удаляет все пары ключ/значение из вызывающей коллекции
`bool Contains(object k)` |	метод |	Возвращает значение `true`, если вызывающая коллекция содержит объект к в качестве ключа. В противном случае возвращает значение `false`
`IDictionaryEnumerator GetEnumerator()` |	метод |	Возвращает нумератор для вызывающей коллекции
`void Remove(object k)` | метод |	Удаляет элемент, ключ которого равен значению `k`
`bool isFixedSize { get }` |	свойство |	Равно значению `true`, если коллекция имеет фиксированный размер
`bool isReadOnly { get }` |	свойство |	Равно значению `true`, если коллекция предназначена только для чтения
`ICollection Keys { get }` |	свойство | Получает коллекцию ключей
`icollection Values { get }` |	свойство |	Получает коллекцию значений
`object this[object key] { get; set; }` |	индексатор |	Этот индексатор можно использовать для получения или установки значения элемента, а также для добавления в коллекцию нового элемента. "Индекс" в данном случае является ключом элемента.

Интерфейс `IDictionaryEnumerator` является производным от интерфейса `IEnumerator` и распространяет свои функциональные возможности нумератора на область словарей.

В интерфейсе `IComparer` определен метод `Compare()`, который позволяет сравнивать два объекта:
```c#
int Compare(object vl, object v2)
```
Метод `Compare()` возвращает положительное число, если значение `vl` больше значения `v2`, отрицательное, если `vl` меньше `v2`, и нуль, если сравниваемые значения равны. Этот интерфейс можно использовать для задания способа сортировки элементов коллекции.

Интерфейс `IHashCodeProvider` должен быть реализован коллекцией, если программисту необходимо определить собственную версию метода `GetHashCode()`.

> **Задание**
>
> Для получения дополнительной информации по данным интерфейсам обратитесь к дополнительной литературе, интернет и документации по С#

### Коллекции
https://intuit.ru/studies/courses/486/342/lecture/8247

В С# под коллекцией понимается некоторая группа объектов. Коллекции упрощают реализацию многих задач программирования, предлагая уже готовые решения для построения структур данных. Все коллекции разработаны на основе четко определенных интерфейсов, поэтому стандартизируют способ обработки группы объектов. Среда .NET Framework поддерживает три основных типа коллекций: *общего назначения*, *специализированные* и *ориентированные на побитовую организацию данных*.

Коллекции общего назначения определены в пространстве имен `System.Collection` и реализуют такие структуры данных, как стеки, очереди, динамические массивы, словари (хеш-таблицы, предназначенные для хранения пар ключ/значение), отсортированный список для хранения пар ключ/значение. Коллекции общего назначения работают с данными типа `object`, поэтому их можно использовать для хранения данных любого типа.

Коллекции специального назначения определены в пространстве имен `System.Collection.Specialized` и ориентированы на обработку данных конкретного типа или на обработку данных уникальным способом. Например, существуют специализированные коллекции, предназначенные только для обработки строк.

В пространстве имен `System.Collection` определена единственная коллекция, ориентированная на побитовую организацию данных, которая служит для хранения групп битов и поддерживает такой набор операций, который не характерен для коллекций других типов.

В данном разделе мы рассмотрим коллекции общего назначения.

> **Замечание**. Перед изучением данного раздела обязательно выполните самостоятельную работу из "Коллекции".

### Коллекции общего назначения
Классы коллекций общего назначения:

Класс |	Описание
-- | --
`Stack` |	**Стек** — частный случай однонаправленного списка, действующий по принципу: последним пришел - первым вышел
`Queue` |	**Очередь** — частный случай однонаправленного списка, действующего по принципу:первым пришел - первым вышел
`ArrayList` |	**Динамический массив**, т.е. массив который при необходимости может увеличивать свой размер
`Hashtable` |	Хеш-таблица для пар ключ/значение
`SortedList` |	Отсортированный список пар ключ/значение

Рассмотрим данные коллекции более подробно.

> **Замечание**. Абстрактный тип данных (АТД) **список** — это последовательность элементов $a_1, а_2,...,а_n (n >= 0)$ одного типа. Количество элементов $n$ называется длиной списка. Если $n > 0$, то $а_1$ называется первым элементом списка, а $а_n$ — последним элементом списка. В случае $n = 0$ имеем пустой список, который не содержит элементов. Важное свойство списка заключается в том, что его элементы линейно упорядочены в соответствии с их позицией в списке. Так элемент $а_i$ предшествует $а_{i+1}$ для $i=1, 2, …n-1$ и $а_i$ следует за $а_{i-1}$ для $i=2, ...n$. Список называется **однонаправленным**, если каждый элемент списка содержит ссылку на следующий элемент. Если каждый элемент списка содержит две ссылки (одну на следующий элемент в списке, вторую — на предыдущий элемент), то такой список называется **двунаправленным** (**двусвязным**). А если последний элемент связать указателем с первым, то получится **кольцевой** список.

### Класс `Stack`
АТД **стек** — это частный случай однонаправленного списка, добавление элементов в который и выборка элементов из которого выполняются с одного конца, называемого **вершиной стека** (**головой** — head ). При выборке элемент исключается из стека. Другие операции со стеком не определены. Говорят, что стек реализует принцип обслуживания LIFO (last in — fist out, последним пришел — первым вышел). Стек проще всего представить себе в виде пирамиды, на которую надевают кольца.

![Stack visual representation](../img/17_01.gif)

Достать первое кольцо можно только после того, как будут сняты все верхние кольца.

В С# реализацию АТД стек представляет класс `Stack`, который реализует интерфейсы `ICollection`, `IEnumerable` и `ICloneable`. `Stack` — это динамическая коллекция, размер которой изменяется.

В классе `Stack` определены следующие конструкторы:
```c#
public Stack(); //создает пустой стек, начальная вместимость которого равна 10
public Stack(int capacity); // создает пустой стек, начальная вместимость которого равна capacity
public Stack(ICollection c); //создает стек, который содержит элементы коллекции, заданной
//параметром с, и аналогичной (аналогичной - с чем?) вместимостью
```
Кроме методов, определенных в интерфейсах, реализуемых классом `Stack`, в этом классе определены собственные методы:

Метод |	Описание
-- | --
`public virtual bool Contains(object v)` |	Возвращает значение `true`, если объект `v` содержится в вызывающем стеке, в противном случае возвращает значение `false`.
`public virtual void Clear()` |	Устанавливает свойство `Сount` равным нулю, тем самым очищая стек.
`public virtual object Peek()` |	Возвращает элемент, расположенный в вершине стека, но не извлекая его из стека
`public virtual object Pop()` |	Возвращает элемент, расположенный в вершине стека, и извлекает его из стека
`public virtual void Push(object v)` |	Помещает объект `v` в стек
`public virtual object[] ToArray()` |	Возвращает массив, который содержит копии элементов вызывающего

Рассмотрим несколько примеров использования стека.

**Пример 1**. Для заданного значения $n$ запишем в стек все числа от $1$ до $n$, а затем извлечем из стека:
```c#
using System;
using System.Collections;

namespace ConsoleApplication
{
 class Program
 {
  public static void Main()
  {
   Console.Write("n= ");
   int n=int.Parse(Console.ReadLine());
   Stack intStack = new Stack();
   for (int i = 1; i <= n; i++)
    intStack.Push(i);
   Console.WriteLine("Размерность стека " + intStack.Count);

   Console.WriteLine("Верхний элемент стека = " + intStack.Peek());
   Console.WriteLine("Размерность стека " + intStack.Count);

   Console.Write("Содержимое стека = ");
   while (intStack.Count != 0)
   Console.Write("{0} ", intStack.Pop());
   Console.WriteLine("\nНовая размерность стека " + intStack.Count);
  }
 }
}
```

**Пример 2**. В текстовом файле содержится математическое выражение. Проверить баланс круглых скобок в данном выражении.
```c#
using System;
using System.Collections;
using System.IO;

namespace MyProgram
{
 class Program
 {
  public static void Main()
  {
   StreamReader fileIn=new StreamReader("t.txt",);
   string line=fileIn.ReadToEnd();
   fileIn.Close();
   Stack skobki=new Stack();
   bool flag=true;
//проверяем баланс скобок
   for ( int i=0; i<line.Length;i++)
   {
    //если текущий символ открывающаяся скобка, то помещаем ее в стек
    if (line[i] == '(') skobki.Push(i);
     else if (line[i] == ')') //если текущий символ закрывающаяся скобка, то
    {
    //если стек пустой, то для закрывающейся скобки не хватает парной открывающейся
    if (skobki.Count == 0)
     { flag = false; Console.WriteLine("Возможно в позиции " + i + "лишняя ) скобка"); }
      else skobki.Pop(); //иначе извлекаем парную скобку
    }
   }
   //если после просмотра строки стек оказался пустым, то скобки сбалансированы
   if (skobki.Count == 0) { if (flag)Console.WriteLine("скобки сбалансированы"); }
   else //иначе баланс скобок нарушен
   {
    Console.Write("Возможно лишняя ( скобка в позиции:");
    while (skobki.Count != 0)
    {
     Console.Write("{0} ", (int)skobki.Pop());
    }
    Console.WriteLine();
   }
  }
 }
}
```
```
________t.txt_________
(1+2)-4*(a-3)/(2-7+6)
```

### Класс `Queue`
АТД **очередь** — это частный случай однонаправленного списка, добавление элементов в который выполняется в один конец (**хвост**), а выборка производится с другого конца (**головы**). Другие операции с очередью не определены. При выборке элемент исключается из очереди. Говорят, что очередь реализует принцип обслуживания FIFO (fist in — fist out, первым пришел — первым вышел). Очередь проще всего представить в виде узкой трубы, в один конец которой бросают мячи, а с другого конца которой они вылетают. Понятно, что мяч, который был брошен в трубу первым, первым и вылетит с другого конца.

![Queue visual representation](../img/17_02.gif)

В С# реализацию АТД очередь представляет класс `Queue`, который также как и стек реализует интерфейсы `ICollection`, `IEnumerable` и `ICloneable`. `Queue` — это динамическая коллекция, размер которой изменяется. При необходимости увеличение вместимости очереди происходит с коэффициентом роста по умолчанию равным 2.0.

В классе Queue определены следующие конструкторы:
```c#
public Queue(); //создает пустую очередь, начальная вместимость которой равна 32
public Queue (int capacity); // создает пустую очередь, начальная вместимость которой равна capacity
//создает пустую очередь, начальная вместимость которой равна capacity, и коэффициент роста
//устанавливается параметром n
public Queue (int capacity, float n);
//создает очередь, которая содержит элементы коллекции, заданной параметром с, и аналогичной
//вместимостью
public Queue (ICollection c);
```
Кроме методов, определенных в интерфейсах, реализуемых классом `Queue`, в этом классе определены собственные методы:

Метод |	Описание
-- | --
`public virtual bool Contains (object v)` |	Возвращает значение `true`, если объект `v` содержится в вызывающей очереди, в противном случае возвращает значение `false`
`public virtual void clear()` |	Устанавливает свойство `Count` равным нулю, тем самым очищая очередь
`public virtual object Dequeue()` |	Возвращает объект из начала вызывающей очереди, удаляя его из очереди
`public virtual object Peek()`	Возвращает объект из начала вызывающей очереди, не удаляя его из очереди
`public virtual void Enqueue(object v)` |	Добавляет объект `v` в конец очереди
`public virtual object [ ] ToArrау()` |	Возвращает массив, который содержит копии элементов из вызывающей очереди
`public virtual void TrimToSize()` |	Устанавливает свойство `Capacity` равным значению свойства `Count`

Рассмотрим несколько примеров использования очереди.

**Пример 1**. Для заданного значения $n$ запишем в очередь все числа от $1$ до $n$, а затем извлечем их из очереди:
```c#
using System;
using System.Collections;
namespace MyProgram
{
 class Program
 {
  public static void Main()
  {
   Console.Write("n= ");
   int n=int.Parse(Console.ReadLine());
   Queue intQ = new Queue();
   for (int i = 1; i <= n; i++)
    intQ.Enqueue(i);
   Console.WriteLine("Размерность очереди " + intQ.Count);

   Console.WriteLine("Верхний элемент очереди = " + intQ.Peek());
   Console.WriteLine("Размерность очереди " + intQ.Count);

   Console.Write("Содержимое очереди = " );
   while (intQ.Count!=0)
    Console.Write("{0} ", intQ.Dequeue());
   Console.WriteLine("\nНовая размерность очереди " + intQ.Count);
  }
 }
}
```

**Пример 2**. В текстовом файле записана информация о людях (фамилия, имя, отчество, возраст, вес через пробел). Вывести на экран вначале информацию о людях младше 40 лет, а затем информацию о всех остальных.
```c#
using System;
using System.Collections;
using System.IO;
using System.Text;

namespace MyProgram
{
 class Program
 {
  public struct one //структура для хранения данных об одном человеке
  {
   public string f;
   public string i;
   public string o;
   public int age;
   public float massa;
  }

  public static void Main()
  {
    StreamReader fileIn = new StreamReader("t.txt",Encoding.GetEncoding(1251));
    string line;
    Queue people = new Queue();
    one a;
    Console.WriteLine("ВОЗРАСТ МЕНЕЕ 40 ЛЕТ");
    while ((line = fileIn.ReadLine()) != null) //читаем до конца файла
    {
     string [] temp = line.Split(' '); //разбиваем строку на составные элементы
     //заполняем структуру
     a.f = temp[0];
     a.i = temp[1];
     a.o = temp[2];
     a.age = int.Parse(temp[3]);
     a.massa = float.Parse(temp[4]);
     // если возраст меньше 40 лет, то выводим данные на экран, иначе помещаем их в
     //очередь для временного хранения
     if (a.age<40)
      Console.WriteLine(a.f + "\t"+ a.i + "\t"+ a.o + "\t"+a.age + "\t" + a.massa);
     else people.Enqueue(a);
    }
    fileIn.Close();

    Console.WriteLine("ВОЗРАСТ 40 ЛЕТ И СТАРШЕ");
    while (people.Count != 0) //извлекаем из очереди данные
    {
     a = (one)people.Dequeue();
     Console.WriteLine(a.f + "\t"+ a.i + "\t"+ a.o + "\t"+a.age + "\t" + a.massa);
    }
  }
 }
}
```
```
_______________t.txt__________________
Иванов Сергей Николаевич 21 64
Петров Игорь Юрьевич 45 88
Семёнов Михаил Алексеевич 20 70
Пиманов Александр Дмитриевич 53 101
```

### Класс `ArrayList`
В С# стандартные массивы имеют фиксированную длину, которая не может измениться во время выполнения программы. Класс `ArrayList` предназначен для поддержки динамических массивов, которые при необходимости могут увеличиваться или сокращаться.

Объект класса `ArrayList` представляет собой массив переменной длины, элементами которого являются объектные ссылки. Любой объект класса `ArrayList` создается с некоторым начальным размером. При превышении этого размера коллекция автоматически удваивается. В случае удаления объектов массив можно сократить.

Класс `ArrayList` реализует интерфейсы `ICollection`, `IList`, `IEnumerable` и `ICloneable`. В классе `ArrayList` определены следующие конструкторы:
```c#
//создает пустой массив с максимальной емкостью равной 16 элементам, при текущей размерности 0
public ArrayList()
public ArrayList(int capacity) //создает массив с заданной емкостью capacity, при текущей размерности 0
public ArrayList(ICollection с) //строит массив, который инициализируется элементами коллекции с
```
Помимо методов, определенных в интерфейсах, которые реализует класс `ArrayList`, в нем определены и собственные методы:

Метод |	Описание
-- | --
`public virtual void AddRange (ICollection с)` |	Добавляет элементы из коллекции `с` в конец вызывающей коллекции
`public virtual int BinarySearch(object v)` |	В вызывающей отсортированной коллекции выполняет поиск значения, заданного параметром `v`. Возвращает индекс найденного элемента. Если искомое значение не обнаружено, возвращает отрицательное значение.
`public virtual int BinarySearch(object v, IComparer comp)` |	В вызывающей отсортированной коллекции выполняет поиск значения, заданного параметром `v`, на основе метода сравнения объектов, заданного параметром `соmp`. Возвращает индекс найденного элемента. Если искомое значение не обнаружено, возвращает отрицательное значение.
`public virtual int BinarySearch(int startldx, int count, object v, IComparer comp)` | В вызывающей отсортированной коллекции выполняет поиск значения, заданного параметром `v`, на основе метода сравнения объектов, заданного параметром `comp`. Поиск начинается с элемента, индекс которого равен значению `startIdx`, и включает `count` элементов. Метод возвращает индекс найденного элемента. Если искомое значение не обнаружено, возвращает отрицательное значение.
`public virtual void CopyTo(Array ar, int startIdx)` |	Копирует содержимое вызывающей коллекции, начиная с элемента, индекс которого равен значению `startIdx`, в массив, заданный параметром `аr`. Приемный массив должен быть одномерным и совместимым по типу с элементами коллекции.
`public virtual void CopyTo(int srcldx, Array ar, int destIdx, int count)` |	Копирует count элементов вызывающей коллекции, начиная с элемента, индекс которого равен значению `srcIdx`, в массив, заданный параметром `аr`, начиная с элемента, индекс которого равен значению `destIdx`. Приемный массив должен быть одномерным и совместимым по типу с элементами коллекции
`public virtual ArrayList GetRange(int idx, int count)` |	Возвращает часть вызывающей коллекции типа `ArrayList`. Диапазон возвращаемой коллекции начинается с индекса `idx` и включает `count` элементов. Возвращаемый объект ссылается на те же элементы, что и вызывающий объект
`public static ArrayList FixedSize(ArrayList ar)` |	Превращает коллекцию `ar` в `ArrayList`-массив с фиксированным размером и возвращает результат
`public virtual void InsertRange(int startldx, ICollection c)` |	Вставляет элементы коллекции, заданной параметром `с`, в вызывающую коллекцию, начиная с индекса, заданного параметром `startIdx`
`public virtual int LastlndexOf(object v)` |	Возвращает индекс последнего вхождения объекта `v` в вызывающей коллекции. Если искомый объект не обнаружен, возвращает отрицательное значение
`public static ArrayList Readonly(ArrayList ar)` |	Превращает коллекцию `ar` в `ArrayList`-массив, предназначенный только для чтения
`public virtual void RemoveRange(int idx, int count)` |	Удаляет `count` элементов из вызывающей коллекции, начиная с элемента, индекс которого равен значению `idx`
`public virtual void Reverse()` |	Располагает элементы вызывающей коллекции в обратном порядке
`public virtual void Reverse(int startldx, int count)` |	Располагает в обратном порядке `count` элементов вызывающей коллекции, начиная с индекса `startldx`
`public virtual void SetRange(int startldx, ICollection c)` |	Заменяет элементы вызывающей коллекции, начиная с индекса `startldx`, элементами коллекции, заданной параметром `с`
`public virtual void Sort()` |	Сортирует коллекцию по возрастанию
`public virtual void Sort(IComparer comp)` |	Сортирует вызывающую коллекцию на основе метода сравнения объектов, заданного параметром `comp`. Если параметр `comp` имеет нулевое значение, для каждого объекта используется стандартный метод сравнения
`public virtual void Sort(int startidx, int endidx, icomparer comp)` |	Сортирует часть вызывающей коллекции на основе метода сравнения объектов, заданного параметром `comp`. Сортировка начинается с индекса `startidx` и заканчивается индексом `endidx`. Если параметр `comp` имеет нулевое значение, для каждого объекта используется стандартный метод сравнения
`public virtual object [ ] ToArray()` |	Возвращает массив, который содержит копии элементов вызывающего объекта
`public virtual Array ToArray(Type type)` |	Возвращает массив, который содержит копии элементов вызывающего объекта. Тип элементов в этом массиве задается параметром `type`
`public virtual void TrimToSize()` |	Устанавливает свойство `Capacity` равным значению свойства `Count`

Свойство `Capacity` позволяет узнать или установить емкость вызывающего динамического массива типа `ArrayList`. Емкость представляет собой количество элементов, которые можно сохранить в `ArrayList`-массиве без его увеличения. Если вам заранее известно, сколько элементов должно содержаться в `ArrayList`-массиве, то размерность массива можно установить используя свойство `Capacity`, сэкономив тем самым системные ресурсы. Если нужно уменьшить размер `ArrayList`-массива, то путем установки свойства `Capacity` можно сделать его меньшим. Но устанавливаемое значение не должно быть меньше значения свойства `Count`, иначе будет сгенерировано исключение `ArgumentOutOfRangeException`. Чтобы сделать емкость `ArrayList`-массива равной действительному количеству элементов, хранимых в нем в данный момент, установите свойство `Capacity` равным свойству `Count`. Того же эффекта можно добиться, вызвав метод `TrimToSize()`.

Рассмотрим несколько примеров использования динамического массива.
```c#
using System;
using System.Collections;

namespace MyProgram
{
 class Program
 {
  static void ArrayPrint(string s, ArrayList a)
  {
   Console.WriteLine(s);
   foreach (int i in a)
    Console.Write(i + " ");
   Console.WriteLine();
  }

  static void Main(string[] args)
  {
   ArrayList myArray = new ArrayList();
   Console.WriteLine("Начальная емкость массива: " + myArray.Capacity);
   Console.WriteLine("Начальное количество элементов: " + myArray.Count);

   Console.WriteLine("\nДобавили 5 цифр");
   for (int i = 0; i < 5; i++) myArray.Add(i);
   Console.WriteLine("Текущая емкость массива: " + myArray.Capacity);
   Console.WriteLine("Текущее количество элементов: " + myArray.Count);
   ArrayPrint("Содержимое массива", myArray);

   Console.WriteLine("\nОптимизируем емкость массива");
   myArray.Capacity=myArray.Count;
   Console.WriteLine("Текущая емкость массива: " + myArray.Capacity);
   Console.WriteLine("Текущее количество элементов: " + myArray.Count);
   ArrayPrint("Содержимое массива", myArray);

   Console.WriteLine("\nДобавляем элементы в массив");
   myArray.Add(10);
   myArray.Insert(1, 0);
   myArray.AddRange(myArray);
   Console.WriteLine("Текущая емкость массива: " + myArray.Capacity);
   Console.WriteLine("Текущее количество элементов: " + myArray.Count);
   ArrayPrint("Содержимое массива", myArray);

   Console.WriteLine("\nУдаляем элементы из массива");
   myArray.Remove(0);
   myArray.RemoveAt(10);
   Console.WriteLine("Текущая емкость массива: " + myArray.Capacity);
   Console.WriteLine("Текущее количество элементов: " + myArray.Count);
   ArrayPrint("Содержимое массива", myArray);

   Console.WriteLine("\nУдаляем весь массив");
   myArray.Clear();
   Console.WriteLine("Текущая емкость массива: " + myArray.Capacity);
   Console.WriteLine("Текущее количество элементов: " + myArray.Count);
   ArrayPrint("Содержимое массива", myArray);
  }
 }
}
```

**Пример 2**. В текстовом файле записана информация о людях (фамилия, имя, отчество, возраст, вес через пробел). Вывести на экран информацию о людях, отсортированную по возрасту.
```c#
using System;
using System.Collections;
using System.IO;
using System.Text;

namespace MyProgram
{
 class Program
 {
  public struct one //структура для хранения данных об одном человеке
  {
   public string f;
   public string i;
   public string o;
   public int age;
   public float massa;
  }

  public class SortByAge : IComparer //реализация стандартного интерфейса
  {
   int IComparer.Compare(object x, object y)  //переопределение метода Compare
   {
    one t1 = (one)x;
    one t2 = (one)y;
    if (t1.age > t2.age) return 1;
    if (t1.age < t2.age) return -1;
    return 0;
   }
  }

  static void ArrayPrint(string s, ArrayList a)
  {
   Console.WriteLine(s);
   foreach (one x in a)
    Console.WriteLine(x.f + "\t"+ x.i + "\t"+ x.o + "\t"+x.age + "\t" + x.massa);
  }

  static void Main(string[] args)
  {
    StreamReader fileIn = new StreamReader("t.txt",Encoding.GetEncoding(1251));
    string line;
    one a;
    ArrayList people = new ArrayList();
    string[] temp = new string[5];
    while ((line=fileIn.ReadLine())!=null) //цикл для организации обработки файла
    {
     temp = line.Split(' ');
     a.f = temp[0];
     a.i = temp[1];
     a.o = temp[2];
     a.age = int.Parse(temp[3]);
     a.massa = float.Parse(temp[4]);
     people.Add(a);
    }
    fileIn.Close();

    ArrayPrint("Исходные данные: ", people);
    people.Sort(new Program.SortByAge());  //вызов сортировки
    ArrayPrint("Отсортированные данные: ", people);
  }
 }
}
```
```
______________t.txt________________
Иванов Сергей Николаевич 21 64
Петров Игорь Юрьевич 45 88
Семёнов Михаил Алексеевич 20 70
Пиманов Александр Дмитриевич 53 101
```

> **Замечание**. Обратите внимание на то, что в данном примере был разработан вложенный класс `SortByAge`, реализующий стандартный интерфейс `IComparer`. В этом классе был перегружен метод `Compare`, позволяющий сравнивать между собой два объекта типа one. Созданный класс использовался для сортировки коллекции по заданному критерию (по возрасту).

### Класс `Hashtable`
Класс `Hashtable` предназначен для создания коллекции, в которой для хранения объектов используется хеш-таблица. В хеш-таблице для хранения информации используется механизм, именуемый **хешированием** (hashing). Суть хеширования состоит в том, что для определения уникального значения, которое называется хеш-кодом, используется информационное содержимое соответствующего ему ключа. Хеш-код затем используется в качестве индекса, по которому в таблице отыскиваются данные, соответствующие этому ключу. Преобразование ключа в хеш-код выполняется автоматически, т.е. сам хеш-код вы даже не увидите. Но преимущество хеширования — в том, что оно позволяет сокращать время выполнения таких операций, как поиск, считывание и запись данных, даже для больших объемов информации.

Класс `Hashtable` реализует стандартные интерфейсы `IDictionary`, `ICollection`, `IEnumerable`, `ISerializable`, `IDeserializationCallback` и `ICloneable`. Размер хеш-таблицы может динамически изменяться. Размер таблицы увеличивается тогда, когда количество элементов превышает значение, равное произведению вместимости таблицы и ее коэффициента заполнения, который может принимать значение на интервале от 0,1 до 1,0. По умолчанию установлен коэффициент равный 1,0.

В классе `Hashtable` определено несколько конструкторов:
```c#
public Hashtable()   //создает пустую хеш-таблицу
// строит хеш-таблицу, которая инициализируется элементами коллекции с
public Hashtable(IDictionary с)
public Hashtable(int capacity) //создает хеш-таблицу с вместимостью capacity
//создает хеш-таблицу вместимостью capacity и коэффициентом заполнения n
public Hashtable(int capacity, float n)
```
Помимо методов, определенных в интерфейсах, которые реализует класс `Hashtable`, в нем определены и собственные методы:

Метод |	Описание
-- | --
`public virtual bool ContainsKey(object k)` |	Возвращает значение `true`, если в вызывающей хеш-таблице содержится ключ, заданный параметром `k`. В противном случае возвращает значение `false`
`public virtual bool ContainsValue(object v)` |	Возвращает значение `true`, если в вызывающей хеш-таблице содержится значение, заданное параметром `v`. В противном случае возвращает значение `false`
`public virtual IDictionaryEnumerator GetEnumerator()` |	Возвращает для вызывающей хеш-таблицы нумератор типа `IDictionaryEnumerator`

В классе `Hashtable`, помимо свойств, определенных в реализованных им интерфейсах, определены два собственных `public`-свойства:
```c#
public virtual ICollection Keys { get; } //позволяет получить коллекцию ключей
public virtual ICollection Values { get; } //позволяет получить коллекцию значений
```
Для добавления элемента в хеш-таблицу необходимо вызвать метод `Add()`, который принимает два отдельных аргумента: ключ и значение. Важно отметить, что хеш-таблица не гарантирует сохранения порядка элементов, т.к хеширование обычно не применяется к отсортированным таблицам.

Рассмотрим пример, который демонстрирует использование `Hashtable` коллекции:

**Пример 1**: рассмотрим простые операции с хеш-таблицей
```c#
using System;
using System.Collections;

namespace MyProgram
{
 class Program
 {
  static void printTab(string s, Hashtable a)
  {
   Console.WriteLine(s);
   ICollection key = a.Keys; //Прочитали все ключи
   foreach (string i in key)//использование ключа для получения значения
   {
    Console.WriteLine(i+"\t"+a[i]);
   }
   Console.WriteLine();
  }

  static void Main(string[] args)
  {
   Hashtable tab = new Hashtable();
   Console.WriteLine("Начальное количество элементов: " + tab.Count);
   printTab("Содержимое таблицы: ", tab);

   Console.WriteLine("Добавили в таблицу записи");
   tab.Add("001","ПЕРВЫЙ");
   tab.Add("002","ВТОРОЙ");
   tab.Add("003","ТРЕТИЙ");
   tab.Add("004", "ЧЕТВЕРТЫЙ");
   tab.Add("005", "ПЯТЫЙ");
   Console.WriteLine("Текущее количество элементов: " + tab.Count);
   printTab("Содержимое заполненной таблицы", tab);
   tab["005"] = "НОВЫЙ ПЯТЫЙ";
   tab["001"] = "НОВЫЙ ПЕРВЫЙ";
   printTab("Содержимое измененной таблицы", tab);
  }
 }
}
```

**Пример 2**. Разработаем простейшую записную книжку, в которую можно добавлять и удалять телефоны, а также осуществлять поиск номера телефона по фамилии и фамилии по номеру телефона.
```c#
using System;
using System.Collections;
using System.IO;
using System.Text;

namespace MyProgram
{
 class Program
 {
  static void printTab(string s, Hashtable a)
  {
   Console.WriteLine(s);
   ICollection key = a.Keys; //Прочитали все ключи
   foreach (string i in key)//использование ключа для получения значения
   {
    Console.WriteLine(i + "\t" + a[i]);
   }
  }

  static void Main(string[] args)
  {
    StreamReader fileIn = new StreamReader("t.txt",Encoding.GetEncoding(1251));
    string line;
    Hashtable people = new Hashtable();
    while ((line = fileIn.ReadLine()) != null) //цикл для организации обработки файла
    {
     string [] temp = line.Split(' ');
     people.Add(temp[0],temp[1]);
    }
    fileIn.Close();
    printTab("Исходные данные: ", people);

    Console.WriteLine("Введите номер телефона");
    line = Console.ReadLine();
    if (people.ContainsKey(line)) Console.WriteLine(line + "\t" + people[line]);
    else
    {
     Console.WriteLine("Такого номера нет в записной книжке.\nВведите фамилию: ");
     string line2=Console.ReadLine();
     people.Add(line,line2);
    }
    printTab("Исходные данные: ", people);

    Console.WriteLine("Введите фамилию для удаления");
    line = Console.ReadLine();
    if (people.ContainsValue(line))
    {
     ICollection key =people.Keys; //Прочитали все ключи
     Console.WriteLine(line);
     string del="";
     foreach (string i in key)//использование ключа для получения значения
      if (string.Compare((string)people[i], line) == 0)
      {
       del = i;
       break;
      }

     Console.WriteLine(del + "\t" + people[del] + "- данные удалены!!!");
     people.Remove(del);
     printTab("Измененные данные: ", people);
    }
    else Console.WriteLine("Такого абонента в записной книжке нет ");
  }
 }
}
```
```
_________t.txt____________
12-34-56 Иванов
78-90-12 Петров
34-56-78 Семёнов
90-11-12 Пиманов
```

## 31. Базовые понятия ООП: объект, его свойства и методы, класс. Основные принципы ООП: инкапсуляция, наследование, полиморфизм.
https://intuit.ru/studies/courses/486/342/lecture/8227

В основе языка С# лежит технология объектно-ориентированного программирования (ООП). Все программы на языке С# в большей или меньшей степени являются объектно-ориентированными, поэтому, приступая к написанию даже самой простой программы, нужно познакомиться с основными понятиями в рамках ООП.

ООП основано на таких понятиях как "класс", "объект", "интерфейс", "инкапсуляция", "наследование", "полиморфизм", "событие".

**Объект в программе** — это абстракция реального объекта. Объект обладает атрибутами, поведением и индивидуальностью. Атрибуты определяют основные черты объекта, поведение — действия над объектом, индивидуальность — отличие одного объекта от другого с такими же атрибутами по их конкретным значениям. Например: два кота, у обоих есть шерсть, но у одного шерсть черного цвета, у другого — рыжая.

**Класс** – это множество объектов с одинаковыми атрибутами и поведением, представляемое в языке программирования в виде абстрактного типа данных, который включает в себя члены класса. Рассмотрим некоторые из них:

- **поля** – непосредственно данные определенного типа для описания атрибутов;
- **методы** — функции, предназначенные для обработки внутренних данных объекта данного класса;
- **свойства** – это специальные поля данных, с помощью которых, можно управлять поведением объектов данного класса.

Класс служит образцом для создания объектов или, другими словами, объект является экземпляром класса.

Важным свойством объекта является его обособленность. Детали реализации объекта, то есть внутренние структуры данных и алгоритмы их обработки, скрыты от пользователя и недоступны для непреднамеренного изменения. Объект используется через его **интерфейс** — совокупность правил доступа. Скрытие деталей реализации называется **инкапсуляцией**.

В ООП данные и методы одного класса могут передаваться другим классам с помощью механизма **наследования**. Порожденный класс (**потомок**), наследующий характеристики другого класса, обладает теми же возможностями, что и класс (**предок**), от которого он порожден. При этом класс-предок остается без изменения, а классу-потомку можно добавлять новые элементы (поля, методы, свойства) или изменять унаследованные методы. Благодаря этому класс-потомок обладает большими возможностями, чем предок. Так, например, все классы порождены от корневого класса `System.Object`.

Классы-потомки некоторого класса являются разновидностями этого класса-предка. (Другими словами, класс-предок является обобщением своих потомков). Это означает, что к объектам классов-потомков можно обращаться с помощью одного и того же имени (но при этом могут выполняться различные действия) — что составляет суть **полиморфизма**. Чаще всего понятие полиморфизма связывают с механизмом виртуальных методов, который мы рассмотрим позднее.

Программу, построенную на принципах ООП, можно представить как совокупность взаимодействующих объектов. Объект А воздействует на объект Б, и для Б возникает событие, на которое Б отреагирует либо ответным воздействием на А, либо воздействием на объект В. Если А — внешний для системы объект, то Б — интерфейсный объект (отвечающий за взаимодействие системы с внешним миром).

**Операционная система Windows** — объектно-ориентированная система, в которой определены классы для производства объектов, обеспечивающих, в частности, интерфейс с пользователем. Программа, написанная под Windows, обращается к ней, командуя какой интерфейсный объект на каком именно месте создать — так строится внешний вид (**интерфейс**) программы. Эти интерфейсные объекты кажутся принадлежащими программе, но на самом деле они — часть Windows: именно она отвечает за их базовый внешний вид и поведение. Поэтому, когда пользователь воздействует на интерфейсный объект программы (нажимает кнопку, выбирает пункт меню и т.п.), для этого объекта происходит *событие* и Windows переводит это событие в сообщение для программы. При написании программы предусматривается однозначная *реакция* на это сообщение в виде *метода*, а в методе вызываются методы других объектов. Т.е. воздействие на *интерфейсный объект* приводит к появлению в недрах Windows сообщения, которое, приходя в программу, запускает цепочку взаимодействий внутренних для нее объектов. Таким образом, ООП программа фактически встраивается в ОС Windows.

Вспомним нашу первую программу:
```c#
class Program	//класс
{
 static void Main () //метод класса
  {
   Console.WriteLine("Hello!!!");
  }
}
```
Программа содержит класс `Program` с единственным статическим (`static`) методом `Main`, что позволяет обращаться к данному методу класса без создания его экземпляра.

## 32.Классы в С#.
https://intuit.ru/studies/courses/486/342/lecture/8242

### Основные понятия
**Класс** — это обобщенное понятие, определяющие характеристики и поведение некоторого множества объектов, называемых экземплярами класса. "Классический" класс содержит данные, определяющие *свойства объектов класса*, и методы, определяющие их поведение. Для Windows-приложений в класс добавляется третья составляющая — события, на которые может *реагировать объект класса*. Все классы библиотеки .Net, а также все классы, которые создает программист в среде .Net, имеют одного общего предка — класс `object`.

Все программы, рассмотренные ранее, состояли из одного класса с одним методом `Main` и несколькими вспомогательными статическими методами. Теперь рассмотрим понятие "класс" более подробно.

Описание класса содержит ключевое слово `class`, за которым следует его *имя*, а далее в фигурных скобках — *тело* класса. Кроме того, для класса можно задать его базовые классы (предки) и ряд необязательных атрибутов и спецификаторов, определяющих различные характеристики класса:
```c#
[ атрибуты ] [ спецификаторы ] class имя_класса [ : предки ]
{тело_класса}
```
Простейший пример класса:
```c#
class Demo{}
```
Спецификаторы определяют свойства класса, а также доступность класса для других элементов программы. Возможные значения спецификаторов перечислены в следующей таблице:

№ |	Спецификатор |	Описание
-- | -- | --
1 |	`new` |	Задает новое описание класса взамен унаследованного от предка. Используется для вложения классов (в иерархии объектов).
2 |	`public` |	Доступ к классу не ограничен
3 |	`protected` |	Доступ только из данного или производного класса. Используется для вложенных классов.
4 |	`internal` |	Доступ только из данной программы (сборки).
5 |	`protected internal` |	Доступ только из данного и производного класса и из данной программы (сборки).
6 |	`private` |	Доступ только из элементов класса, внутри которых описан данный класс. Используется для вложенных классов.
7 |	`static` |	Статический класс. Позволяет обращатся к методам класса без создания экземпляра класса
8 |	`sealed` |	Бесплодный класс. Запрещает наследование данного класса. Применяется в иерархии объектов.
9 |	`abstract` |	Абстрактный класс. Применяется в иерархии объектов.

Спецификаторы 2-6 называются *спецификаторами доступа*. Они определяют, откуда можно непосредственно обращаться к данному классу. Спецификаторы доступа могут комбинироваться с остальными спецификаторами.

> **Замечание**. Атрибуты будут рассмотрены позже.

Класс можно описывать непосредственно внутри пространства имен или внутри другого класса. В последнем случае класс называется вложенным. В зависимости от места описания класса некоторые из этих спецификаторов могут быть запрещены. В данном разделе мы рассмотрим классы, которые описываются непосредственно в пространстве имен. Для таких классов допускаются только два спецификатора: `public` и `internal`. По умолчанию, то есть если ни один спецификатор доступа не указан, подразумевается спецификатор `internal`.

Объекты создаются явным или неявным образом, то есть либо программистом, либо системой. Программист создает экземпляр класса с помощью операции new, например:
```c#
Demo a = new Demo (); // Создается экземпляр класса Demo
```
Если достаточный для хранения объекта объем памяти выделить не удалось, то генерируется исключение `OutOfMemoryException`.

Для каждого объекта при его создании в памяти выделяется отдельная область, в которой хранятся его данные. В классе могут присутствовать *статические элементы*, которые существуют в единственном экземпляре для всех объектов класса. Статические данные часто называют **данными класса**, а остальные — **данными экземпляра**. Для работы с данными класса используются *статические методы класса*, для работы с данными экземпляра — *методы экземпляра*, или просто методы.

До сих пор мы использовали в программах только данные (переменные и константы) и методы. В общем случае класс может содержать следующие функциональные элементы:

1. Данные: переменные или константы.
2. Методы, реализующие не только вычисления, но и другие действия, выполняемые классом или его экземпляром.
3. Конструкторы (реализуют действия по *инициализации экземпляров* или класса в целом).
4. Свойства (определяют характеристики класса в соответствии со способами их задания и получения).
5. Деструкторы (определяют действия, которые необходимо выполнить до того, как объект будет уничтожен).
6. Индексаторы (обеспечивают возможность доступа к элементам класса по их порядковому номеру).
7. Операции (задают действия с объектами с помощью знаков операций).
8. События (определяют уведомления, которые может генерировать класс).
9. Типы (типы данных, внутренние по отношению к классу).

В данном разделе мы рассмотрим первые четыре категории элементов класса

Прежде чем приступить к проектированию классов, необходимо поговорить о присваивании и сравнении объектов. Механизм выполнения присваивания один и тот же для величин любого типа, как ссылочного, так и размерного, однако результаты различаются. При присваивании значения копируется значение, а при присваивании ссылки — ссылка, поэтому после присваивания одного объекта другому мы получим две ссылки, указывающие на одну и ту же область памяти:

![Присвоение](../img/13_01.gif)

Пусть были созданы три объекта `а`, `b` и `с`, а затем выполнено присваивание `b = с`. Теперь ссылки `b` и `с` указывают на один и тот же объект. Старое значение `b` становится недоступным и очищается сборщиком мусора.

Аналогичная ситуация с операцией проверки на равенство. Величины *значимого типа* равны, если равны их значения. Величины ссылочного типа равны, если они ссылаются на одни и те же данные. Так, объекты `b` и `с` равны, т.к. они ссылаются на одну и ту же область памяти. Но `а` не равно `b` даже при равенстве их значений.

### Данные: поля и константы
Данные, содержащиеся в классе, могут быть *переменными* или *константами* и задаются в соответствии с правилами, рассмотренными в теме "Идентификаторы". При описании данных также можно указывать атрибуты и спецификаторы, задающие различные характеристики элементов. Синтаксис описания элемента данных приведен ниже:
```c#
[атрибуты] [спецификаторы] [const] тип имя [ = начальное_значение ]
```
Рассмотрим возможные спецификаторы для данных:

№ |	Спецификатор |	Описание
-- | -- | --
1 |	`new` |	Новое описание поля, скрывающее унаследованный элемент класса
2 |	`public` |	Доступ к элементу не ограничен
3 |	`protected` |	Доступ только из данного и производных классов
4 |	`internal` |	Доступ только из данной сборки
5 |	`protected internal`	Доступ только из данного и производных классов и из данной сборки
6 |	`private`	Доступ только из данного класса
7 |	`static` |	Одно поле для всех экземпляров класса
8 |	`readonly` |	Поле доступно только для чтения (значение таких полей можно установить либо при описании, либо в конструкторе)
9 |	`volatile` |	Поле может изменяться другим процессом или системой

> **Замечание**. Атрибуты будут рассмотрены позже.

Для констант можно использовать только спецификаторы 1-6.

По умолчанию элементы класса считаются закрытыми `private`. Для полей класса этот вид доступа является предпочтительным, поскольку поля определяют внутреннее строение класса, которое должно быть скрыто от пользователя. Все методы класса имеют непосредственный доступ к его закрытым полям.

Поля, описанные со спецификатором `static`, а также константы существуют в единственном экземпляре для всех объектов класса, поэтому к ним обращаются не через имя экземпляра, а через имя класса. Обращение к полю класса выполняется с помощью операции доступа (точка). Справа от точки задается имя поля, слева — имя экземпляра для обычных полей или имя класса для статических. Рассмотрим пример создания класса `Demo` и два способа обращения к его полям.
```c#
class Circle
{
 public int x=0;
 public int y=0;
 public int radius=3;
 public const double pi = 3.14;
 public static string name = "Окружность";
 double p;
 double s;
}

class Program
{
 static void Main()
 {
  Circle cr = new Circle();   //создание экземпляра класса
  Console.WriteLine("pi=" + Circle.pi);// обращение к константе
  Console.Write(Circle.name);// обращение к статическому полю
  //обращение к обычным полям
  Console.WriteLine(" с центром в точке ({0},{1}) и радиусом {2}", cr.x, cr.y, cr.radius);
  // Console.WriteLine(cr.p); - вызовет ошибку, т.к. поле p имеет тип private

  Console.Write("Введите коэффициент= ");
  int kof = int.Parse(Console.ReadLine());
  cr.x -= kof; cr.y += kof; cr.radius *= kof;
  Console.WriteLine(" Новая окружность с центром в точке ({0},{1}) и радиусом {2}",
  cr.x, cr.y, cr.radius);
  //cr.s = 2 * Circle.pi * cr.radius; - вызовет ошибку, т.к. поле s имеет тип private
 }
}
```

### Методы
> **Замечание**. Создание и использование методов было рассмотрено нами ранее. Теперь рассмотрим использование методов в контексте создания классов.

Методы находятся в памяти в единственном экземпляре и используются всеми объектами одного класса совместно, поэтому необходимо обеспечить работу методов нестатических экземпляров с полями именно того объекта, для которого они были вызваны. Для этого в любой нестатический метод автоматически передается скрытый параметр `this`, в котором хранится ссылка на вызвавший функцию экземпляр.

В явном виде параметр `this` применяется для того, чтобы возвратить из метода ссылку на вызвавший объект, а также для идентификации поля в случае, если его имя совпадает с именем параметра метода, например:
```c#
class Circle
{
 public int x=0;
 public int y=0;
 public int radius=3;
 public const double pi = 3.14;
 public static string name = "Окружность";
  public Circle T() //метод возвращает ссылку на экземпляр класса
 {
  return this;
 }
 public void Set(int x, int y, int r)
 {
  this.x = x;
  this.y = y;
 radius=r;
 }
}

class Program
{
 static void Main()
 {
  Circle cr = new Circle();   //создание экземпляра класса
  Console.WriteLine("pi=" + Circle.pi);// обращение к константе
  Console.Write(Circle.name);// обращение к статическому полю
  //обращение к обычным полям
  Console.WriteLine(" с центром в точке ({0},{1}) и радиусом {2}", cr.x, cr.y, cr.radius);
  cr.Set(1, 1, 10);
  Console.WriteLine("Новая окружность с центром в точке ({0},{1}) и радиусом {2}", cr.x, cr.y, cr.radius);
  Circle b=cr.T();//получаем ссылку на объект cr, аналог b=c
  Console.WriteLine("Новая ссылка на окружность с центром в точке ({0},{1}) и радиусом {2}", b.x, b.y, b.radius);
  }
}
```

### Конструкторы
Конструктор предназначен для инициализации объекта. Конструкторы делятся на конструкторы класса (для статических классов) и конструкторы экземпляра класса (всех остальных классов).

#### Конструкторы экземпляра
Конструктор экземпляра вызывается автоматически при создании объекта класса с помощью операции `new`. Имя конструктора совпадает с именем класса. Рассмотрим основные свойства конструкторов:

1. Конструктор не возвращает значение, даже типа `void`.
2. Класс может иметь несколько конструкторов с разными параметрами для разных видов инициализации.
3. Если программист не указал ни одного конструктора или какие-то поля не были инициализированы, полям значимых типов присваивается нуль, полям ссылочных типов — значение `null`.

До сих пор мы задавали начальные значения полей класса при описании класса. Это удобно в том случае, когда для всех экземпляров класса начальные значения некоторого поля одинаковы. Если же при создании объектов требуется присваивать полю разные значения, это следует делать с помощью явного задания конструктора. В следующем примере добавлен конструктор и метод `Print` для вывода информации об объекте:
```c#
class Circle
 {
  public int x;
  public int y;
  public int radius;
  public const double pi = 3.14;
  public static string name = "Окружность";
  public Circle(int x, int y, int r)//конструктор
  {
   this.x = x;
   this.y = y;
   radius = r;
  }
  public void Print()
  {
   Console.Write(name);
   Console.WriteLine(" с центром в точке ({0},{1}) и радиусом {2}", x, y, radius);
   Console.WriteLine();
  }
 }

 class Program
 {
  static void Main()
  {
   Circle a = new Circle(0, 0, 1);   //вызов конструктора
   a.Print();
   Circle b=new Circle(10, 10, 5);//вызов конструктора
   b.Print();
  }
 }
```

Часто бывает удобно задать в классе несколько конструкторов, чтобы обеспечить возможность инициализации объектов разными способами. Для этого конструкторы должны иметь разные сигнатуры. Рассмотрим это на примере:
```c#
class Circle
 {
  public int x;
  public int y;
  public int radius;
  public const double pi = 3.14;
  public static string name = "Окружность";
  public Circle(int x, int y, int r)//конструктор 1
  {
   this.x = x;
   this.y = y;
   radius = r;
  }
  public Circle(int r)//конструктор 2
  {
   radius = r;
  }
  public void Print()
  {
   Console.Write(name);
   Console.WriteLine(" с центром в точке ({0},{1}) и радиусом {2}", x, y, radius);
   Console.WriteLine();
  }
 }

 class Program
 {
  static void Main()
  {
   Circle a = new Circle(0, 0, 1);   //вызов конструктора 1
   a.Print();
   Circle b=new Circle(5);//вызов конструктора 2
   b.Print();
  }
 }
```

Обратите внимание на то, что в конструкторе 2 не были инициализированы поля `x`, `y`, поэтому им присваивается значение `0`.

Если один из конструкторов выполняет какие-либо действия, а другой должен делать то же самое плюс еще что-нибудь, то удобно вызвать первый конструктор из второго. Для этого используется уже известное вам ключевое слово `this` в другом контексте, например:
```c#
public Circle(int x, int y, int r):this(r)  //конструктор 1
{
 this.x = x;
 this.y = y;
}

public Circle(int r)    //конструктор 2
{
 radius = r;
}
```

Конструкция, находящаяся после двоеточия, называется инициализатором, то есть тем кодом, который исполняется до начала выполнения тела конструктора. В нашем случае конструктор 1 до выполнения своего кода вызывает конструктор 2.

#### Конструкторы класса
Статические классы содержат только статические члены, в том числе и конструктор, которые хранятся в памяти в единственном экземпляре. Поэтому создавать экземпляры класса нет смысла.

Чтобы подчеркнуть этот факт, в первой версии С# для статических классов создавали два конструктора, один — пустой закрытый (private) конструктор, второй — статический конструктор, не имеющий параметров. Первый конструктор предотвращал попытки создания экземпляров класса. Второй конструктор автоматически вызывается системой до первого обращения к любому элементу статического класса, выполняя необходимые действия по инициализации. Вышесказанное отражено в следующем примере:
```c#
class Demo
{
  static int a;
  static int b;
  private Demo(){}   //закрытый конструктор
  static Demo()       //статический конструктор
  {
   a=10;
   b=2;
  }
  public static void Print ()
  {
   Console.WriteLine("{0}+{1}={2}",a,b,a+b);
   Console.WriteLine("{0}*{1}={2}",a,b,a*b);
   Console.WriteLine("{0}-{1}={2}",a,b,a-b);
  }
}

class Program
{
 static void Main()
 {
  //Demo S=new Demo();    //ошибка содать экземпляр класса нельзя
  Demo.Print();
 }
}
```

В версию 2.0 введена возможность описывать статический класс, то есть класс с модификатором `static`. Экземпляры такого класса создавать запрещено, и кроме того, от него запрещено наследовать. Все элементы такого класса должны явным образом объявляться с модификатором `static` (константы и вложенные типы классифицируются как статические элементы автоматически). Конструктор экземпляра для статического класса задавать запрещается.
```c#
static class Demo
{
  static int a=20;
  static int b=10;
  public static void Print ()
  {
    Console.WriteLine("{0}+{1}={2}",a,b,a+b);
    Console.WriteLine("{0}*{1}={2}",a,b,a*b);
    Console.WriteLine("{0}-{1}={2}",a,b,a-b);
  }
}

class Program
{
  static void Main()
  {
    Demo.Print();
  }
}
```

### Свойства
Иногда требуется создать поле, которое с одной стороны, должно быть доступно для использования, с другой стороны, возможность что-то сделать с этим полем имеет ограничения. Например, полю нельзя присваивать произвольное значение, а только значения из какого-то диапазона. Свойство предлагает простой и удобный способ решения этой проблемы.

Синтаксис свойства:
```c#
[атрибуты] [спецификаторы] тип имя_свойства
{
   [get код_доступа]
   [set код_доступа]
}
```

Значения спецификаторов для свойств и методов аналогичны. Чаще всего свойства объявляются как открытые (со спецификатором `public`).

Код доступа представляет собой блоки операторов, которые выполняются при получении ( `get`) или установке (`set`) свойства. Может отсутствовать либо часть `get`, либо `set`, но не обе одновременно. Если отсутствует часть `set`, то свойство доступно только для чтения. Если отсутствует часть `get`, то свойство доступно только для записи.

Рассмотрим пример работы со свойствами, обращая внимание на то, что синтаксически чтение и запись свойства выглядят почти как методы. При этом `get` должен содержать оператор `return`, возвращающий выражение, для типа которого должно существовать неявное преобразование к типу свойства.
```c#
class Circle
 {
  //закрытые поля
  int x;
  int y;
  int radius;
  public static string name = "Окружность";
  public Circle(int x, int y, int r):this(r)//конструктор 1
  {
   this.x = x;
   this.y = y;
  }
  public Circle(int r)//конструктор 2
  {
   radius = r;
  }
  public void Print()
  {
   Console.Write(name);
   Console.WriteLine(" с центром в точке ({0},{1}) и радиусом {2}", x, y, radius);
   Console.WriteLine();
  }
  public int X //свойство для обращения к полю x
  {
   get
   {
    return x;
   }
   set
   {
    x = value;
   }
  }
  public int Y //свойство для обращения к полю y
  {
   get
   {
    return y;
   }
   set
   {
    y = value;
   }
  }
  public int R //свойство для обращения к полю radius
  {
   get
   {
    return radius;
   }
   set
   {
    radius = value;
   }
  }
  public double P //свойство только для чтения
  {
   get
   {
    return 2* Math.PI *radius;
   }

  }
  public double S //свойство только для чтения
  {
   get
   {
    return Math.PI *radius*radius;
   }

  }
 }

 class Program
 {
  static void Main()
  {
   Circle a = new Circle(0, 0, 1);  //вызов конструктора
   a.Print();
   //установка новых значений
   a.X=1;
   a.Y=1;
   a.R=10;
   //a.S=100; //ошибка - свойство доступно только для чтения
   Console.WriteLine("центр=({0},{1}) радиус={2} периметр={3:f2} площадь={4:f2}", a.X, a.Y, a.R, a.P, a.S);
  }
 }
```

### "Один класс — один файл"
С добавлением новых классов в программу резко увеличивается ее размер, что затрудняет ее прочтение. Поэтому следует руководствоваться одним простым принципом "один класс — один файл". Для того чтобы создать новый файл для класса `Circle` выполним следующие действия:

1. В окне *Solution Explorer* щелкните правой кнопкой на имени проекта *Hello* (на рисунке выделен жирным)

    ![Add class: Solution explorer](../img/13_02.gif)

2. Выполните команду *Add*/*Add Class…*

    ![Add class: Add](../img/13_03.gif)

    В поле *Name* напишите `Сircle.cs` и нажмите кнопку *Add*.

    ![Add class: Add name](../img/13_04.gif)

    А файл *Circle.cs* выглядит следующим образом:
    ```c#
    using System;

    namespace ConsoleApplication1
    {
    public class Circle
    {
      public Circle()
      {
      //
      // TODO: Add constructor logic here
      //
      }
    }
    }
    ```

3. Замените `namespace ConsoleApplication1` на namespace `MyProgram`, для того чтобы идентификаторы файлов `Program.cs` и `Circle.cs` были определены в одном пространстве имен.
4. Перенесите класс `Circle` из файла *Program.cs* в файл *Circle.cs*.
5. Теперь запустите программу и посмотрите, что она делает.

### Иерархия классов
https://intuit.ru/studies/courses/486/342/lecture/8244

Управлять большим количеством разрозненных классов довольно сложно. С этой проблемой можно справиться путем упорядочивания и ранжирования классов, то есть объединяя общие для нескольких классов свойства в одном классе и используя его в качестве базового. Эту возможность предоставляет механизм *наследования*.

*Наследование* применяется для следующих взаимосвязанных целей:

1. исключения из программы повторяющихся фрагментов кода;
2. упрощения модификации программы;
3. упрощения создания новых программ на основе существующих.

Наследование является единственной возможностью использовать объекты, исходный код которых недоступен, но в которые требуется внести изменения.

Кроме механизма наследования в данном разделе мы рассмотрим такие важные понятия ООП как *полиморфизм* и *инкапсуляцию*, которые также принимают участие в формировании иерархии классов.

### Наследование
Класс в С# может иметь произвольное количество потомков и только одного предка. При описании класса имя его предка записывается в заголовке класса после двоеточия. Если имя предка не указано, предком считается базовый класс всей иерархии `System.Object`. Синтаксис наследования:
```c#
[атрибуты] [спецификаторы] class имя_класса [: предки]
{ тело_класса}
```
Обратите внимание на то, что слово "предки" присутствует в описании класса во множественном числе, хотя класс может иметь только одного предка. Это связано с тем, что класс наряду с единственным предком-классом может наследовать интерфейсы (специальный вид классов, не имеющих реализации). Интерфейсы будут рассмотрены чуть позже.

Класс, который наследуется, называется **базовым**. Класс, который наследует базовый класс, называется **производным**. Производный класс наследует все переменные, методы, свойства, операторы и индексаторы, определенные в базовом классе, кроме того в производный класс могут быть добавлены уникальные элементы или переопределены существующие.

Рассмотрим наследование классов на примере геометрических фигур на плоскости. В качестве базового класса создадим класс `DemoPoint` (точка на плоскости), в качестве производного класса от `DemoPoint` класс `DemoLine` (отрезок на плоскости):
```c#
class DemoPoint //базовый класс
  {
    public int x;
    public int y;
    public void Show()
    {
      Console.WriteLine("({0}, {1})", x, y);
    }
  }

  class DemoLine : DemoPoint //производный класс
  {
    public int xEnd;
    public int yEnd;
    public  void Show()
    {
      Console.WriteLine("({0}, {1})-({2}, {3})", x, y ,xEnd, yEnd);
    }
  }

  class Program
  {
    static void Main()
    {
      DemoPoint point = new DemoPoint();
      point.x = 0;
      point.y = 0;
      point.Show();
      DemoLine line = new DemoLine();
      line.x = 2;  line.y = 2;
      line.xEnd = 10;  line.yEnd = 10;
      line.Show();
    }
  }
```

Экземпляр класса `DemoLine` с одинаковой легкостью использует как собственные поля и методы, так и унаследованные от класса `DemoPoint`. При этом, если метод производного класса называется также как и метод базового класса, то вызывается метод производного. Однако компилятором будет сгенерировано предупреждение:

![Warning](../img/15_01.gif)

Чтобы избежать подобного предупреждения необходимо перед одноименным членом производного класса, в данном случае перед методом `Show` в классе `DemoLine`, поставить спецификатор `new`. Данный спецификатор скрывает одноименный член базового класса и предупреждений выдаваться не будет.

### Использование защищенного доступа
В нашем примере поля `x` и `у` базового класса были открыты для доступа (`public`). Если убрать `public`, то поля автоматически станут закрытыми для доступа (`private`), в том числе и для доступа из производного класса. Решить проблему доступа к закрытым полям базового класса из производного можно двумя способами: используя свойства класса или спецификатор `protected`. При объявлении какого-то члена класса с помощью спецификатора `protected`, он становится закрытым для всех классов, кроме производных.
```c#
class DemoPoint
  {
      protected int x;
      protected int y;
      public void Show()
      {
        Console.WriteLine("({0}, {1})",x, y);
      }
    }

    class DemoLine : DemoPoint
    {
      public int xEnd;
      public int yEnd;
      public new void Show()
      {
        x=2; y=2; //доступ к закрытым полям базового класса
        Console.WriteLine("({0}, {1})-({2}, {3})", x, y, xEnd, yEnd);
      }
    }

    class Program
    {
      static void Main()
      {
        DemoPoint point = new DemoPoint();
        point.Show();
        DemoLine line = new DemoLine();
        //line.x = 2; line.y = 2; //доступ к полям закрыт
        line.xEnd = 10;    line.yEnd = 10;
        line.Show();
      }
    }
```

Обратите внимание на то, что доступ к полям `х` и `y` из класса `Program` невозможен, а из производного класса `DemoLine` возможен.

### Наследование конструкторов
В иерархии классов как базовые, так и производные классы могут иметь собственные конструкторы. При этом конструктор базового класса создает часть объекта, соответствующую базовому классу, а конструктор производного класса — часть объекта, соответствующую производному классу. Так как базовый класс не имеет доступа к элементам производного класса, то их конструкторы должны быть раздельными.

В предыдущем примере классы создавались за счет автоматического вызова средствами С# конструктора по умолчанию. Добавим конструктор только в производный класс `DemoLine`:
```c#
class DemoPoint
{
  protected int x;
  protected int y;
  public void Show()
  {
    Console.WriteLine("({0}, {1})",x, y);
  }
}

class DemoLine : DemoPoint
{
  public int xEnd;
  public int yEnd;
  new public void Show()
  {
    Console.WriteLine("({0}, {1})-({2}, {3})", x, y, xEnd, yEnd);
  }

  public DemoLine(int x1, int y1, int x2, int y2) //конструктор производного класса
  {
    x = x1;    y = y1;
    xEnd = x2; yEnd = y2;
  }
}

class Program
{
  static void Main()
  {
    DemoPoint point = new DemoPoint(); //вызывается конструктор по умолчанию
    point.Show();
    DemoLine line = new DemoLine(2, 2, 10, 10); //вызывается собственный конструктор
    line.Show();
  }
}
```
В данном случае конструктор определяется только в производном классе, поэтому часть объекта, соответствующая базовому классу, создается автоматически с помощью конструктора по умолчанию, а часть объекта, соответствующая производному классу, создается собственным конструктором.

Если же конструкторы определены и в базовом, и в производном классе, то процесс создания объектов несколько усложняется, т.к. должны выполниться конструкторы обоих классов. В этом случае используется ключевое слово `base`, которое имеет два назначения:

1. **позволяет вызвать конструктор базового класса**:

    Производный класс может вызывать конструктор, определенный в его базовом классе, используя расширенную форму объявления конструктора и ключевое слово `base`. Формат расширенного объявления:
    ```c#
    конструктор_производного_класса (список_параметров) : base (список_аргументов)
    { тело конструктора }
    ```
    где с помощью элемента списка аргументов передаются параметры конструктору базового класса. Например:
    ```c#
    class DemoPoint
        {
          protected int x;
          protected int y;
          public void Show()
          {
            Console.WriteLine("({0}, {1})",x, y);
    }
          public DemoPoint (int x, int y)//конструктор базового класса
          {
            this.x=x;  this.y=y;
          }
        }

    class DemoLine : DemoPoint
        {
          public int xEnd;
          public int yEnd;
          new public void Show()
          {
            Console.WriteLine("({0}, {1})-({2}, {3})", x, y, xEnd, yEnd);
          }

          public DemoLine(int x1, int y1, int x2, int y2):base(x1, y1) //конструктор производного класса
          {
            xEnd = x2; yEnd = y2;
          }
        }

    class Program
        {
          static void Main()
          {
            DemoPoint point= new DemoPoint(5, 5);
            point.Show();
            DemoLine line = new DemoLine( 2, 2, 10, 10);
            line.Show();
          }
        }
    ```

    > **Задание**. Объясните, почему в конструкторе базового класса для инициализации полей используется параметр `this`, а в конструкторе производного класса нет.

    В общем случае с помощью ключевого слова `base` можно вызвать конструктор любой формы, определенный в базовом классе. Реально же выполнится тот конструктор, параметры которого будут соответствовать переданным при вызове аргументам. Например:
    ```c#
    class DemoPoint
    {
      protected int x;
      protected int y;
      public void Show()
      {
        Console.WriteLine("({0}, {1})",x, y);
    }
      public DemoPoint () //конструктор базового класса по умолчанию
      {
        this.x=1;  this.y=1;
      }
      public DemoPoint (int x, int y) //конструктор базового класса с параметрами
      {
        this.x=x;  this.y=y;
      }
    }

    class DemoLine : DemoPoint
    {
      public int xEnd;
      public int yEnd;
      new public void Show()
      {
        Console.WriteLine("({0}, {1})-({2}, {3})", x, y, xEnd, yEnd);
      }
      public DemoLine() //конструктор производного класса по умолчанию
      {
        xEnd = 100; yEnd = 100;
      }
      public DemoLine(int x2, int y2) //конструктор производного класса с двумя параметрами
      {
        xEnd = x2; yEnd = y2;
      }
      //конструктор производного класса с четырьмя параметрами
      public DemoLine(int x1, int y1, int x2, int y2):base(x1, y1)
      {
        xEnd = x2; yEnd = y2;
      }
    }

    class Program
    {
      static void Main()
      {
        DemoPoint point1= new DemoPoint(); //вызов конструктора по умолчанию
        DemoPoint point2= new DemoPoint(5, 5); //вызов конструктора с параметрами
        point1.Show();
        point2.Show();
        DemoLine line1 = new DemoLine();//вызов конструктора по умолчанию
        DemoLine line2 = new DemoLine(4, 4);   //вызов конструктора с двумя параметрами
        //вызов конструктора с четырьмя параметрами
        DemoLine line3 = new DemoLine(2, 2, 10, 10);
        line1.Show();
        line2.Show();
        line3.Show();
      }
    }
    ```

    > **Задание**. Объясните, как при вызове конструкторе производного класса инициируется вызов конструктора базового класса.

2. **позволяет получить доступ к члену базового класса, который скрыт "за" членом производного класса.**

В этом случае ключевое слово `base` действует подобно ссылке `this`, за исключением того, что ссылка `base` всегда указывает на базовый класс для производного класса, в котором она используется. В этом случае формат ее записи выглядит следующим образом:
```c#
base.член_класса
```
Здесь в качестве элемента `член_класса` можно указывать либо метод, либо поле экземпляра. Эта форма ссылки `base` наиболее применима в тех случаях, когда имя члена в производном классе скрывает член с таким же именем в базовом классе.
```c#
class DemoPoint
  {
    protected int x;
    protected int y;
    public void Show()
    {
      Console.Write("({0}, {1})",x, y);
    }
    public DemoPoint (int x, int y)//конструктор базового класса
    {
      this.x=x;  this.y=y;
    }
  }

  class DemoLine : DemoPoint
  {
    public int xEnd;
    public int yEnd;
    new public void Show()
    {
      base.Show(); //вызов члена базового класса
      Console.WriteLine("-({0}, {1})", xEnd, yEnd);
    }

    public DemoLine(int x1, int y1, int x2, int y2):base(x1, y1) //конструктор производного класса
    {
      xEnd = x2; yEnd = y2;
    }
  }

  class Program
  {
    static void Main()
    {
      DemoLine line = new DemoLine( 2, 2, 10, 10);
      line.Show();
    }
  }
```
Несмотря на то, что метод `Show` в классе `DemoLine` скрывает одноименный метод в классе `DemoPoint`, ссылка `base` позволяет получить доступ к методу `Show` в базовом классе. Аналогично с помощью ссылки `base` можно получить доступ к одноименным полям базового класса.

### Многоуровневая иерархия
До сих пор мы рассматривали *простой тип* иерархии классов, который состоит из одного базового и одного производного класса. В общем случае можно построить иерархию классов, состоящую из любого количества уровней наследования. Рассмотрим следующую иерархию классов:

```mermaid
graph TB
A["Точка на плоскости<br>DemoPoint"] --- B["Точка в пространстве<br>DemoShape"]
A --- C["Отрезок на плоскости<br>DemoLine"] --- D["Треугольник на плоскости<br>DemoTriangle"]
```

```c#
class DemoPoint
{
  protected int x;
  protected int y;
  public void Show()
  {
    Console.WriteLine("точка на плоскости: ({0}, {1})",x, y);
  }
  public DemoPoint (int x, int y)
  {
    this.x=x;  this.y=y;
  }
}

class DemoShape : DemoPoint
{
  protected int z;
  new public void Show()
  {
    Console.WriteLine("точка в пространстве: ({0}, {1}, {2})", x, y, z);
  }
  public DemoShape(int x, int y, int z):base(x, y)
  {
    this.z=z;
  }
}

class DemoLine : DemoPoint
{
  protected int x2;
  protected int y2;
  new public void Show()
  {
    Console.WriteLine("отрезок на плоскости: ({0}, {1})-({2},{3})",x,y, x2, y2);
  }
  public DemoLine(int x1, int y1, int x2, int y2):base(x1, y1)
  {
    this.x2 = x2; this.y2 = y2;
  }
}

class DemoTriangle: DemoLine
{
  protected int x3;
  protected int y3;
  new public void Show()
  {
    Console.WriteLine("треугольник на плоскости: ({0}, {1})-({2},{3})-({4},{5})",x,y, x2, y2, x3, y3);
  }
  public DemoTriangle(int x1, int y1, int x2, int y2, int x3, int y3):base(x1, y1, x2, y2)
  {
    this.x3 = x3; this.y3 = y3;
  }
}

class Program
{
  static void Main()
  {
    DemoPoint point = new DemoPoint(1,1);
    point.Show();
    DemoShape pointShape = new DemoShape(1,1,1);
    pointShape.Show();
    DemoLine line = new DemoLine( 2, 2, 10, 10);
    line.Show();
    DemoTriangle triangle = new DemoTriangle (0,0,0,3,4,0);
    triangle.Show();
  }
}
```

### Переменные базового класса и производного класса
С# является языком со *строгой типизацией*, в нем требуется строгое соблюдение совместимости типов с учетом *стандартных преобразований типов*. Из чего следует, что *переменная* одного типа обычно не может ссылаться на *объект* другого ссылочного типа. За одним небольшим исключением — ссылочная *переменная* базового класса может ссылаться на *объект* любого производного класса. Продемонстрируем это на примере:
```c#
class DemoPoint
  {
    public int x;
    public int y;
    public void Show()
    {
      Console.WriteLine("точка на плоскости: ({0}, {1})",x, y);
    }
    public DemoPoint (int x, int y)
    {
      this.x=x;  this.y=y;
    }
  }

class DemoShape : DemoPoint
  {
    public int z;
    new public void Show()
    {
      Console.WriteLine("точка в пространстве: ({0}, {1}, {2})", x, y, z);
    }
    public DemoShape(int x, int y, int z):base(x, y)
    {
      this.z=z;
    }
}

class Program
  {
    static void Main()
    {
      DemoPoint point1 = new DemoPoint(0,1);
      Console.WriteLine("({0}, {1})",point1.x,point1.y);
      DemoShape pointShape = new DemoShape(2,3,4);
      Console.WriteLine("({0}, {1}, {2})",pointShape.x, pointShape.y, pointShape.z);
      DemoPoint point2=pointShape; //допустимая операция
      //ошибка - не соответствие типов указателей
      //pointShape=point1;
      Console.WriteLine("({0}, {1})", point2.x, point2.y);
      //ошибка, т.к. в классе DemoPoint нет поля z
      //Console.WriteLine("({0}, {1}, {2})", point2.x, point2.y, point2.z);
    }
  }
```
Ошибка возникнет и при попытке через объект `point2` обратиться к методу `Show`. Например, `point2.Show()`. В этом случае компилятор не сможет определить, какой метод `Show` вызвать — для базового или для производного класса. Для решения данной проблемы можно воспользоваться таким понятием как **полиморфизм**, который основывается на механизме виртуальных методов.

### Виртуальные методы
**Виртуальный метод** — это метод, который объявлен в базовом классе с использованием ключевого слова `virtual`, и затем переопределен в производном классе с помощью ключевого слова `override`. При этом если реализована многоуровневая *иерархия классов*, то каждый производный класс может иметь свою собственную версию виртуального метода. Этот факт особенно полезен в случае, когда доступ к объекту производного класса осуществляется через ссылочную переменную базового класса. В этой ситуации С# сам выбирает какую версию виртуального метода нужно вызвать. Этот выбор производится по типу объекта, на которую ссылается данная *ссылка*. Например:
```c#
class DemoPoint //базовый класс
  {
    protected int x;
    protected int y;
    public virtual void Show()  //виртуальный метод
    {
      Console.WriteLine("точка на плоскости: ({0}, {1})",x, y);
    }
    public DemoPoint (int x, int y)
    {
      this.x=x;  this.y=y;
    }
  }
  class DemoShape : DemoPoint //производный класс
  {
    protected int z;
    public override void Show() //перегрузка виртуального метода
    {
      Console.WriteLine("точка в пространстве: ({0}, {1}, {2})", x, y, z);
    }

    public DemoShape(int x, int y, int z):base(x, y) //конструктор производного класса
    {
      this.z=z;
    }

  }
  class DemoLine : DemoPoint //производный класс
  {
    protected int x2;
    protected int y2;
    public override void Show()  //перегрузка виртуального метода
    {
      Console.WriteLine("отрезок на плоскости: ({0}, {1})-({2},{3})",x,y, x2, y2);
    }
    public DemoLine(int x1, int y1, int x2, int y2):base(x1, y1)
    {
      this.x2 = x2; this.y2 = y2;
    }
  }

  class Program
  {
    static void Main()
    {
      DemoPoint point1 = new DemoPoint(0,1);
      point1.Show();
      DemoShape pointShape = new DemoShape(2,3,4);
      pointShape.Show();
      DemoLine line = new DemoLine(0,0, 10, 10);
      line.Show();
      Console.WriteLine();
      //использование ссылки базового класса на объекты производных классов
      DemoPoint point2=pointShape;
      point2.Show();
      point2=line;
      point2.Show();
    }
  }
```
Таким образом, благодаря полиморфизму через ссылочную переменную возможно обращаться к объектам разного типа, а также с помощью одного и того же имени выполнять различные действия.

### Абстрактные методы и классы
Иногда полезно создать базовый класс, определяющий только своего рода "пустой бланк", который унаследуют *все производные классы*, причем каждый из них заполнит этот "бланк" собственной информацией. Такой класс определяет структуру методов, которые *производные классы* должны реализовать, но сам при этом не обеспечивает реализации этих методов. Подобная ситуация может возникнуть, когда базовый класс попросту не в состоянии реализовать метод. В данной ситуации разрабатываются *абстрактные методы* или целые *абстрактные классы*.

**Абстрактный метод** создается с помощью модификатора `abstract`. Он не имеет тела и, следовательно, не реализуется базовым классом, а *производные* классы должны его обязательно переопределить. Абстрактный метод автоматически является виртуальным, однако использовать спецификатор `virtual` не нужно. Более того, если вы попытаетесь использовать два спецификатора одновременно, `abstract` и `virtual`, то компилятор выдаст сообщение об ошибке.

> **Задание**. Подумайте, можно ли спецификатор `abstract` применять в сочетании со спецификатором `static`. И объясните почему?

Если класс содержит один или несколько абстрактных классов, то его также нужно объявить как абстрактный, используя спецификатор `abstract` перед `class`. Поскольку абстрактный класс полностью не реализован, то невозможно создать экземпляр класса с помощью операции `new`. Например, если класс `Demo` определен как абстрактный, то попытка создать экземпляр класса `Demo` повлечет ошибку:
```c#
Demo a = new Demo();
```
Однако, можно создать массив ссылок, используя этот же абстрактный класс:
```c#
Demo [] Ob=new Demo[5];
```
Если производный класс наследует абстрактный, то он должен полностью переопределить *все абстрактные методы базового класса* или также быть объявлен как абстрактный. Таким образом, спецификатор `abstract` наследуется до тех пор, пока в производном классе не будут реализованы все абстрактные методы.

Рассмотрим пример использования абстрактных методов и классов.
```c#
abstract class Demo //абстрактный класс
  {
    abstract public void Show();//абстрактный метод
    abstract public double Dlina();//абстрактный метод
  }

  class DemoPoint:Demo //производный класс от абстрактного
  {
    protected int x;
    protected int y;
    public DemoPoint (int x, int y)
    {
      this.x=x;  this.y=y;
    }
    public override void Show() //переопределение абстрактного метода
    {
      Console.WriteLine("точка на плоскости: ({0}, {1})",x, y);
    }
    public override double Dlina()  //переопределение абстрактного метода
    {
      return Math.Sqrt(x*x+y*y);
    }
  }

  class DemoShape : DemoPoint //производный класс
  {
    protected int z;
    public DemoShape(int x, int y, int z):base(x, y)
    {
      this.z=z;
    }
    public override void Show()  //переопределение абстрактного метода
    {
      Console.WriteLine("точка в пространстве: ({0}, {1}, {2})", x, y, z);
    }
    public override double Dlina()  //переопределение абстрактного метода
    {
      return Math.Sqrt(x*x+y*y+z*z);
    }
  }

  class DemoLine : DemoPoint //производный класс
  {
    protected int x2;
    protected int y2;
    public DemoLine(int x1, int y1, int x2, int y2):base(x1, y1)
    {
      this.x2 = x2; this.y2 = y2;
    }
    public override void Show()  //переопределение абстрактного метода
    {
      Console.WriteLine("отрезок на плоскости: ({0}, {1})-({2},{3})",x,y, x2, y2);
    }
    public override double Dlina()  //переопределение абстрактного метода
    {
      return Math.Sqrt((x-x2)*(x-x2)+(y-y2)*(y-y2));
    }
  }

  class Program
  {
    static void Main()
    {
      Demo [] Ob=new Demo[5]; //массив ссылок
      //заполнения массива ссылками на объекты производных классов
      Ob[0]=new DemoPoint(1,1);
      Ob[1]=new DemoShape(1,1,1);
      Ob[2]=new DemoLine(0,3,4,0);
      Ob[3]=new DemoLine(2,1,2,10);
      Ob[4]=new DemoPoint(0,100);
      foreach (Demo a in Ob) //просмотр массива
      {
        a.Show();
        Console.WriteLine("Dlina: {0:f2}\n", a.Dlina());
      }
    }
  }
```

### Запрет наследования
В С# есть ключевое слово `sealed`, позволяющее описать класс, от которого запрещено наследование. Например:
```c#
sealed class Demo {   … }
class newDemo: Demo {   …  }  // ошибка
```

> **Задание**. Подумайте:
>
> 1. для чего может создаваться класс, от которого нельзя наследовать?
> 2. можно ли использовать сочетание спецификаторов `sealed` и `abstract` при описании класса, и почему?
