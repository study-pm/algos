# Вопросы к экзамену

- [1. Понятие алгоритма. Свойства алгоритмов.](#1-понятие-алгоритма-свойства-алгоритмов)
- [2. Способы описания алгоритмов: словесно-формульный, графический, на алгоритмическом языке.](#2-способы-описания-алгоритмов-словесно-формульный-графический-на-алгоритмическом-языке)
  - [Словесный способ](#словесный-способ)
  - [Формульно-словесный способ](#формульно-словесный-способ)
  - [Табличный способ](#табличный-способ)
  - [Графический способ](#графический-способ)
  - [Программный способ (текстовая запись)](#программный-способ-текстовая-запись)
  - [О взаимодополнении способов представления](#о-взаимодополнении-способов-представления)
- [3. Графический способ описания.](#3-графический-способ-описания)
  - [Главные элементы блок-схем алгоритмов](#главные-элементы-блок-схем-алгоритмов)
  - [Общие требования к блок-схеме](#общие-требования-к-блок-схеме)
  - [Решение алгоритма сортировки пузырьком](#решение-алгоритма-сортировки-пузырьком)
- [4. Базовые структуры алгоритмов. Виды алгоритмов](#4-базовые-структуры-алгоритмов-виды-алгоритмов)
- [5. Виды алгоритмов: линейный, разветвляющийся, циклический.](#5-виды-алгоритмов-линейный-разветвляющийся-циклический)
  - [Последовательный (линейный) алгоритм](#последовательный-линейный-алгоритм)
  - [Разветвляющиеся алгоритмы](#разветвляющиеся-алгоритмы)
  - [Циклические алгоритмы](#циклические-алгоритмы)
- [6. Принципы алгоритмизации.](#6-принципы-алгоритмизации)
  - [Этапы решения задач на ЭВМ](#этапы-решения-задач-на-эвм)
    - [I этап: Постановка задачи и её содержательный анализ](#i-этап-постановка-задачи-и-её-содержательный-анализ)
    - [II этап: Математическая формализация](#ii-этап-математическая-формализация)
    - [III этап: Алгоритмизация (построение алгоритма)](#iii-этап-алгоритмизация-построение-алгоритма)
    - [IV этап: Программирование](#iv-этап-программирование)
    - [V этап: Отладка и тестирование программы](#v-этап-отладка-и-тестирование-программы)
    - [VI этап: Проведение расчетов и анализ результатов](#vi-этап-проведение-расчетов-и-анализ-результатов)
  - [Распределение общего времени между этапами, необходимое для разработки сложных программ](#распределение-общего-времени-между-этапами-необходимое-для-разработки-сложных-программ)
  - [Общие рекомендации](#общие-рекомендации)
  - [Принципы алгоритмизации](#принципы-алгоритмизации)
  - [Принципы, лежащие в основе создания эффективных алгоритмов](#принципы-лежащие-в-основе-создания-эффективных-алгоритмов)
- [9. Отладка и тестирование алгоритмов.](#9-отладка-и-тестирование-алгоритмов)

1. Понятие алгоритма. Свойства алгоритмов.
2. Способы описания алгоритмов: словесно-формульный, графический, на алгоритмическом языке.
3. Графический способ описания.
4. Базовые структуры алгоритмов. Виды алгоритмов
5. Виды алгоритмов: линейный, разветвляющийся, циклический.
6. Принципы алгоритмизации.
7. Разветвляющийся алгоритм. Методика составления разветвляющихся алгоритмов.
8. Циклический алгоритм. Методика составления циклических алгоритмов.
9.  Отладка и тестирование алгоритмов.
10. Структура программы на языке С#.
11. Основные элементы языка С#: переменные, константы, алфавит, идентификаторы, ключевые слова, выражения, операторы.
12. Основные типы данных языка С#.
13. Объявление переменных и констант в языке С#. Инициализация переменных.
14. Операции и выражения в языке С#: арифметические, логические выражения. Основные математические функции.
15. Функция ввода.
16. Функции вывода.
17. Условный оператор в языке С#.
18. Оператор выбора в языке С#.
19. Циклические операторы в языке С#: цикл с предусловием, цикл с постусловием, цикл с параметром.
20. Операторы передачи управления break и continue.
21. Методы в С#
22. Понятие массива. Объявление и инициализация одномерного массива в языке С#.
23. Понятие массива. Объявление и инициализация многомерного массива в языке С#.
24. Строки в языке С#. Функции для работы со строками.
25. Функции в языке С#. Структура функции. Вызов функции. Прототип функции.
26. Рекурсивные функции.
27. Область видимости переменных. Локальные и глобальные переменные. Статические и динамические переменные
28. Ввод/вывод в С#.  Форматированный ввод/вывод в С#.
29. Файловый ввод/вывод в С#. Функции для работы с файлами.
30. Структуры в языке С#. Определение и инициализация структуры. Создание экземпляра структуры.
31. Базовые понятия ООП: объект, его свойства и методы, класс. Основные принципы ООП: инкапсуляция, наследование, полиморфизм.
32. Классы в С#.

## 1. Понятие алгоритма. Свойства алгоритмов.

**Алгоритм** – понятное и точное предписание (указание) исполнителю совершить
последовательность действий, направленных на достижение указанной цели или на решение поставленной задачи.

Исполнитель выполняет алгоритм **формально**.

**Система команд исполнителя** (**СКИ**) — совокупность команд, которые данный исполнитель умеет выполнять. Совокупность всех действий, которые исполнитель может выполнить в ответ на эти команды, называется **системой допустимых действий** Исполнителя.

**Свойства алгоритма**

1. Дискретность
2. Понятность (единственность толкования)
3. Определённость (детерминированность — обязательное завершение каждого из действий)
4. Конечность (результативность)
5. Выполнимость (эффективность)
6. Массовость (универсальность — возможность применения для целого класса задач)
7. Однозначность

## 2. Способы описания алгоритмов: словесно-формульный, графический, на алгоритмическом языке.
https://otus.ru/nest/post/1769/

**Алгоритмом** (algorithm) называют чёткое описание последовательности действий, направленных на решение конкретной задачи.

Способы описания алгоритмов:

- словесный (вербальный);
- графический (блок-схемы);
- математический (формулами);
- алгоритмические языки (программа).

### Словесный способ
Словесное описание алгоритма предполагает наличие некого словесного перечня действий. Пример: вам говорят что-то типа следующего: «Вычислите Z при условии, что Z = X + Y, когда X равен 0,89, а Y равен 1,286. Полученное значение Z следует возвести в куб и вычислить корень».

У такого способа есть недостаток: отсутствие наглядности выполнения процесса и чёткой формализации объектов алгоритма.

### Формульно-словесный способ
При использовании формульно-словесного способа инструкции задаются более чётко. Этот тот случай, когда словесные пояснения сопровождаются перечнем конкретных действий, плюс эти пояснения характеризуются наличием формальных символов и выражений (формул).

Для примера составим **формульно-словесный алгоритм** вычисления выражения: $z=2 \cdot x–(y+6)$:
- вводим значения $x$ и $y$;
- находим сумму ($y+6$);
- находим произведение ($2 \cdot x$);
- вычисляем $z$ как разность уже полученных выше значений: $z=2 \cdot x–(y+6)$;
- выводим $z$ как результат вычисления выражения.

Это более компактный и лаконичный метод, он нагляднее, но всё же строго формальным не является.

### Табличный способ
В случае применения табличного метода алгоритм задаётся в виде входных данных: расчётных форм и таблиц. Способ широко применяется в экономических расчетах. Исходные данные, как и результаты, заносятся в заголовки столбцов используемой таблицы. Простейший пример такого способа представления — та же таблица умножения.

### Графический способ
Этот метод ещё называют **способом блок-схем**. В данной ситуации каждый этап прохождения алгоритма представляется в виде геометрических фигур — так называемых «блоков», причём конкретная форма фигур зависит от выполняемой операции. Существует стандарт, регламентирующий размеры используемых графических блоков, а также их отображение, функции, формы и взаимное расположение. Направление работы алгоритма показывают линии соединения блоков.

Другое название способа — **визуальное представление**. При проектировании алгоритмов, представленных графически, придерживаются ряда правил:
- в начале алгоритма располагаются блоки ввода значений (входные данные);
- после ввода значений располагаются блоки обработки и блоки условия;
- алгоритм завершается блоками вывода значений, полученных в результате работы алгоритма (выходные данные);
- должен быть лишь один блок начала и один — окончания;
- межблочная связь указывается линиями (направленными либо ненаправленными);
- вычислительные формулы, данные и логические выражения размещаются внутри соответствующих блоков;
- возможно наличие комментариев в виде выносок.

![Основные элементы блок-схем](../img/img-fZfgBD.png)

Графический способ представления имеет практическое значение и используется не только в случае программирования. Его применяют при составлении информационных и структурных схем, инфографики и в иных ситуациях, когда нужно обеспечить чёткую визуализацию данных и графически отобразить последовательность расположения объектов алгоритма.

Создание блок-схемы алгоритма — важный и нужный этап решения поставленной задачи. Но при некоторых обстоятельствах этот этап можно считать промежуточным, так как в таком виде описанный алгоритм невозможно выполнить средствами ЭВМ. Зато графический способ представления значительно облегчает процесс дальнейшего создания компьютерной программы. О ней ниже.

### Программный способ (текстовая запись)
Программа представляет собой алгоритм, который записан как последовательность команд. Речь идёт о командах, понятных компьютеру, для чего используются различные языки программирования, представляющие собой системы кодирования предписаний с правилами их применения. Языки программирования характеризуются строго определённым синтаксисом, то есть свободное толкование конструкций не допускается.

В случае программного способа представления алгоритмическая последовательность записывается в виде компьютерной программы с высокой степенью формализации. В результате появляется возможность решать прикладные задачи.

### О взаимодополнении способов представления
Способы, представленные выше, нередко являются взаимодополняемыми:
- на этапе обсуждения используются словесные и словесно-формульные способы;
- на этапе проектирования рекомендуется использовать графические алгоритмы (графическое представление);
- на этапе проверки возможно табличное описание;
- на этапе непосредственного применения и решения прикладных задач используют текстовую запись, представленную в виде компьютерной программы.

## 3. Графический способ описания.
https://otus.ru/nest/post/1778/

**Блок-схема** — графическое изображение структуры алгоритма, в котором каждый этап процесса переработки данных представляется в виде геометрических фигур (блоков), имеющих определенную конфигурацию в зависимости от характера выполняемых при этом операций.

Существуют правила, единые обозначения и стандарты, регламентирующие применение визуального отображения схем алгоритмов. В России это ГОСТ 19.701-90 «Схемы алгоритмов программ, данных и систем», который близок к международному стандарту ISO 5807:1985.

### Главные элементы блок-схем алгоритмов
Прежде чем продолжить, стоит дать определение **блок-схемы** в соответствии со стандартом — речь идёт о совокупности символов, которые отвечают этапам работы алгоритма, причём эти символы имеют соединяющие линии:
- **пунктирную** — для соединения с комментарием;
- **сплошную** — отображает зависимости по управлению, допускается наличие на ней стрелки.

В соответствии со стандартом составитель может не указывать стрелку, если дуга направляется сверху вниз или слева направо.

Также существуют и дополнительные виды линий, которые применяются, когда надо дать описание блок-схемам параллельных алгоритмов, однако в этой статье мы их рассматривать не будем, как и ряд других дополнительных спецсимволов.

В таблице ниже дан перечень основных символов, используемых при описании алгоритмов:

![Основные элементы блок-схем](../img/Screenshot_1-1801-c116d0.png)

![Flowchart items](../img/algos-block-schemes.png)

![Flowchart items](../img/algo-block-scheme-0.png)

![Flowchart items](../img/algo-block-scheme-1.png)

![Flowchart items](../img/algo-block-scheme-2.png)

![Flowchart items](../img/algo-block-scheme-3.png)

### Общие требования к блок-схеме

https://prohor-off.ru/pascal/pascal2.html#:~:text=%D0%A2%D0%B8%D0%BF%D1%8B%20%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%BE%D0%B2.,%D0%B8%20%D0%B8%D0%BC%D0%B5%D0%B5%D1%82%20%D0%BD%D0%B5%D1%81%D0%BA%D0%BE%D0%BB%D1%8C%D0%BA%D0%BE%20%D0%B2%D0%B5%D1%82%D0%B2%D0%B5%D0%B9%20%D0%BE%D0%B1%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B8.

- Стрелки в блок—схемах указываются только справа — налево и снизу — вверх.
- Блоки рисуются карандашом по линейке, текст пишется ручкой.
- Ширина всех блоков должна быть одинакова (блоки должны располагаться друг под другом).
- Все блоки алгоритма нумеруются.

### Решение алгоритма сортировки пузырьком
В этом примере давайте попробуем дать описание решению алгоритма сортировки по методу пузырьком (метод сортировки вставками). Здесь применяются 2 цикла. Во вложенном цикле осуществляется попарное сравнение элементов. Если нарушается порядок, происходит перестановка. По итогу выполнения одной итерации во внутреннем цикле, наибольший элемент будет смещён в самый конец массива. Внешний цикл будет выполняться, пока полностью весь массив не отсортируется.

![Блок-схема алгоритма сортировки пузырьком](../img/Screenshot_3-1801-3fbca6.avif)

На схеме отображено применение символов конца и начала цикла. Здесь условие внешнего цикла (`А`) проверяется в конце (с постусловием), а функционирует он до тех пор, пока переменная `hasSwapped` является `true`. Во внутреннем цикле используется предусловие для перебора пар элементов, которые сравниваются. Если они располагаются в неправильном порядке, они переставляются путём вызова внешней процедуры (`swap`). Для понимания назначения внешней процедуры, как и порядка следования аргументов этой процедуры, нужно оставлять комментарии. Если функция возвращает значение, то комментарий можно написать к символу-терминатору конца.

## 4. Базовые структуры алгоритмов. Виды алгоритмов

В 1969 году нидерландский ученый Эдсгер Дийкстра доказал важную теорему. Суть ее в том, что для решения любой логической задачи можно составить алгоритм, используя лишь три алгоритмических структуры: *следование*, *ветвление* и *повторение*. Эти структуры называют **базовыми**. В соответствии с этим различают три основных типа структур алгоритма:

- линейный (следование);
- альтернативный (разветвление);
- циклический (повторение, итерация).

Соответственно этим структурам выделяют следующие виды алгоритмов (по ходу выполнения):

- последовательный;
- разветвлённый;
- циклический.

Самой простой структурой является **«следование**».

Алгоритм реализован через последовательную алгоритмическую структуру, если все команды этого алгоритма выполняются один раз, причем в том порядке, в котором они записаны.

Алгоритм, основанный на конструкции «следование» называется **линейным алгоритмом**. Примером такого алгоритма может служить алгоритм вычисления дискриминанта квадратного уравнения, блок-схема которого приведена на рисунке 1.

![Линейный алгоритм](../img/189d6b2e-f240-4a57-84d2-9cda9492d4c5.png)

**Рис. 1**

Следующей конструкцией является **«ветвление»**. Она встречается, если действия алгоритма зависят от некоторого условия.

Алгоритм реализован через алгоритмическую конструкцию «ветвление», если от входных данных зависит, какие команды будут выполняться. Условие, которое выражает эту зависимость, фактически является вопросом, на который можно ответить либо «да», либо «нет».

Существуют полная и неполная формы ветвления.

В полной форме если условие выполняется, то алгоритм переходит к выполнению первой серии команд, а если не выполняется — то ко второй.

В неполной форме алгоритм выполняет серию команд только если условие истинно. В противном случае ничего не происходит.

Алгоритм, основанный на конструкции «ветвление» называется **разветвляющимся алгоритмом**. Примером такого алгоритма может служить алгоритм нахождения корней квадратного уравнения, блок-схема которого приведена на рисунке 2.

![Разветвляющийся алгоритм](../img/ea5d55a4-b598-437f-8466-bed779d81bb2.png)

**Рис. 2**

И, наконец, последняя алгоритмическая конструкция — «**повторение**».

Алгоритм реализован с использованием алгоритмической конструкции «повторение», если некая группа подряд идущих шагов алгоритма (она называется телом цикла) может выполняться многократно в зависимости от входных данных.

Алгоритм, содержащий конструкцию «повторение» называется **циклическим алгоритмом**.

Существует несколько разновидностей циклических алгоритмов.

Первый — **цикл с заданным условием продолжения работы** (цикл с предусловием или цикл-пока).

Второй — **цикл с заданным условием окончания работы** (цикл с постусловием или цикл-до).

И третий — **цикл с заданным числом повторений** (цикл с параметром).

![Циклический алгоритм](../img/4e287700-accd-44ba-9988-6395cd366d8d.png)

Доказано, что при решении задач можно ограничиться только одним циклом — циклом с предусловием. Но в ряде случаев цикл с постусловием или цикл с параметром делают решение задачи легче.

Примером решения одной и той же задачи с помощью различных циклов может служить задача возведения некоторого числа $a$ в натуральную степень $n$.

![Решение задачи разными циклами](../img/9e9d2b8d-8156-43b1-8828-f84a97fc6935.png)

## 5. Виды алгоритмов: линейный, разветвляющийся, циклический.

Алгоритмы бывают трёх типов:

- **последовательный** — действия выполняются по порядку друг за другом;
- **циклический** — организовывает повторение действий;
- **разветвляющийся** — содержит одно или несколько логических условий и имеет несколько ветвей обработки. Разветвление даёт возможность выбора варианта действий в зависимости от результатов анализа исходных условий.

### Последовательный (линейный) алгоритм

<div style="background-color: white">

![](../img/al09.gif)

</div>

Самой простой структурой является **«следование**».

Алгоритм реализован через последовательную алгоритмическую структуру, если все команды этого алгоритма выполняются один раз, причем в том порядке, в котором они записаны.

Алгоритм, основанный на конструкции «следование» называется **линейным алгоритмом**. Примером такого алгоритма может служить алгоритм вычисления дискриминанта квадратного уравнения, блок-схема которого приведена на рисунке 1.

![Линейный алгоритм](../img/189d6b2e-f240-4a57-84d2-9cda9492d4c5.png)

**Рис. 1**

### Разветвляющиеся алгоритмы

<div style="background-color: white">

| Условный оператор `IF` (полная запись) | Условный оператор `IF` (краткая запись) | Оператор выбора `CASE` |
-- | -- | --
![](../img/al14.gif) | ![](../img/al15.gif) | ![](../img/al16.gif)

</div>

Следующей конструкцией является **«ветвление»**. Она встречается, если действия алгоритма зависят от некоторого условия.

Алгоритм реализован через алгоритмическую конструкцию «ветвление», если от входных данных зависит, какие команды будут выполняться. Условие, которое выражает эту зависимость, фактически является вопросом, на который можно ответить либо «да», либо «нет».

Существуют полная и неполная формы ветвления.

В полной форме если условие выполняется, то алгоритм переходит к выполнению первой серии команд, а если не выполняется — то ко второй.

В неполной форме алгоритм выполняет серию команд только если условие истинно. В противном случае ничего не происходит.

Алгоритм, основанный на конструкции «ветвление» называется **разветвляющимся алгоритмом**. Примером такого алгоритма может служить алгоритм нахождения корней квадратного уравнения, блок-схема которого приведена на рисунке 2.

![Разветвляющийся алгоритм](../img/ea5d55a4-b598-437f-8466-bed779d81bb2.png)

### Циклические алгоритмы

<div style="background-color: white">

| Безусловный оператор цикла `FOR` | Условный оператор цикла с предусловием `WHILE` | Условный оператор цикла с постусловием `REPEAT` |
-- | -- | --
![](../img/al12.gif) | ![](../img/al13.gif) | ![](../img/al11.gif)

</div>

И, наконец, последняя алгоритмическая конструкция — «**повторение**».

Алгоритм реализован с использованием алгоритмической конструкции «повторение», если некая группа подряд идущих шагов алгоритма (она называется телом цикла) может выполняться многократно в зависимости от входных данных.

Алгоритм, содержащий конструкцию «повторение» называется **циклическим алгоритмом**.

Существует несколько разновидностей циклических алгоритмов.

Первый — **цикл с заданным условием продолжения работы** (цикл с предусловием или цикл-пока).

Второй — **цикл с заданным условием окончания работы** (цикл с постусловием или цикл-до).

И третий — **цикл с заданным числом повторений** (цикл с параметром).

![Циклический алгоритм](../img/4e287700-accd-44ba-9988-6395cd366d8d.png)

Доказано, что при решении задач можно ограничиться только одним циклом — циклом с предусловием. Но в ряде случаев цикл с постусловием или цикл с параметром делают решение задачи легче.

Примером решения одной и той же задачи с помощью различных циклов может служить задача возведения некоторого числа $a$ в натуральную степень $n$.

![Решение задачи разными циклами](../img/9e9d2b8d-8156-43b1-8828-f84a97fc6935.png)

## 6. Принципы алгоритмизации.

### Этапы решения задач на ЭВМ

| | | |
-- | -- | --
| 1. | Постановка задачи. | Работа без ЭВМ
| 2. | Математическая формализация. | Работа без ЭВМ
| 3. | Алгоритмизация. | Работа без ЭВМ
| 4. | Программирование | Работа на ЭВМ
| 5. | Отладка и тестирование программы | Работа на ЭВМ
| 6. | Проведение расчетов и анализ результатов |

#### I этап: Постановка задачи и её содержательный анализ

① Формируется условие задачи:

1. Что дано? (Анализ исходных данных) → **аргументы**
2. Что необходимо определить? → **результат**
3. Какие данные допустимы и в каких единицах измерения?
4. Какие результаты и в каком виде должны быть получены?

② Всем величинам присвоить имена.

#### II этап: Математическая формализация

Реально существующие объекты, предметы, явления заменяются математическими формулами.

#### III этап: Алгоритмизация (построение алгоритма)

При разработке алгоритма решения сложной задачи следует использовать метод структурного подхода:

1. Алгоритм собирается из 3-х основных базовых структур.
2. Разработка алгоритма «сверху вниз».
3. Сквозной структурный контроль.

**Сквозной структурный контроль** представляет собой совокупность технологических операций контроля, позволяющих обеспечить как можно более раннее обнаружение ошибок в процессе разработки. Термин «сквозной» в названии отражает выполнение контроля на всех этапах разработки. Термин «структурный» означает наличие четких рекомендаций по выполнению контролирующих операций на каждом этапе.

Сквозной структурный контроль должен выполняться на специальных контрольных сессиях, в которых, помимо разработчиков, могут участвовать специально приглашенные эксперты. Одна из первых сессий должна быть организована на этапе определения спецификаций. На этой сессии проверяют полноту и точность спецификаций, при этом целесообразно присутствие заказчика или специалиста по предметной области, которые смогут определить, насколько правильно и полно определены спецификации программного обеспечения.

На этапе проектирования вручную по частям проверяют алгоритмы разрабатываемого программного обеспечения на конкретных наборах данных и сверяют полученные результаты с соответствующими спецификациями. Основная задача – убедиться в правильности понимания спецификаций и проанализировать достоинства и недостатки концептуальных решений, закладываемых в проект.

На этапе реализации проверяют план (последовательность) реализации модулей, набор тестов, а также тексты отдельных модулей.

Для всех этапов целесообразно иметь списки наиболее часто встречающихся ошибок, которые формируют по литературным источникам и исходя из опыта предыдущих разработок. Такие списки позволяют сконцентрировать усилия на конкретных моментах, а не проверять все подряд. При этом все найденные ошибки фиксируют в специальном документе, но не исправляют их (более подробно см. §9.2).

Помимо раннего обнаружения ошибок, сквозной структурный контроль обеспечивает своевременную подготовку качественной документации по проекту.

https://studfile.net/preview/2007545/page:17/

#### IV этап: Программирование

- выбор языка программирования;
- запись алгоритма на выбранном языке программирования.

#### V этап: Отладка и тестирование программы

Ошибки программы:

- синтаксические;
- логические.

**Тест** – набор исходных данных, для которых заранее известен результат.

#### VI этап: Проведение расчетов и анализ результатов

Производится расчет программы (выполнение на ЭВМ).

После выполнения программы необходимо провести обработку и осмысление результатов.

### Распределение общего времени между этапами, необходимое для разработки сложных программ

![Распределение времени между этапами](../img/algos-time-distribution.png)

### Общие рекомендации

1. Необходимо создать программу универсальной.
2. Вместо констант лучше использовать переменные.
3. Программа должна иметь комментарии.

### Принципы алгоритмизации
https://studfile.net/preview/9012806/page:3/

На сегодняшний день самой популярной методикой программирования является **структурное программирование** "сверху – вниз". Эта технология программирования представляет собой процесс пошагового разбиения алгоритма на все более мелкие части с целью получить такие элементы, для которых можно легко написать конкретные предписания.

Структурная алгоритмизация основывается на двух принципах:

1) последовательная детализация "сверху - вниз";

2) ограниченность базового набора структур для построения алгоритмов любой степени сложности.

Из принципов вытекают требования структурного программирования:

1) программа должна составляться мелкими шагами, таким образом, сложная задача разбивается на достаточно простые, легко воспринимаемые части;

2) логика программы должна опираться на минимальное число достаточно простых базовых управляющих структур.

Базовый набор структурной алгоритмизации содержит линейные, разветвляющиеся и циклические структуры.

Можно перечислить основные свойства и достоинства структурного программирования:

1) возможность преодоления барьера сложности программ;

2) возможность демонстрации правильности программ на различных этапах решения задачи;

3) наглядность программ;

4) простота модификации программ.

### Принципы, лежащие в основе создания эффективных алгоритмов
https://studfile.net/preview/9012806/page:3/

Разработке алгоритма предшествуют такие этапы, как **формализация и моделирование** задачи. **Формализация** предполагает замену словесной формулировки решаемой задачи краткими символьными обозначениями, близкими к обозначениям в языках программирования или к математическим. **Моделирование** задачи является важнейшим этапом, целью которого является поиск общей концепции решения. Обычно моделирование выполняется путем выдвижения гипотез решения задачи и их проверке любым рациональным способом (прикидочные расчеты, физическое моделирование и т.д.). Результатом каждой проверки является либо принятие гипотезы, либо отказ от нее и разработка новой.

При разработке алгоритма используют следующие основные принципы.

1. **Принцип поэтапной детализации алгоритма** (другое название — "проектирование сверху-вниз"). Этот принцип предполагает первоначальную разработку алгоритма в виде укрупненных блоков (разбиение задачи на подзадачи) и их постепенную детализацию.

2. **Принцип "от главного к второстепенному"**, предполагающий составление алгоритма, начиная с главной конструкции. При этом, часто, приходится "достраивать" алгоритм в обратную сторону, например, от середины к началу.

3. **Принцип структурирования**, т.е. использования только типовых алгоритмических структур при построении алгоритма. Нетиповой структурой считается, например, циклическая конструкция, содержащая в теле цикла дополнительные выходы из цикла. В программировании нетиповые структуры появляются в результате злоупотребления командой безусловного перехода (GoTo). При этом программа хуже читается и труднее отлаживается.

## 9. Отладка и тестирование алгоритмов.
https://studfile.net/preview/9012806/page:4/

**Отладка алгоритма** – это процесс выявления и исправления ошибок в нём. Суть отладки алгоритма в том, что выбирается некоторый набор исходных данных, называемый *тестовым набором* (*тестом*), и задача с этим набором решается дважды: один раз — исполнением алгоритма, второй раз — каким-либо иным способом, исходя из условия задачи (например, вручную). При совпадении результатов алгоритм считается верным.

**Задачи отладки**. При всех методах отладки алгоритмов система отладки с той или иной степенью автоматизации должна решать следующие задачи:
- обнаруживать наличие ошибок;
- проводить диагностику и локализацию ошибок;
- устранять ошибки и корректировать алгоритмы и программы, а также соответствующую документацию;
- информировать оператора о ходе, вычислений, переменных величинах и передачах управления в отлаживаемых алгоритмах и программах.

Самыми сложными среди перечисленных являются задачи обнаружения, диагностики и локализации ошибок.

**Тест** – набор исходных данных, для которых заранее известен результат.

**Тестирование** – это проверка в процессе эксперимента соответствия (*конформности*) реализации требованиям, заданным в виде спецификации. Тестирование **полное**, если оно однозначно отвечает на вопрос: есть в реализации ошибки или нет, где под ошибкой понимается нарушение требований, то есть *неконформность*.

Набор тестов называется **значимым**, если каждая конформная реализация его проходит; **исчерпывающий**, если каждая неконформная реализация его не проходит; **полный**, если он значимый и исчерпывающий.

**Избыточное тестирование** — тестирование алгоритма со всеми возможными комбинациями всех возможных входных данных во всех возможных условиях выполнения.

Тестирование алгоритма позволяет выявить логические ошибки построения алгоритма. Подобные ошибки можно обнаружить при тестировании алгоритма на большом количестве различных тестовых наборов данных, так как далеко не при каждом сочетании входных данных логические ошибки построения алгоритма дают о себе знать. Следовательно, эффективное проектирование текстовых наборов данных - задача достаточно сложная.

**Структурное тестирование** основывается на детальном изучении логики алгоритма и подборе тестов, позволяющих обеспечить максимально возможное количество проверяемых операторов, логических ветвлений и условий.

При использовании структурного тестирования для построения тестовых наборов данных возможно использование следующих критериев:

1) набор данных должен обеспечивать выполнение каждого оператора, по крайней мере, один раз;

2) тестовые наборы данных в узлах ветвления с более чем одним условием должны обеспечивать принятие каждым условием значения истина или ложь хотя бы по одному разу;

3) тестовые наборы данных в узлах ветвления с более чем одним условием должны обеспечивать перебор всех возможных сочетаний значений условий в одном узле ветвления.
